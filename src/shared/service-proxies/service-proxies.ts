//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param redirectUri (optional) 
     * @return Success
     */
    signIn(scheme: string, redirectUri?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignIn/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param redirectUri (optional) 
     * @param scope (optional) 
     * @param loginHint (optional) 
     * @param domainHint (optional) 
     * @param claims (optional) 
     * @param policy (optional) 
     * @return Success
     */
    challenge(scheme: string, redirectUri?: string | undefined, scope?: string | undefined, loginHint?: string | undefined, domainHint?: string | undefined, claims?: string | undefined, policy?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/Challenge/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (loginHint === null)
            throw new Error("The parameter 'loginHint' cannot be null.");
        else if (loginHint !== undefined)
            url_ += "loginHint=" + encodeURIComponent("" + loginHint) + "&";
        if (domainHint === null)
            throw new Error("The parameter 'domainHint' cannot be null.");
        else if (domainHint !== undefined)
            url_ += "domainHint=" + encodeURIComponent("" + domainHint) + "&";
        if (claims === null)
            throw new Error("The parameter 'claims' cannot be null.");
        else if (claims !== undefined)
            url_ += "claims=" + encodeURIComponent("" + claims) + "&";
        if (policy === null)
            throw new Error("The parameter 'policy' cannot be null.");
        else if (policy !== undefined)
            url_ += "policy=" + encodeURIComponent("" + policy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallenge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallenge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChallenge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    signOut(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignOut/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    resetPassword(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/ResetPassword/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editProfile(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/EditProfile/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientDocumentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    document(documentGuid: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientDocuments/Document/{documentGuid}";
        if (documentGuid === undefined || documentGuid === null)
            throw new Error("The parameter 'documentGuid' must be defined.");
        url_ = url_.replace("{documentGuid}", encodeURIComponent("" + documentGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDocument(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    contractDocuments(clientId: number, includeLinkedClients: boolean, includeExpired: boolean): Observable<ClientContractViewRootDto> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/ContractDocuments/{includeLinkedClients}/{includeExpired}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        if (includeExpired === undefined || includeExpired === null)
            throw new Error("The parameter 'includeExpired' must be defined.");
        url_ = url_.replace("{includeExpired}", encodeURIComponent("" + includeExpired));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientContractViewRootDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientContractViewRootDto>;
        }));
    }

    protected processContractDocuments(response: HttpResponseBase): Observable<ClientContractViewRootDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientContractViewRootDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientContractViewRootDto>(null as any);
    }

    /**
     * @return Success
     */
    generalAttachments(clientId: number, includeLinkedClients: boolean): Observable<ClientAttachmentInfoOutputDto[]> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralAttachments/{includeLinkedClients}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAttachmentInfoOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAttachmentInfoOutputDto[]>;
        }));
    }

    protected processGeneralAttachments(response: HttpResponseBase): Observable<ClientAttachmentInfoOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAttachmentInfoOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAttachmentInfoOutputDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAvailableStatusForClientAttachments(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/ClientDocuments/GetAvailableStatusForClientAttachmentsAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableStatusForClientAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableStatusForClientAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdNameDto[]>;
        }));
    }

    protected processGetAvailableStatusForClientAttachments(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(null as any);
    }

    /**
     * @param formFile (optional) 
     * @return Success
     */
    generalFilePost(clientId: number, attachmentFileTypeId: number, formFile?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile/{attachmentFileTypeId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (attachmentFileTypeId === undefined || attachmentFileTypeId === null)
            throw new Error("The parameter 'attachmentFileTypeId' must be defined.");
        url_ = url_.replace("{attachmentFileTypeId}", encodeURIComponent("" + attachmentFileTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile === null || formFile === undefined)
            throw new Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFilePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFilePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFilePost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    generalFileDelete(clientId: number, clientAttachmentGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile/{clientAttachmentGuid}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientAttachmentGuid === undefined || clientAttachmentGuid === null)
            throw new Error("The parameter 'clientAttachmentGuid' must be defined.");
        url_ = url_.replace("{clientAttachmentGuid}", encodeURIComponent("" + clientAttachmentGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFileDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFileDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFileDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generalFilePut(clientId: number, body?: UpdateClientAttachmentFileInfoInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFilePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFilePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFilePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    evaluations(clientId: number, includeLinkedClients: boolean, maxAnswerDate: moment.Moment): Observable<ClientEvaluationOutputDto[]> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/Evaluations/{includeLinkedClients}/{maxAnswerDate}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        if (maxAnswerDate === undefined || maxAnswerDate === null)
            throw new Error("The parameter 'maxAnswerDate' must be defined.");
        url_ = url_.replace("{maxAnswerDate}", encodeURIComponent(maxAnswerDate ? "" + maxAnswerDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientEvaluationOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientEvaluationOutputDto[]>;
        }));
    }

    protected processEvaluations(response: HttpResponseBase): Observable<ClientEvaluationOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientEvaluationOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientEvaluationOutputDto[]>(null as any);
    }

    /**
     * @return Success
     */
    evaluation(legacyConsultantId: number, evalTenantId: number, evalGuid: string, useLocalLanguage: boolean, forcePdf: boolean): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{legacyConsultantId}/Evaluation/{evalTenantId}/{evalGuid}/{useLocalLanguage}/{forcePdf}";
        if (legacyConsultantId === undefined || legacyConsultantId === null)
            throw new Error("The parameter 'legacyConsultantId' must be defined.");
        url_ = url_.replace("{legacyConsultantId}", encodeURIComponent("" + legacyConsultantId));
        if (evalTenantId === undefined || evalTenantId === null)
            throw new Error("The parameter 'evalTenantId' must be defined.");
        url_ = url_.replace("{evalTenantId}", encodeURIComponent("" + evalTenantId));
        if (evalGuid === undefined || evalGuid === null)
            throw new Error("The parameter 'evalGuid' must be defined.");
        url_ = url_.replace("{evalGuid}", encodeURIComponent("" + evalGuid));
        if (useLocalLanguage === undefined || useLocalLanguage === null)
            throw new Error("The parameter 'useLocalLanguage' must be defined.");
        url_ = url_.replace("{useLocalLanguage}", encodeURIComponent("" + useLocalLanguage));
        if (forcePdf === undefined || forcePdf === null)
            throw new Error("The parameter 'forcePdf' must be defined.");
        url_ = url_.replace("{forcePdf}", encodeURIComponent("" + forcePdf));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEvaluation(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

@Injectable()
export class ClientPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientSalesPut(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientSalesGet(clientPeriodId: string): Observable<ClientPeriodSalesDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodSalesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodSalesDataDto>;
        }));
    }

    protected processClientSalesGet(response: HttpResponseBase): Observable<ClientPeriodSalesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodSalesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodSalesDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientContractsPut(clientPeriodId: string, body?: ClientPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientContractsPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientContractsPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientContractsPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientContractsGet(clientPeriodId: string): Observable<ClientPeriodContractsDataQueryDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientContractsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientContractsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodContractsDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodContractsDataQueryDto>;
        }));
    }

    protected processClientContractsGet(response: HttpResponseBase): Observable<ClientPeriodContractsDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodContractsDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodContractsDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientFinancePut(clientPeriodId: string, body?: ClientPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientFinancePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientFinancePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientFinancePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientFinanceGet(clientPeriodId: string): Observable<ClientPeriodFinanceDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientFinanceGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientFinanceGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodFinanceDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodFinanceDataDto>;
        }));
    }

    protected processClientFinanceGet(response: HttpResponseBase): Observable<ClientPeriodFinanceDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodFinanceDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodFinanceDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientExtend(clientPeriodId: string, body?: ExtendClientPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-extend";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processClientExtend(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientChange(clientPeriodId: string, body?: ChangeClientPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-change";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processClientChange(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addConsultantPeriod(clientPeriodId: string, body?: ConsultantPeriodAddDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/add-consultant-period";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddConsultantPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddConsultantPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddConsultantPeriod(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    projectType(projectTypeId: number): Observable<ProjectTypeConfigurationDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/project-type/{projectTypeId}";
        if (projectTypeId === undefined || projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' must be defined.");
        url_ = url_.replace("{projectTypeId}", encodeURIComponent("" + projectTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectTypeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectTypeConfigurationDto>;
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<ProjectTypeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectTypeConfigurationDto>(null as any);
    }

    /**
     * @return Success
     */
    availableConsultants(clientPeriodId: string): Observable<AvailableConsultantDto[]> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/available-consultants";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableConsultantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableConsultantDto[]>;
        }));
    }

    protected processAvailableConsultants(response: HttpResponseBase): Observable<AvailableConsultantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AvailableConsultantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableConsultantDto[]>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    stepResponsible(clientPeriodId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/{stepType}/step-responsible?";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientSalesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    editStart(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts/edit-start";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientFinanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    editStart(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance/edit-start";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clientPeriod(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clients(clientId: number): Observable<ClientDetailsDto> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDetailsDto>;
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriod(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesType (optional) 
     * @param deliveryType (optional) 
     * @param workflowStatus (optional) 
     * @param responsibleEmployees (optional) 
     * @param showOnlyWorkflowsWithNewSales (optional) 
     * @param showOnlyWorkflowsWithExtensions (optional) 
     * @param showOnlyWorkflowsWithPendingStepsForSelectedEmployees (optional) 
     * @param showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees (optional) 
     * @param includeTerminated (optional) 
     * @param includeDeleted (optional) 
     * @param search (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflow(invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesType?: number | undefined, deliveryType?: number | undefined, workflowStatus?: WorkflowStatus | undefined, responsibleEmployees?: number[] | undefined, showOnlyWorkflowsWithNewSales?: boolean | undefined, showOnlyWorkflowsWithExtensions?: boolean | undefined, showOnlyWorkflowsWithPendingStepsForSelectedEmployees?: boolean | undefined, showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees?: boolean | undefined, includeTerminated?: boolean | undefined, includeDeleted?: boolean | undefined, search?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<WorkflowListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Workflow?";
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesType === null)
            throw new Error("The parameter 'salesType' cannot be null.");
        else if (salesType !== undefined)
            url_ += "SalesType=" + encodeURIComponent("" + salesType) + "&";
        if (deliveryType === null)
            throw new Error("The parameter 'deliveryType' cannot be null.");
        else if (deliveryType !== undefined)
            url_ += "DeliveryType=" + encodeURIComponent("" + deliveryType) + "&";
        if (workflowStatus === null)
            throw new Error("The parameter 'workflowStatus' cannot be null.");
        else if (workflowStatus !== undefined)
            url_ += "WorkflowStatus=" + encodeURIComponent("" + workflowStatus) + "&";
        if (responsibleEmployees === null)
            throw new Error("The parameter 'responsibleEmployees' cannot be null.");
        else if (responsibleEmployees !== undefined)
            responsibleEmployees && responsibleEmployees.forEach(item => { url_ += "ResponsibleEmployees=" + encodeURIComponent("" + item) + "&"; });
        if (showOnlyWorkflowsWithNewSales === null)
            throw new Error("The parameter 'showOnlyWorkflowsWithNewSales' cannot be null.");
        else if (showOnlyWorkflowsWithNewSales !== undefined)
            url_ += "ShowOnlyWorkflowsWithNewSales=" + encodeURIComponent("" + showOnlyWorkflowsWithNewSales) + "&";
        if (showOnlyWorkflowsWithExtensions === null)
            throw new Error("The parameter 'showOnlyWorkflowsWithExtensions' cannot be null.");
        else if (showOnlyWorkflowsWithExtensions !== undefined)
            url_ += "ShowOnlyWorkflowsWithExtensions=" + encodeURIComponent("" + showOnlyWorkflowsWithExtensions) + "&";
        if (showOnlyWorkflowsWithPendingStepsForSelectedEmployees === null)
            throw new Error("The parameter 'showOnlyWorkflowsWithPendingStepsForSelectedEmployees' cannot be null.");
        else if (showOnlyWorkflowsWithPendingStepsForSelectedEmployees !== undefined)
            url_ += "ShowOnlyWorkflowsWithPendingStepsForSelectedEmployees=" + encodeURIComponent("" + showOnlyWorkflowsWithPendingStepsForSelectedEmployees) + "&";
        if (showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees === null)
            throw new Error("The parameter 'showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees' cannot be null.");
        else if (showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees !== undefined)
            url_ += "ShowOnlyWorkflowsWithUpcomingStepsForSelectedEmployees=" + encodeURIComponent("" + showOnlyWorkflowsWithUpcomingStepsForSelectedEmployees) + "&";
        if (includeTerminated === null)
            throw new Error("The parameter 'includeTerminated' cannot be null.");
        else if (includeTerminated !== undefined)
            url_ += "IncludeTerminated=" + encodeURIComponent("" + includeTerminated) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowListItemDtoPaginatedList>;
        }));
    }

    protected processWorkflow(response: HttpResponseBase): Observable<WorkflowListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param isInternalContract (optional) 
     * @param pm3ConsultantId (optional) 
     * @return Success
     */
    workflowIntegration(periodId: string, isInternalContract?: boolean | undefined, pm3ConsultantId?: number | undefined): Observable<WorkflowPeriodForLegacyContractDto> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/{periodId}?";
        if (periodId === undefined || periodId === null)
            throw new Error("The parameter 'periodId' must be defined.");
        url_ = url_.replace("{periodId}", encodeURIComponent("" + periodId));
        if (isInternalContract === null)
            throw new Error("The parameter 'isInternalContract' cannot be null.");
        else if (isInternalContract !== undefined)
            url_ += "isInternalContract=" + encodeURIComponent("" + isInternalContract) + "&";
        if (pm3ConsultantId === null)
            throw new Error("The parameter 'pm3ConsultantId' cannot be null.");
        else if (pm3ConsultantId !== undefined)
            url_ += "pm3ConsultantId=" + encodeURIComponent("" + pm3ConsultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowIntegration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowIntegration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowPeriodForLegacyContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowPeriodForLegacyContractDto>;
        }));
    }

    protected processWorkflowIntegration(response: HttpResponseBase): Observable<WorkflowPeriodForLegacyContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowPeriodForLegacyContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowPeriodForLegacyContractDto>(null as any);
    }
}

@Injectable()
export class ClientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param countryFilter (optional) 
     * @param ownerFilter (optional) 
     * @param isActive (optional) 
     * @param excludeDeleted (optional) 
     * @param onlyWrongfullyDeletedInHubspot (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    list(search?: string | undefined, countryFilter?: number[] | undefined, ownerFilter?: number[] | undefined, isActive?: boolean | undefined, excludeDeleted?: boolean | undefined, onlyWrongfullyDeletedInHubspot?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/list?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (countryFilter === null)
            throw new Error("The parameter 'countryFilter' cannot be null.");
        else if (countryFilter !== undefined)
            countryFilter && countryFilter.forEach(item => { url_ += "countryFilter=" + encodeURIComponent("" + item) + "&"; });
        if (ownerFilter === null)
            throw new Error("The parameter 'ownerFilter' cannot be null.");
        else if (ownerFilter !== undefined)
            ownerFilter && ownerFilter.forEach(item => { url_ += "ownerFilter=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        if (onlyWrongfullyDeletedInHubspot === null)
            throw new Error("The parameter 'onlyWrongfullyDeletedInHubspot' cannot be null.");
        else if (onlyWrongfullyDeletedInHubspot !== undefined)
            url_ += "onlyWrongfullyDeletedInHubspot=" + encodeURIComponent("" + onlyWrongfullyDeletedInHubspot) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientListItemDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ClientListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param search (optional) 
     * @param projectTypeFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clientOverview(search?: string | undefined, projectTypeFilter?: string[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientOverviewListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/client-overview?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectTypeFilter === null)
            throw new Error("The parameter 'projectTypeFilter' cannot be null.");
        else if (projectTypeFilter !== undefined)
            projectTypeFilter && projectTypeFilter.forEach(item => { url_ += "projectTypeFilter=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientOverviewListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientOverviewListItemDtoPaginatedList>;
        }));
    }

    protected processClientOverview(response: HttpResponseBase): Observable<ClientOverviewListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientOverviewListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientOverviewListItemDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    specialRatesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialRateDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialRateDto[]>;
        }));
    }

    protected processSpecialRatesGet(response: HttpResponseBase): Observable<ClientSpecialRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialRateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialRateDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPost(clientId: number, body?: AddClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPut(clientId: number, body?: UpdateClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    specialFeesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialFeeDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialFeeDto[]>;
        }));
    }

    protected processSpecialFeesGet(response: HttpResponseBase): Observable<ClientSpecialFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialFeeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPost(clientId: number, body?: AddClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPut(clientId: number, body?: UpdateClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    requestTrack(clientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientRequestTrackItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/request-track?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTrack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientRequestTrackItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientRequestTrackItemDtoPaginatedList>;
        }));
    }

    protected processRequestTrack(response: HttpResponseBase): Observable<ClientRequestTrackItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRequestTrackItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRequestTrackItemDtoPaginatedList>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflowTrack(clientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientWorkflowTrackItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/workflow-track?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowTrack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientWorkflowTrackItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientWorkflowTrackItemDtoPaginatedList>;
        }));
    }

    protected processWorkflowTrack(response: HttpResponseBase): Observable<ClientWorkflowTrackItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientWorkflowTrackItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientWorkflowTrackItemDtoPaginatedList>(null as any);
    }

    /**
     * @param excludeDeleted (optional) 
     * @return Success
     */
    contacts(clientId: number, excludeDeleted?: boolean | undefined): Observable<ContactDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/contacts?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDto[]>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrl(clientId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrl";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrlEditContactLogin(clientId: number, contactId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrlEditContactLogin/{contactId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrlEditContactLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrlEditContactLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrlEditContactLogin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    hubspotClientUrl(clientId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/HubspotClientUrlAsync";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHubspotClientUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHubspotClientUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processHubspotClientUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class SpecialRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    delete(clientId: number, clientSpecialRateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{clientSpecialRateId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialRateId === undefined || clientSpecialRateId === null)
            throw new Error("The parameter 'clientSpecialRateId' must be defined.");
        url_ = url_.replace("{clientSpecialRateId}", encodeURIComponent("" + clientSpecialRateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SpecialFeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    delete(clientId: number, clientSpecialFeeId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{clientSpecialFeeId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialFeeId === undefined || clientSpecialFeeId === null)
            throw new Error("The parameter 'clientSpecialFeeId' must be defined.");
        url_ = url_.replace("{clientSpecialFeeId}", encodeURIComponent("" + clientSpecialFeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConsultantPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    consultantSalesGet(consultantPeriodId: string): Observable<ConsultantPeriodSalesDataDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodSalesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodSalesDataDto>;
        }));
    }

    protected processConsultantSalesGet(response: HttpResponseBase): Observable<ConsultantPeriodSalesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodSalesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodSalesDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantSalesPut(consultantPeriodId: string, body?: ConsultantPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantContractsGet(consultantPeriodId: string): Observable<ConsultantPeriodContractsDataQueryDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantContractsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantContractsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodContractsDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodContractsDataQueryDto>;
        }));
    }

    protected processConsultantContractsGet(response: HttpResponseBase): Observable<ConsultantPeriodContractsDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodContractsDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodContractsDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantContractsPut(consultantPeriodId: string, body?: ConsultantPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantContractsPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantContractsPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantContractsPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantFinanceGet(consultantPeriodId: string): Observable<ConsultantPeriodFinanceDataDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantFinanceGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantFinanceGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodFinanceDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodFinanceDataDto>;
        }));
    }

    protected processConsultantFinanceGet(response: HttpResponseBase): Observable<ConsultantPeriodFinanceDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodFinanceDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodFinanceDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantFinancePut(consultantPeriodId: string, body?: ConsultantPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantFinancePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantFinancePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantFinancePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extend(consultantPeriodId: string, body?: ExtendConsultantPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/extend";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    change(consultantPeriodId: string, body?: ChangeConsultantPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/change";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processChange(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    stepResponsible(consultantPeriodId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/{stepType}/step-responsible?";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConsultantSalesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(consultantPeriodId: string, body?: ConsultantPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConsultantContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    editStart(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts/edit-start";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(consultantPeriodId: string, body?: ConsultantPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConsultantFinanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    editStart(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance/edit-start";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(consultantPeriodId: string, body?: ConsultantPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clientPeriodSync(clientPeriodId: string): Observable<ContractSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{clientPeriodId}/ClientPeriodSync";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSyncResultDto>;
        }));
    }

    protected processClientPeriodSync(response: HttpResponseBase): Observable<ContractSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSyncResultDto>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriodSync(consultantPeriodId: string): Observable<ContractSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{consultantPeriodId}/ConsultantPeriodSync";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSyncResultDto>;
        }));
    }

    protected processConsultantPeriodSync(response: HttpResponseBase): Observable<ContractSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSyncResultDto>(null as any);
    }

    /**
     * @return Success
     */
    workflowTerminationSync(workflowTerminationId: string): Observable<ContractSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{workflowTerminationId}/WorkflowTerminationSync";
        if (workflowTerminationId === undefined || workflowTerminationId === null)
            throw new Error("The parameter 'workflowTerminationId' must be defined.");
        url_ = url_.replace("{workflowTerminationId}", encodeURIComponent("" + workflowTerminationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowTerminationSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowTerminationSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSyncResultDto>;
        }));
    }

    protected processWorkflowTerminationSync(response: HttpResponseBase): Observable<ContractSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSyncResultDto>(null as any);
    }

    /**
     * @param workflowTerminationId (optional) 
     * @return Success
     */
    consultantTerminationSync(consultantTerminationId: string, workflowTerminationId?: string | undefined): Observable<ContractSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{consultantTerminationId}/ConsultantTerminationSync?";
        if (consultantTerminationId === undefined || consultantTerminationId === null)
            throw new Error("The parameter 'consultantTerminationId' must be defined.");
        url_ = url_.replace("{consultantTerminationId}", encodeURIComponent("" + consultantTerminationId));
        if (workflowTerminationId === null)
            throw new Error("The parameter 'workflowTerminationId' cannot be null.");
        else if (workflowTerminationId !== undefined)
            url_ += "workflowTerminationId=" + encodeURIComponent("" + workflowTerminationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTerminationSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTerminationSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContractSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContractSyncResultDto>;
        }));
    }

    protected processConsultantTerminationSync(response: HttpResponseBase): Observable<ContractSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractSyncResultDto>(null as any);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    current(): Observable<CurrentEmployeeDto> {
        let url_ = this.baseUrl + "/api/Employee/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentEmployeeDto>;
        }));
    }

    protected processCurrent(response: HttpResponseBase): Observable<CurrentEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentEmployeeDto>(null as any);
    }
}

@Injectable()
export class EmployeeNotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    enabledNotifications(): Observable<EmployeeNotificationDto[]> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/enabled-notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnabledNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnabledNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeNotificationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeNotificationDto[]>;
        }));
    }

    protected processEnabledNotifications(response: HttpResponseBase): Observable<EmployeeNotificationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeNotificationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeNotificationDto[]>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    addNotification(notificationId?: number | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/add-notification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeNotification(notificationId?: number | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/remove-notification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    countries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Enum/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    currencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCurrencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tenants(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/tenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processTenants(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    deliveryTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/delivery-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliveryTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliveryTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDeliveryTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoiceFrequencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoice-frequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceFrequencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoiceFrequencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoicingTimes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoicing-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicingTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicingTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoicingTimes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    rateUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/rate-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRateUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    salesTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/sales-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSalesTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    signerRoles(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/signer-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSignerRoles(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    margins(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/margins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMargins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMargins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processMargins(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateReportingUnits(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-reporting-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateReportingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateReportingUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateReportingUnits(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDuration(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDuration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDuration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDuration(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDeadline(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-deadline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDeadline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDeadline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDeadline(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    workflowStatuses(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/workflow-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processWorkflowStatuses(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    stepTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/step-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processStepTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    workflowProcessTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/workflow-process-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowProcessTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowProcessTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processWorkflowProcessTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    terminationReasons(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/termination-reasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTerminationReasons(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    terminationTimes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/termination-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTerminationTimes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    emagineOffice(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/emagine-office";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmagineOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmagineOffice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmagineOffice(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contractExpirationNotificationInterval(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/contract-expiration-notification-interval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractExpirationNotificationInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractExpirationNotificationInterval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processContractExpirationNotificationInterval(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    commissionFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    commissionTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    recipientTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/recipient-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecipientTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecipientTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRecipientTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectCategory(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectCategory(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    employmentType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/employment-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmploymentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmploymentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmploymentType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    discount(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/discount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDiscount(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    expectedWorkloadUnit(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/expected-workload-unit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpectedWorkloadUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpectedWorkloadUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processExpectedWorkloadUnit(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantInsuranceOption(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/consultant-insurance-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantInsuranceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantInsuranceOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processConsultantInsuranceOption(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    legalContractStatuses(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/legal-contract-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLegalContractStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLegalContractStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processLegalContractStatuses(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }
}

@Injectable()
export class HubSpotCardDataFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    workflows(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Workflows?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processWorkflows(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    requests(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Requests?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequests(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    contactPerson(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/ContactPerson?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContactPerson(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    camLoginLink(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/CamLoginLink?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamLoginLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamLoginLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotContractFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    listContracts(userId?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotContractFetch/ListContracts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListContracts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processListContracts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotInstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    auth(code?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/auth?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    syncAllWithHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncAllWithHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllWithHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllWithHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncAllWithHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    syncClientParents(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncClientParents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncClientParents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncClientParents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncClientParents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HubSpotTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testCreateClientInHubSpot(): Observable<SimplePublicObject> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestCreateClientInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCreateClientInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCreateClientInHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimplePublicObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimplePublicObject>;
        }));
    }

    protected processTestCreateClientInHubSpot(response: HttpResponseBase): Observable<SimplePublicObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimplePublicObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePublicObject>(null as any);
    }

    /**
     * @return Success
     */
    testSyncUpdateToLegacy(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestSyncUpdateToLegacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSyncUpdateToLegacy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSyncUpdateToLegacy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSyncUpdateToLegacy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBigCompany(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotTest/GetBigCompanyAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetBigCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param nameFilter (optional) 
     * @param showAll (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    employees(nameFilter?: string | undefined, showAll?: boolean | undefined, idsToExclude?: number[] | undefined): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Employees?";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "nameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (showAll === null)
            throw new Error("The parameter 'showAll' cannot be null.");
        else if (showAll !== undefined)
            url_ += "showAll=" + encodeURIComponent("" + showAll) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto[]>;
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    consultants(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<ConsultantResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Consultants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantResultDto[]>;
        }));
    }

    protected processConsultants(response: HttpResponseBase): Observable<ConsultantResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantResultDto[]>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    consultantsWithSourcingRequest(clientId?: number | undefined, filter?: string | undefined, maxRecords?: number | undefined): Observable<ConsultantWithSourcingRequestResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Consultants-With-Sourcing-Request?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantsWithSourcingRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantsWithSourcingRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantWithSourcingRequestResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantWithSourcingRequestResultDto[]>;
        }));
    }

    protected processConsultantsWithSourcingRequest(response: HttpResponseBase): Observable<ConsultantWithSourcingRequestResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantWithSourcingRequestResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantWithSourcingRequestResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    suppliers(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<SupplierResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Suppliers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierResultDto[]>;
        }));
    }

    protected processSuppliers(response: HttpResponseBase): Observable<SupplierResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    clients(filter?: string | undefined, maxRecords?: number | undefined): Observable<ClientResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Clients?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientResultDto[]>;
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientResultDto[]>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    contacts(clientId?: number | undefined, filter?: string | undefined, maxRecords?: number | undefined): Observable<ContactResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Contacts?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactResultDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactResultDto[]>(null as any);
    }
}

@Injectable()
export class MainOverviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param mainOverviewStatusesForSales (optional) 
     * @param accountManagers (optional) 
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param margins (optional) 
     * @param search (optional) 
     * @param cutOffDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflows(mainOverviewStatusesForSales?: MainOverviewStatus[] | undefined, accountManagers?: number[] | undefined, invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, margins?: number[] | undefined, search?: string | undefined, cutOffDate?: moment.Moment | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<MainOverviewItemForWorkflowDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/MainOverview/workflows?";
        if (mainOverviewStatusesForSales === null)
            throw new Error("The parameter 'mainOverviewStatusesForSales' cannot be null.");
        else if (mainOverviewStatusesForSales !== undefined)
            mainOverviewStatusesForSales && mainOverviewStatusesForSales.forEach(item => { url_ += "MainOverviewStatusesForSales=" + encodeURIComponent("" + item) + "&"; });
        if (accountManagers === null)
            throw new Error("The parameter 'accountManagers' cannot be null.");
        else if (accountManagers !== undefined)
            accountManagers && accountManagers.forEach(item => { url_ += "AccountManagers=" + encodeURIComponent("" + item) + "&"; });
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (margins === null)
            throw new Error("The parameter 'margins' cannot be null.");
        else if (margins !== undefined)
            margins && margins.forEach(item => { url_ += "Margins=" + encodeURIComponent("" + item) + "&"; });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (cutOffDate === null)
            throw new Error("The parameter 'cutOffDate' cannot be null.");
        else if (cutOffDate !== undefined)
            url_ += "CutOffDate=" + encodeURIComponent(cutOffDate ? "" + cutOffDate.toISOString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewItemForWorkflowDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewItemForWorkflowDtoPaginatedList>;
        }));
    }

    protected processWorkflows(response: HttpResponseBase): Observable<MainOverviewItemForWorkflowDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainOverviewItemForWorkflowDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewItemForWorkflowDtoPaginatedList>(null as any);
    }

    /**
     * @param mainOverviewStatusesForSales (optional) 
     * @param accountManagers (optional) 
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param margins (optional) 
     * @param search (optional) 
     * @param cutOffDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    consultants(mainOverviewStatusesForSales?: MainOverviewStatus[] | undefined, accountManagers?: number[] | undefined, invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, margins?: number[] | undefined, search?: string | undefined, cutOffDate?: moment.Moment | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<MainOverviewItemForConsultantDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/MainOverview/consultants?";
        if (mainOverviewStatusesForSales === null)
            throw new Error("The parameter 'mainOverviewStatusesForSales' cannot be null.");
        else if (mainOverviewStatusesForSales !== undefined)
            mainOverviewStatusesForSales && mainOverviewStatusesForSales.forEach(item => { url_ += "MainOverviewStatusesForSales=" + encodeURIComponent("" + item) + "&"; });
        if (accountManagers === null)
            throw new Error("The parameter 'accountManagers' cannot be null.");
        else if (accountManagers !== undefined)
            accountManagers && accountManagers.forEach(item => { url_ += "AccountManagers=" + encodeURIComponent("" + item) + "&"; });
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (margins === null)
            throw new Error("The parameter 'margins' cannot be null.");
        else if (margins !== undefined)
            margins && margins.forEach(item => { url_ += "Margins=" + encodeURIComponent("" + item) + "&"; });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (cutOffDate === null)
            throw new Error("The parameter 'cutOffDate' cannot be null.");
        else if (cutOffDate !== undefined)
            url_ += "CutOffDate=" + encodeURIComponent(cutOffDate ? "" + cutOffDate.toISOString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewItemForConsultantDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewItemForConsultantDtoPaginatedList>;
        }));
    }

    protected processConsultants(response: HttpResponseBase): Observable<MainOverviewItemForConsultantDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainOverviewItemForConsultantDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewItemForConsultantDtoPaginatedList>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @param mainOverviewUserSelectedStatusForSales (optional) 
     * @return Success
     */
    setUserSelectedStatusForWorkflow(workflowId?: string | undefined, mainOverviewUserSelectedStatusForSales?: MainOverviewStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MainOverview/setUserSelectedStatusForWorkflow?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (mainOverviewUserSelectedStatusForSales === null)
            throw new Error("The parameter 'mainOverviewUserSelectedStatusForSales' cannot be null.");
        else if (mainOverviewUserSelectedStatusForSales !== undefined)
            url_ += "MainOverviewUserSelectedStatusForSales=" + encodeURIComponent("" + mainOverviewUserSelectedStatusForSales) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserSelectedStatusForWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserSelectedStatusForWorkflow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserSelectedStatusForWorkflow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @param consultantId (optional) 
     * @param mainOverviewUserSelectedStatusForSales (optional) 
     * @return Success
     */
    setUserSelectedStatusForConsultant(workflowId?: string | undefined, consultantId?: number | undefined, mainOverviewUserSelectedStatusForSales?: MainOverviewStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MainOverview/setUserSelectedStatusForConsultant?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "ConsultantId=" + encodeURIComponent("" + consultantId) + "&";
        if (mainOverviewUserSelectedStatusForSales === null)
            throw new Error("The parameter 'mainOverviewUserSelectedStatusForSales' cannot be null.");
        else if (mainOverviewUserSelectedStatusForSales !== undefined)
            url_ += "MainOverviewUserSelectedStatusForSales=" + encodeURIComponent("" + mainOverviewUserSelectedStatusForSales) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserSelectedStatusForConsultant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserSelectedStatusForConsultant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserSelectedStatusForConsultant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    viewTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/MainOverview/view-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processViewTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    statuses(): Observable<MainOverviewStatusDto[]> {
        let url_ = this.baseUrl + "/api/MainOverview/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewStatusDto[]>;
        }));
    }

    protected processStatuses(response: HttpResponseBase): Observable<MainOverviewStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainOverviewStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewStatusDto[]>(null as any);
    }
}

@Injectable()
export class NotificationTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendActionRequired(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send-action-required?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendActionRequired(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendActionRequired(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendActionRequired(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendContractExpiration(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send-contract-expiration?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendContractExpiration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendContractExpiration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendContractExpiration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendConsultantExtension(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send-consultant-extension?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendConsultantExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendConsultantExtension(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendConsultantExtension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendWorkflowStepResponsibleChanged(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send-Workflow-Step-Responsible-Changed?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendWorkflowStepResponsibleChanged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendWorkflowStepResponsibleChanged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendWorkflowStepResponsibleChanged(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartNewWorkflowInputDto | undefined): Observable<NewWorkflowCreatedDto> {
        let url_ = this.baseUrl + "/api/Workflow/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewWorkflowCreatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewWorkflowCreatedDto>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<NewWorkflowCreatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewWorkflowCreatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewWorkflowCreatedDto>(null as any);
    }

    /**
     * @return Success
     */
    workflowExists(requestConsultantId: number): Observable<WorkflowAlreadyExistsDto> {
        let url_ = this.baseUrl + "/api/Workflow/{requestConsultantId}/workflow-exists";
        if (requestConsultantId === undefined || requestConsultantId === null)
            throw new Error("The parameter 'requestConsultantId' must be defined.");
        url_ = url_.replace("{requestConsultantId}", encodeURIComponent("" + requestConsultantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowAlreadyExistsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowAlreadyExistsDto>;
        }));
    }

    protected processWorkflowExists(response: HttpResponseBase): Observable<WorkflowAlreadyExistsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowAlreadyExistsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowAlreadyExistsDto>(null as any);
    }

    /**
     * @param clientPeriodId (optional) 
     * @param includeProcesses (optional) 
     * @return Success
     */
    clientPeriods(workflowId: string, clientPeriodId?: string | undefined, includeProcesses?: boolean | undefined): Observable<WorkflowDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/clientPeriods?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' cannot be null.");
        else if (clientPeriodId !== undefined)
            url_ += "clientPeriodId=" + encodeURIComponent("" + clientPeriodId) + "&";
        if (includeProcesses === null)
            throw new Error("The parameter 'includeProcesses' cannot be null.");
        else if (includeProcesses !== undefined)
            url_ += "includeProcesses=" + encodeURIComponent("" + includeProcesses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowDto>;
        }));
    }

    protected processClientPeriods(response: HttpResponseBase): Observable<WorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowDto>(null as any);
    }

    /**
     * @return Success
     */
    overview(workflowId: string): Observable<WorkflowOverviewDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/overview";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowOverviewDto>;
        }));
    }

    protected processOverview(response: HttpResponseBase): Observable<WorkflowOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowOverviewDto>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    history(workflowId: string, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<WorkflowHistoryDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/history?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowHistoryDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowHistoryDtoPaginatedList>;
        }));
    }

    protected processHistory(response: HttpResponseBase): Observable<WorkflowHistoryDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowHistoryDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowHistoryDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    notesGet(workflowId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/notes";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processNotesGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notesPut(workflowId: string, body?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/notes";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationStart(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-start";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSalesGet(workflowId: string): Observable<WorkflowTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationSalesGet(response: HttpResponseBase): Observable<WorkflowTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesPut(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesComplete(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractGet(workflowId: string): Observable<WorkflowTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationContractGet(response: HttpResponseBase): Observable<WorkflowTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractPut(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractComplete(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingGet(workflowId: string): Observable<WorkflowTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationSourcingGet(response: HttpResponseBase): Observable<WorkflowTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingPut(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingComplete(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    terminationStepResponsible(workflowId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/{stepType}/termination-step-responsible?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationDelete(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantStart(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-start?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSalesGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSalesGet(response: HttpResponseBase): Observable<ConsultantTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesPut(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesComplete(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales-complete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationConsultantContractGet(response: HttpResponseBase): Observable<ConsultantTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractPut(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractComplete(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSourcingGet(response: HttpResponseBase): Observable<ConsultantTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingPut(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingComplete(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantTerminationId (optional) 
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    terminationConsultantStepResponsible(stepType: StepType, workflowId: string, consultantTerminationId?: string | undefined, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/{stepType}/termination-consultant-step-responsible?";
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantTerminationId === null)
            throw new Error("The parameter 'consultantTerminationId' cannot be null.");
        else if (consultantTerminationId !== undefined)
            url_ += "consultantTerminationId=" + encodeURIComponent("" + consultantTerminationId) + "&";
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantDelete(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-delete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkflowIntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    workflowPeriodLegalContractStatus(body?: WorkflowPeriodLegalContractStatusUpdateInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/WorkflowPeriodLegalContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowPeriodLegalContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowPeriodLegalContractStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkflowPeriodLegalContractStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param body (optional) 
     * @return Success
     */
    workflowPeriodInfosForIncomeReport(tenantId?: number | undefined, fromDate?: moment.Moment | undefined, toDate?: moment.Moment | undefined, body?: InputWorkflowPeriodInfoForIncomeReportDto[] | undefined): Observable<OutputWorkflowPeriodInfoForIncomeReportDto> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/WorkflowPeriodInfosForIncomeReport?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowPeriodInfosForIncomeReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowPeriodInfosForIncomeReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputWorkflowPeriodInfoForIncomeReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputWorkflowPeriodInfoForIncomeReportDto>;
        }));
    }

    protected processWorkflowPeriodInfosForIncomeReport(response: HttpResponseBase): Observable<OutputWorkflowPeriodInfoForIncomeReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputWorkflowPeriodInfoForIncomeReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputWorkflowPeriodInfoForIncomeReportDto>(null as any);
    }
}

export class AddClientSpecialFeeDto implements IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AddClientSpecialRateDto implements IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AvailableConsultantDto implements IAvailableConsultantDto {
    consultantName?: string | undefined;
    consultantId?: number;
    externalId?: string;

    constructor(data?: IAvailableConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantName = _data["consultantName"];
            this.consultantId = _data["consultantId"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): AvailableConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantName"] = this.consultantName;
        data["consultantId"] = this.consultantId;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface IAvailableConsultantDto {
    consultantName?: string | undefined;
    consultantId?: number;
    externalId?: string;
}

export class ChangeClientPeriodDto implements IChangeClientPeriodDto {
    cutoverDate?: moment.Moment;
    clientNewLegalContractRequired?: boolean;
    consultantPeriods?: NewContractRequiredConsultantPeriodDto[] | undefined;

    constructor(data?: IChangeClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cutoverDate = _data["cutoverDate"] ? moment(_data["cutoverDate"].toString()) : <any>undefined;
            this.clientNewLegalContractRequired = _data["clientNewLegalContractRequired"];
            if (Array.isArray(_data["consultantPeriods"])) {
                this.consultantPeriods = [] as any;
                for (let item of _data["consultantPeriods"])
                    this.consultantPeriods!.push(NewContractRequiredConsultantPeriodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangeClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cutoverDate"] = this.cutoverDate ? this.cutoverDate.format('YYYY-MM-DD') : <any>undefined;
        data["clientNewLegalContractRequired"] = this.clientNewLegalContractRequired;
        if (Array.isArray(this.consultantPeriods)) {
            data["consultantPeriods"] = [];
            for (let item of this.consultantPeriods)
                data["consultantPeriods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChangeClientPeriodDto {
    cutoverDate?: moment.Moment;
    clientNewLegalContractRequired?: boolean;
    consultantPeriods?: NewContractRequiredConsultantPeriodDto[] | undefined;
}

export class ChangeConsultantPeriodDto implements IChangeConsultantPeriodDto {
    cutoverDate?: moment.Moment;
    newLegalContractRequired?: boolean;

    constructor(data?: IChangeConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cutoverDate = _data["cutoverDate"] ? moment(_data["cutoverDate"].toString()) : <any>undefined;
            this.newLegalContractRequired = _data["newLegalContractRequired"];
        }
    }

    static fromJS(data: any): ChangeConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cutoverDate"] = this.cutoverDate ? this.cutoverDate.format('YYYY-MM-DD') : <any>undefined;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        return data;
    }
}

export interface IChangeConsultantPeriodDto {
    cutoverDate?: moment.Moment;
    newLegalContractRequired?: boolean;
}

export class ClientAddressDto implements IClientAddressDto {
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IClientAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ClientAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IClientAddressDto {
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
}

export class ClientAttachmentInfoOutputDto implements IClientAttachmentInfoOutputDto {
    clientAttachmentGuid?: string;
    documentStorageGuid?: string;
    attachmentTypeId?: number;
    documentType?: DocumentTypeEnum;
    headline?: string | undefined;
    filename?: string | undefined;
    updatedBy?: string | undefined;
    dateUpdated?: moment.Moment;

    constructor(data?: IClientAttachmentInfoOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientAttachmentGuid = _data["clientAttachmentGuid"];
            this.documentStorageGuid = _data["documentStorageGuid"];
            this.attachmentTypeId = _data["attachmentTypeId"];
            this.documentType = _data["documentType"];
            this.headline = _data["headline"];
            this.filename = _data["filename"];
            this.updatedBy = _data["updatedBy"];
            this.dateUpdated = _data["dateUpdated"] ? moment(_data["dateUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientAttachmentInfoOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAttachmentInfoOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientAttachmentGuid"] = this.clientAttachmentGuid;
        data["documentStorageGuid"] = this.documentStorageGuid;
        data["attachmentTypeId"] = this.attachmentTypeId;
        data["documentType"] = this.documentType;
        data["headline"] = this.headline;
        data["filename"] = this.filename;
        data["updatedBy"] = this.updatedBy;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IClientAttachmentInfoOutputDto {
    clientAttachmentGuid?: string;
    documentStorageGuid?: string;
    attachmentTypeId?: number;
    documentType?: DocumentTypeEnum;
    headline?: string | undefined;
    filename?: string | undefined;
    updatedBy?: string | undefined;
    dateUpdated?: moment.Moment;
}

export enum ClientAttachmentTypeEnum {
    RateCards = 256,
    OrgDiagrams = 258,
    OtherImportantDocuments = 260,
    GeneralDocuments = 288,
    BiddingMaterials = 290,
}

export class ClientContractBaseDto implements IClientContractBaseDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: string | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    documents?: ContractDocumentInfoDto[] | undefined;

    constructor(data?: IClientContractBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"];
            this.statusColorEnum = _data["statusColorEnum"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(ContractDocumentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientContractBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate;
        data["statusColorEnum"] = this.statusColorEnum;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientContractBaseDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: string | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    documents?: ContractDocumentInfoDto[] | undefined;
}

export class ClientContractViewRootDto implements IClientContractViewRootDto {
    frameAgreements?: ClientContractBaseDto[] | undefined;
    workflows?: ClientWorkflowTreeItemDto[] | undefined;

    constructor(data?: IClientContractViewRootDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["frameAgreements"])) {
                this.frameAgreements = [] as any;
                for (let item of _data["frameAgreements"])
                    this.frameAgreements!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(ClientWorkflowTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientContractViewRootDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractViewRootDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.frameAgreements)) {
            data["frameAgreements"] = [];
            for (let item of this.frameAgreements)
                data["frameAgreements"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientContractViewRootDto {
    frameAgreements?: ClientContractBaseDto[] | undefined;
    workflows?: ClientWorkflowTreeItemDto[] | undefined;
}

export class ClientDetailsDto implements IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IClientDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ClientDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export class ClientEvaluationOutputDto implements IClientEvaluationOutputDto {
    evaluationGuid?: string;
    evaluationTenantId?: number;
    consultantTenant?: number;
    legacyConsultantId?: number;
    clientName?: string | undefined;
    clientContactName?: string | undefined;
    consultantName?: string | undefined;
    externalId?: string;
    averageScore?: number;
    evaluationDate?: moment.Moment;
    evaluationFormName?: string | undefined;
    comment?: string | undefined;

    constructor(data?: IClientEvaluationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.evaluationGuid = _data["evaluationGuid"];
            this.evaluationTenantId = _data["evaluationTenantId"];
            this.consultantTenant = _data["consultantTenant"];
            this.legacyConsultantId = _data["legacyConsultantId"];
            this.clientName = _data["clientName"];
            this.clientContactName = _data["clientContactName"];
            this.consultantName = _data["consultantName"];
            this.externalId = _data["externalId"];
            this.averageScore = _data["averageScore"];
            this.evaluationDate = _data["evaluationDate"] ? moment(_data["evaluationDate"].toString()) : <any>undefined;
            this.evaluationFormName = _data["evaluationFormName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ClientEvaluationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientEvaluationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationGuid"] = this.evaluationGuid;
        data["evaluationTenantId"] = this.evaluationTenantId;
        data["consultantTenant"] = this.consultantTenant;
        data["legacyConsultantId"] = this.legacyConsultantId;
        data["clientName"] = this.clientName;
        data["clientContactName"] = this.clientContactName;
        data["consultantName"] = this.consultantName;
        data["externalId"] = this.externalId;
        data["averageScore"] = this.averageScore;
        data["evaluationDate"] = this.evaluationDate ? this.evaluationDate.format('YYYY-MM-DD') : <any>undefined;
        data["evaluationFormName"] = this.evaluationFormName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IClientEvaluationOutputDto {
    evaluationGuid?: string;
    evaluationTenantId?: number;
    consultantTenant?: number;
    legacyConsultantId?: number;
    clientName?: string | undefined;
    clientContactName?: string | undefined;
    consultantName?: string | undefined;
    externalId?: string;
    averageScore?: number;
    evaluationDate?: moment.Moment;
    evaluationFormName?: string | undefined;
    comment?: string | undefined;
}

export class ClientGanttRow implements IClientGanttRow {
    name?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;

    constructor(data?: IClientGanttRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["ganttRowItems"])) {
                this.ganttRowItems = [] as any;
                for (let item of _data["ganttRowItems"])
                    this.ganttRowItems!.push(GanttRowItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientGanttRow {
        data = typeof data === 'object' ? data : {};
        let result = new ClientGanttRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.ganttRowItems)) {
            data["ganttRowItems"] = [];
            for (let item of this.ganttRowItems)
                data["ganttRowItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientGanttRow {
    name?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;
}

export class ClientListItemDto implements IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;

    constructor(data?: IClientListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crmClientId = _data["crmClientId"];
            this.legacyClientId = _data["legacyClientId"];
            this.name = _data["name"];
            this.clientAddress_Address = _data["clientAddress_Address"];
            this.clientAddress_Address2 = _data["clientAddress_Address2"];
            this.clientAddress_PostCode = _data["clientAddress_PostCode"];
            this.clientAddress_City = _data["clientAddress_City"];
            this.clientAddress_Country_Id = _data["clientAddress_Country_Id"];
            this.clientAddress_Country_Name = _data["clientAddress_Country_Name"];
            this.clientAddress_Country_Code = _data["clientAddress_Country_Code"];
            this.phone = _data["phone"];
            this.owner_Id = _data["owner_Id"];
            this.owner_Name = _data["owner_Name"];
            this.tenant_Id = _data["tenant_Id"];
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClientListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crmClientId"] = this.crmClientId;
        data["legacyClientId"] = this.legacyClientId;
        data["name"] = this.name;
        data["clientAddress_Address"] = this.clientAddress_Address;
        data["clientAddress_Address2"] = this.clientAddress_Address2;
        data["clientAddress_PostCode"] = this.clientAddress_PostCode;
        data["clientAddress_City"] = this.clientAddress_City;
        data["clientAddress_Country_Id"] = this.clientAddress_Country_Id;
        data["clientAddress_Country_Name"] = this.clientAddress_Country_Name;
        data["clientAddress_Country_Code"] = this.clientAddress_Country_Code;
        data["phone"] = this.phone;
        data["owner_Id"] = this.owner_Id;
        data["owner_Name"] = this.owner_Name;
        data["tenant_Id"] = this.tenant_Id;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;
}

export class ClientListItemDtoPaginatedList implements IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientOverviewListItemDto implements IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;

    constructor(data?: IClientOverviewListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.clientName = _data["clientName"];
            this.consultantName = _data["consultantName"];
            this.note = _data["note"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.contractsCount = _data["contractsCount"];
            this.contractsPendingCount = _data["contractsPendingCount"];
            this.contractsExtensionsOkCount = _data["contractsExtensionsOkCount"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["clientName"] = this.clientName;
        data["consultantName"] = this.consultantName;
        data["note"] = this.note;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["contractsCount"] = this.contractsCount;
        data["contractsPendingCount"] = this.contractsPendingCount;
        data["contractsExtensionsOkCount"] = this.contractsExtensionsOkCount;
        return data;
    }
}

export interface IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;
}

export class ClientOverviewListItemDtoPaginatedList implements IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientOverviewListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientOverviewListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientPeriodContractsDataCommandDto implements IClientPeriodContractsDataCommandDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto[] | undefined;

    constructor(data?: IClientPeriodContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodContractsDataCommandDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto[] | undefined;
}

export class ClientPeriodContractsDataQueryDto implements IClientPeriodContractsDataQueryDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    clientLegalContractDoneStatusId?: number;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto[] | undefined;

    constructor(data?: IClientPeriodContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
            this.clientLegalContractDoneStatusId = _data["clientLegalContractDoneStatusId"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        data["clientLegalContractDoneStatusId"] = this.clientLegalContractDoneStatusId;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodContractsDataQueryDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    clientLegalContractDoneStatusId?: number;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto[] | undefined;
}

export class ClientPeriodDto implements IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
    consultantIds?: number[] | undefined;

    constructor(data?: IClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["workflowProcesses"])) {
                this.workflowProcesses = [] as any;
                for (let item of _data["workflowProcesses"])
                    this.workflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantIds"])) {
                this.consultantIds = [] as any;
                for (let item of _data["consultantIds"])
                    this.consultantIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.workflowProcesses)) {
            data["workflowProcesses"] = [];
            for (let item of this.workflowProcesses)
                data["workflowProcesses"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantIds)) {
            data["consultantIds"] = [];
            for (let item of this.consultantIds)
                data["consultantIds"].push(item);
        }
        return data;
    }
}

export interface IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
    consultantIds?: number[] | undefined;
}

export class ClientPeriodFinanceDataDto implements IClientPeriodFinanceDataDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;

    constructor(data?: IClientPeriodFinanceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtorCreatedInNavision = _data["debtorCreatedInNavision"];
            this.differentDebtorNumberForInvoicing = _data["differentDebtorNumberForInvoicing"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantFinanceData"])) {
                this.consultantFinanceData = [] as any;
                for (let item of _data["consultantFinanceData"])
                    this.consultantFinanceData!.push(ConsultantPeriodFinanceDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodFinanceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodFinanceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtorCreatedInNavision"] = this.debtorCreatedInNavision;
        data["differentDebtorNumberForInvoicing"] = this.differentDebtorNumberForInvoicing;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantFinanceData)) {
            data["consultantFinanceData"] = [];
            for (let item of this.consultantFinanceData)
                data["consultantFinanceData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodFinanceDataDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
}

export class ClientPeriodMainDataDto implements IClientPeriodMainDataDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
    salesTypeDto?: EnumEntityTypeDto;
    deliveryTypeDto?: EnumEntityTypeDto;
    projectTypeDto?: EnumEntityTypeDto;
    marginTypeDto?: EnumEntityTypeDto;
    commissionAccountManager?: Pm3EmployeeDto;
    salesAccountManager?: Pm3EmployeeDto;
    consultantPeriodSalesData?: ConsultantPeriodSalesDataInfoForIncomeReportDto;
    periodCommissionDtos?: CommissionDetailsDto[] | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;

    constructor(data?: IClientPeriodMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.projectLineId = _data["projectLineId"];
            this.salesTypeDto = _data["salesTypeDto"] ? EnumEntityTypeDto.fromJS(_data["salesTypeDto"]) : <any>undefined;
            this.deliveryTypeDto = _data["deliveryTypeDto"] ? EnumEntityTypeDto.fromJS(_data["deliveryTypeDto"]) : <any>undefined;
            this.projectTypeDto = _data["projectTypeDto"] ? EnumEntityTypeDto.fromJS(_data["projectTypeDto"]) : <any>undefined;
            this.marginTypeDto = _data["marginTypeDto"] ? EnumEntityTypeDto.fromJS(_data["marginTypeDto"]) : <any>undefined;
            this.commissionAccountManager = _data["commissionAccountManager"] ? Pm3EmployeeDto.fromJS(_data["commissionAccountManager"]) : <any>undefined;
            this.salesAccountManager = _data["salesAccountManager"] ? Pm3EmployeeDto.fromJS(_data["salesAccountManager"]) : <any>undefined;
            this.consultantPeriodSalesData = _data["consultantPeriodSalesData"] ? ConsultantPeriodSalesDataInfoForIncomeReportDto.fromJS(_data["consultantPeriodSalesData"]) : <any>undefined;
            if (Array.isArray(_data["periodCommissionDtos"])) {
                this.periodCommissionDtos = [] as any;
                for (let item of _data["periodCommissionDtos"])
                    this.periodCommissionDtos!.push(CommissionDetailsDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientPeriodMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["projectLineId"] = this.projectLineId;
        data["salesTypeDto"] = this.salesTypeDto ? this.salesTypeDto.toJSON() : <any>undefined;
        data["deliveryTypeDto"] = this.deliveryTypeDto ? this.deliveryTypeDto.toJSON() : <any>undefined;
        data["projectTypeDto"] = this.projectTypeDto ? this.projectTypeDto.toJSON() : <any>undefined;
        data["marginTypeDto"] = this.marginTypeDto ? this.marginTypeDto.toJSON() : <any>undefined;
        data["commissionAccountManager"] = this.commissionAccountManager ? this.commissionAccountManager.toJSON() : <any>undefined;
        data["salesAccountManager"] = this.salesAccountManager ? this.salesAccountManager.toJSON() : <any>undefined;
        data["consultantPeriodSalesData"] = this.consultantPeriodSalesData ? this.consultantPeriodSalesData.toJSON() : <any>undefined;
        if (Array.isArray(this.periodCommissionDtos)) {
            data["periodCommissionDtos"] = [];
            for (let item of this.periodCommissionDtos)
                data["periodCommissionDtos"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IClientPeriodMainDataDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
    salesTypeDto?: EnumEntityTypeDto;
    deliveryTypeDto?: EnumEntityTypeDto;
    projectTypeDto?: EnumEntityTypeDto;
    marginTypeDto?: EnumEntityTypeDto;
    commissionAccountManager?: Pm3EmployeeDto;
    salesAccountManager?: Pm3EmployeeDto;
    consultantPeriodSalesData?: ConsultantPeriodSalesDataInfoForIncomeReportDto;
    periodCommissionDtos?: CommissionDetailsDto[] | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
}

export class ClientPeriodSalesDataDto implements IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IClientPeriodSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesMainData = _data["salesMainData"] ? SalesMainDataDto.fromJS(_data["salesMainData"]) : <any>undefined;
            this.salesClientData = _data["salesClientData"] ? SalesClientDataDto.fromJS(_data["salesClientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantSalesData"])) {
                this.consultantSalesData = [] as any;
                for (let item of _data["consultantSalesData"])
                    this.consultantSalesData!.push(ConsultantSalesDataDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientPeriodSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesMainData"] = this.salesMainData ? this.salesMainData.toJSON() : <any>undefined;
        data["salesClientData"] = this.salesClientData ? this.salesClientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantSalesData)) {
            data["consultantSalesData"] = [];
            for (let item of this.consultantSalesData)
                data["consultantSalesData"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class ClientRateDto implements IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IClientRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.invoiceCurrencyId = _data["invoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ClientRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["invoiceCurrencyId"] = this.invoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ClientRequestTrackItemDto implements IClientRequestTrackItemDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;

    constructor(data?: IClientRequestTrackItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.headline = _data["headline"];
            this.status = _data["status"] ? RequestStatusValueValueNameDto.fromJS(_data["status"]) : <any>undefined;
            this.clientDeadline = _data["clientDeadline"] ? moment(_data["clientDeadline"].toString()) : <any>undefined;
            this.dateAdded = _data["dateAdded"] ? moment(_data["dateAdded"].toString()) : <any>undefined;
            this.projectType = _data["projectType"] ? RequestProjectTypeValueValueNameDto.fromJS(_data["projectType"]) : <any>undefined;
            this.priority = _data["priority"];
            this.numberOfConsultants = _data["numberOfConsultants"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(SimpleRequestLocationDto.fromJS(item));
            }
            if (Array.isArray(_data["requestSourcers"])) {
                this.requestSourcers = [] as any;
                for (let item of _data["requestSourcers"])
                    this.requestSourcers!.push(EmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["accountManagers"])) {
                this.accountManagers = [] as any;
                for (let item of _data["accountManagers"])
                    this.accountManagers!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRequestTrackItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["headline"] = this.headline;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["clientDeadline"] = this.clientDeadline ? this.clientDeadline.toISOString() : <any>undefined;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["priority"] = this.priority;
        data["numberOfConsultants"] = this.numberOfConsultants;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.requestSourcers)) {
            data["requestSourcers"] = [];
            for (let item of this.requestSourcers)
                data["requestSourcers"].push(item.toJSON());
        }
        if (Array.isArray(this.accountManagers)) {
            data["accountManagers"] = [];
            for (let item of this.accountManagers)
                data["accountManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientRequestTrackItemDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;
}

export class ClientRequestTrackItemDtoPaginatedList implements IClientRequestTrackItemDtoPaginatedList {
    items?: ClientRequestTrackItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientRequestTrackItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientRequestTrackItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientRequestTrackItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientRequestTrackItemDtoPaginatedList {
    items?: ClientRequestTrackItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientResultDto implements IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;

    constructor(data?: IClientResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ClientResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
}

export class ClientSpecialFeeDto implements IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequency = _data["clientSpecialFeeFrequency"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeFrequency"]) : <any>undefined;
            this.clientSpecialFeeSpecifiedAs = _data["clientSpecialFeeSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrency = _data["prodataToProdataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["prodataToProdataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequency"] = this.clientSpecialFeeFrequency ? this.clientSpecialFeeFrequency.toJSON() : <any>undefined;
        data["clientSpecialFeeSpecifiedAs"] = this.clientSpecialFeeSpecifiedAs ? this.clientSpecialFeeSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrency"] = this.prodataToProdataRateCurrency ? this.prodataToProdataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientSpecialRateDto implements IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnit = _data["specialRateReportingUnit"] ? SpecialRateReportingUnit.fromJS(_data["specialRateReportingUnit"]) : <any>undefined;
            this.specialRateSpecifiedAs = _data["specialRateSpecifiedAs"] ? SpecialRateSpecifiedAs.fromJS(_data["specialRateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.proDataToProDataRate = _data["proDataToProDataRate"];
            this.proDataToProDataRateCurrency = _data["proDataToProDataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["proDataToProDataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnit"] = this.specialRateReportingUnit ? this.specialRateReportingUnit.toJSON() : <any>undefined;
        data["specialRateSpecifiedAs"] = this.specialRateSpecifiedAs ? this.specialRateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["proDataToProDataRate"] = this.proDataToProDataRate;
        data["proDataToProDataRateCurrency"] = this.proDataToProDataRateCurrency ? this.proDataToProDataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientWorkflowTrackItemDto implements IClientWorkflowTrackItemDto {
    workflowId?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    invoicingReferencePerson?: ContactDto;

    constructor(data?: IClientWorkflowTrackItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.workflowStatusWithEmployee = _data["workflowStatusWithEmployee"] ? WorkflowStatusWithEmployeeDto.fromJS(_data["workflowStatusWithEmployee"]) : <any>undefined;
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(ConsultantResultDto.fromJS(item));
            }
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientWorkflowTrackItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTrackItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["workflowStatusWithEmployee"] = this.workflowStatusWithEmployee ? this.workflowStatusWithEmployee.toJSON() : <any>undefined;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientWorkflowTrackItemDto {
    workflowId?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    invoicingReferencePerson?: ContactDto;
}

export class ClientWorkflowTrackItemDtoPaginatedList implements IClientWorkflowTrackItemDtoPaginatedList {
    items?: ClientWorkflowTrackItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientWorkflowTrackItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientWorkflowTrackItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientWorkflowTrackItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTrackItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientWorkflowTrackItemDtoPaginatedList {
    items?: ClientWorkflowTrackItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientWorkflowTreeItemDto implements IClientWorkflowTreeItemDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: string | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    clientContracts?: ClientContractBaseDto[] | undefined;
    consultantContracts?: ClientContractBaseDto[] | undefined;
    internalContracts?: ClientContractBaseDto[] | undefined;

    constructor(data?: IClientWorkflowTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"];
            this.statusColorEnum = _data["statusColorEnum"];
            if (Array.isArray(_data["clientContracts"])) {
                this.clientContracts = [] as any;
                for (let item of _data["clientContracts"])
                    this.clientContracts!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantContracts"])) {
                this.consultantContracts = [] as any;
                for (let item of _data["consultantContracts"])
                    this.consultantContracts!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["internalContracts"])) {
                this.internalContracts = [] as any;
                for (let item of _data["internalContracts"])
                    this.internalContracts!.push(ClientContractBaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientWorkflowTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate;
        data["statusColorEnum"] = this.statusColorEnum;
        if (Array.isArray(this.clientContracts)) {
            data["clientContracts"] = [];
            for (let item of this.clientContracts)
                data["clientContracts"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantContracts)) {
            data["consultantContracts"] = [];
            for (let item of this.consultantContracts)
                data["consultantContracts"].push(item.toJSON());
        }
        if (Array.isArray(this.internalContracts)) {
            data["internalContracts"] = [];
            for (let item of this.internalContracts)
                data["internalContracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientWorkflowTreeItemDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: string | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    clientContracts?: ClientContractBaseDto[] | undefined;
    consultantContracts?: ClientContractBaseDto[] | undefined;
    internalContracts?: ClientContractBaseDto[] | undefined;
}

export class CommissionDetailsDto implements ICommissionDetailsDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
    emagineOfficeCountryName?: string | undefined;
    currencyName?: string | undefined;

    constructor(data?: ICommissionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierResultDto.fromJS(_data["supplier"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientResultDto.fromJS(_data["client"]) : <any>undefined;
            this.emagineOfficeCountryName = _data["emagineOfficeCountryName"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): CommissionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["emagineOfficeCountryName"] = this.emagineOfficeCountryName;
        data["currencyName"] = this.currencyName;
        return data;
    }
}

export interface ICommissionDetailsDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
    emagineOfficeCountryName?: string | undefined;
    currencyName?: string | undefined;
}

export class CommissionDto implements ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;

    constructor(data?: ICommissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierResultDto.fromJS(_data["supplier"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientResultDto.fromJS(_data["client"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
}

export class ConsultantContractsDataCommandDto implements IConsultantContractsDataCommandDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;

    constructor(data?: IConsultantContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.consultantTimeReportingCapCurrencyId = _data["consultantTimeReportingCapCurrencyId"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
        }
    }

    static fromJS(data: any): ConsultantContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["consultantTimeReportingCapCurrencyId"] = this.consultantTimeReportingCapCurrencyId;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        return data;
    }
}

export interface IConsultantContractsDataCommandDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
}

export class ConsultantContractsDataQueryDto implements IConsultantContractsDataQueryDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    internalLegalContractDoneStatusId?: number;
    consultantLegalContractDoneStatusId?: number;

    constructor(data?: IConsultantContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.consultantTimeReportingCapCurrencyId = _data["consultantTimeReportingCapCurrencyId"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.internalLegalContractDoneStatusId = _data["internalLegalContractDoneStatusId"];
            this.consultantLegalContractDoneStatusId = _data["consultantLegalContractDoneStatusId"];
        }
    }

    static fromJS(data: any): ConsultantContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["consultantTimeReportingCapCurrencyId"] = this.consultantTimeReportingCapCurrencyId;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["internalLegalContractDoneStatusId"] = this.internalLegalContractDoneStatusId;
        data["consultantLegalContractDoneStatusId"] = this.consultantLegalContractDoneStatusId;
        return data;
    }
}

export interface IConsultantContractsDataQueryDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    internalLegalContractDoneStatusId?: number;
    consultantLegalContractDoneStatusId?: number;
}

export class ConsultantGanttRow implements IConsultantGanttRow {
    name?: string | undefined;
    consultantId?: number | undefined;
    consultantExternalId?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;

    constructor(data?: IConsultantGanttRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.consultantId = _data["consultantId"];
            this.consultantExternalId = _data["consultantExternalId"];
            if (Array.isArray(_data["ganttRowItems"])) {
                this.ganttRowItems = [] as any;
                for (let item of _data["ganttRowItems"])
                    this.ganttRowItems!.push(GanttRowItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsultantGanttRow {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantGanttRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["consultantId"] = this.consultantId;
        data["consultantExternalId"] = this.consultantExternalId;
        if (Array.isArray(this.ganttRowItems)) {
            data["ganttRowItems"] = [];
            for (let item of this.ganttRowItems)
                data["ganttRowItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConsultantGanttRow {
    name?: string | undefined;
    consultantId?: number | undefined;
    consultantExternalId?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;
}

export class ConsultantNameWithRequestUrl implements IConsultantNameWithRequestUrl {
    consultantName?: string | undefined;
    requestId?: number | undefined;
    requestUrl?: string | undefined;

    constructor(data?: IConsultantNameWithRequestUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantName = _data["consultantName"];
            this.requestId = _data["requestId"];
            this.requestUrl = _data["requestUrl"];
        }
    }

    static fromJS(data: any): ConsultantNameWithRequestUrl {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantNameWithRequestUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantName"] = this.consultantName;
        data["requestId"] = this.requestId;
        data["requestUrl"] = this.requestUrl;
        return data;
    }
}

export interface IConsultantNameWithRequestUrl {
    consultantName?: string | undefined;
    requestId?: number | undefined;
    requestUrl?: string | undefined;
}

export class ConsultantPeriodAddDto implements IConsultantPeriodAddDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IConsultantPeriodAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodAddDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class ConsultantPeriodContractsDataCommandDto implements IConsultantPeriodContractsDataCommandDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto;

    constructor(data?: IConsultantPeriodContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectDescription = _data["projectDescription"];
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.newLegalContractRequired = _data["newLegalContractRequired"];
            this.consultantData = _data["consultantData"] ? ConsultantContractsDataCommandDto.fromJS(_data["consultantData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectDescription"] = this.projectDescription;
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        data["consultantData"] = this.consultantData ? this.consultantData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodContractsDataCommandDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto;
}

export class ConsultantPeriodContractsDataQueryDto implements IConsultantPeriodContractsDataQueryDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    clientData?: ContractsClientDataDto;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto;

    constructor(data?: IConsultantPeriodContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectDescription = _data["projectDescription"];
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.newLegalContractRequired = _data["newLegalContractRequired"];
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            this.consultantData = _data["consultantData"] ? ConsultantContractsDataQueryDto.fromJS(_data["consultantData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectDescription"] = this.projectDescription;
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        data["customDebtorNumber"] = this.customDebtorNumber;
        data["consultantData"] = this.consultantData ? this.consultantData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodContractsDataQueryDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    clientData?: ContractsClientDataDto;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto;
}

export class ConsultantPeriodFinanceDataDto implements IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;

    constructor(data?: IConsultantPeriodFinanceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.checkInvoicingSettingsOnConsultant = _data["checkInvoicingSettingsOnConsultant"];
            this.creditorCreatedInNavision = _data["creditorCreatedInNavision"];
        }
    }

    static fromJS(data: any): ConsultantPeriodFinanceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodFinanceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["checkInvoicingSettingsOnConsultant"] = this.checkInvoicingSettingsOnConsultant;
        data["creditorCreatedInNavision"] = this.creditorCreatedInNavision;
        return data;
    }
}

export interface IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;
}

export class ConsultantPeriodSalesDataDto implements IConsultantPeriodSalesDataDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    consultantSalesData?: ConsultantSalesDataDto;
    directClientIdValue?: number | undefined;
    clientRate?: ClientRateDto;
    clientPeriodPdcInvoicingEntityId?: number | undefined;

    constructor(data?: IConsultantPeriodSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectDescription = _data["projectDescription"];
            this.consultantSalesData = _data["consultantSalesData"] ? ConsultantSalesDataDto.fromJS(_data["consultantSalesData"]) : <any>undefined;
            this.directClientIdValue = _data["directClientIdValue"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.clientPeriodPdcInvoicingEntityId = _data["clientPeriodPdcInvoicingEntityId"];
        }
    }

    static fromJS(data: any): ConsultantPeriodSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectDescription"] = this.projectDescription;
        data["consultantSalesData"] = this.consultantSalesData ? this.consultantSalesData.toJSON() : <any>undefined;
        data["directClientIdValue"] = this.directClientIdValue;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["clientPeriodPdcInvoicingEntityId"] = this.clientPeriodPdcInvoicingEntityId;
        return data;
    }
}

export interface IConsultantPeriodSalesDataDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectDescription?: string | undefined;
    consultantSalesData?: ConsultantSalesDataDto;
    directClientIdValue?: number | undefined;
    clientRate?: ClientRateDto;
    clientPeriodPdcInvoicingEntityId?: number | undefined;
}

export class ConsultantPeriodSalesDataInfoForIncomeReportDto implements IConsultantPeriodSalesDataInfoForIncomeReportDto {
    deliveryAccountManagerDto?: Pm3EmployeeDto;
    workplaceDto?: WorkplaceDto;

    constructor(data?: IConsultantPeriodSalesDataInfoForIncomeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryAccountManagerDto = _data["deliveryAccountManagerDto"] ? Pm3EmployeeDto.fromJS(_data["deliveryAccountManagerDto"]) : <any>undefined;
            this.workplaceDto = _data["workplaceDto"] ? WorkplaceDto.fromJS(_data["workplaceDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodSalesDataInfoForIncomeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodSalesDataInfoForIncomeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryAccountManagerDto"] = this.deliveryAccountManagerDto ? this.deliveryAccountManagerDto.toJSON() : <any>undefined;
        data["workplaceDto"] = this.workplaceDto ? this.workplaceDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodSalesDataInfoForIncomeReportDto {
    deliveryAccountManagerDto?: Pm3EmployeeDto;
    workplaceDto?: WorkplaceDto;
}

export class ConsultantRateDto implements IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IConsultantRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataCurrencyId = _data["prodataToProdataCurrencyId"];
            this.prodataToProdataInvoiceCurrencyId = _data["prodataToProdataInvoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ConsultantRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataCurrencyId"] = this.prodataToProdataCurrencyId;
        data["prodataToProdataInvoiceCurrencyId"] = this.prodataToProdataInvoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ConsultantResultDto implements IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    companyName?: string | undefined;
    tenantId?: number;
    externalId?: string;
    city?: string | undefined;
    countryId?: number | undefined;

    constructor(data?: IConsultantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.legacyId = _data["legacyId"];
            this.companyName = _data["companyName"];
            this.tenantId = _data["tenantId"];
            this.externalId = _data["externalId"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ConsultantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["legacyId"] = this.legacyId;
        data["companyName"] = this.companyName;
        data["tenantId"] = this.tenantId;
        data["externalId"] = this.externalId;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    companyName?: string | undefined;
    tenantId?: number;
    externalId?: string;
    city?: string | undefined;
    countryId?: number | undefined;
}

export class ConsultantSalesDataDto implements IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantPeriodId?: string | undefined;
    soldRequestConsultantId?: number | undefined;
    requestId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    durationSameAsClientPeriod?: boolean;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean | undefined;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;

    constructor(data?: IConsultantSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
            this.requestId = _data["requestId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.durationSameAsClientPeriod = _data["durationSameAsClientPeriod"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isOnsiteWorkplace = _data["isOnsiteWorkplace"];
            this.onsiteClientId = _data["onsiteClientId"];
            this.onsiteClient = _data["onsiteClient"] ? ClientResultDto.fromJS(_data["onsiteClient"]) : <any>undefined;
            this.isEmagineOfficeWorkplace = _data["isEmagineOfficeWorkplace"];
            this.emagineOfficeId = _data["emagineOfficeId"];
            this.isRemoteWorkplace = _data["isRemoteWorkplace"];
            this.remoteAddressCountryId = _data["remoteAddressCountryId"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.noExpectedWorkload = _data["noExpectedWorkload"];
            this.expectedWorkloadHours = _data["expectedWorkloadHours"];
            this.expectedWorkloadUnitId = _data["expectedWorkloadUnitId"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.deliveryManagerSameAsAccountManager = _data["deliveryManagerSameAsAccountManager"];
            this.deliveryAccountManagerIdValue = _data["deliveryAccountManagerIdValue"];
            this.deliveryAccountManager = _data["deliveryAccountManager"] ? EmployeeDto.fromJS(_data["deliveryAccountManager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        data["requestId"] = this.requestId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["durationSameAsClientPeriod"] = this.durationSameAsClientPeriod;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isOnsiteWorkplace"] = this.isOnsiteWorkplace;
        data["onsiteClientId"] = this.onsiteClientId;
        data["onsiteClient"] = this.onsiteClient ? this.onsiteClient.toJSON() : <any>undefined;
        data["isEmagineOfficeWorkplace"] = this.isEmagineOfficeWorkplace;
        data["emagineOfficeId"] = this.emagineOfficeId;
        data["isRemoteWorkplace"] = this.isRemoteWorkplace;
        data["remoteAddressCountryId"] = this.remoteAddressCountryId;
        data["percentageOnSite"] = this.percentageOnSite;
        data["noExpectedWorkload"] = this.noExpectedWorkload;
        data["expectedWorkloadHours"] = this.expectedWorkloadHours;
        data["expectedWorkloadUnitId"] = this.expectedWorkloadUnitId;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["deliveryManagerSameAsAccountManager"] = this.deliveryManagerSameAsAccountManager;
        data["deliveryAccountManagerIdValue"] = this.deliveryAccountManagerIdValue;
        data["deliveryAccountManager"] = this.deliveryAccountManager ? this.deliveryAccountManager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantPeriodId?: string | undefined;
    soldRequestConsultantId?: number | undefined;
    requestId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    durationSameAsClientPeriod?: boolean;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean | undefined;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;
}

export class ConsultantTerminationContractDataCommandDto implements IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationContractDataQueryDto implements IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultant?: ConsultantResultDto;
}

export class ConsultantTerminationSalesDataCommandDto implements IConsultantTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;

    constructor(data?: IConsultantTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        return data;
    }
}

export interface IConsultantTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
}

export class ConsultantTerminationSalesDataQueryDto implements IConsultantTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    clientId?: number;
    finalEvaluationReferencePerson?: ContactDto;

    constructor(data?: IConsultantTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.clientId = _data["clientId"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["clientId"] = this.clientId;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    clientId?: number;
    finalEvaluationReferencePerson?: ContactDto;
}

export class ConsultantTerminationSourcingDataCommandDto implements IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationSourcingDataQueryDto implements IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;
}

export class ConsultantWithSourcingRequestResultDto implements IConsultantWithSourcingRequestResultDto {
    consultant?: ConsultantResultDto;
    sourcingRequestConsultantId?: number | undefined;
    sourcingRequestId?: number | undefined;
    sourcingRequestConsultantHeadline?: string | undefined;

    constructor(data?: IConsultantWithSourcingRequestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.sourcingRequestConsultantId = _data["sourcingRequestConsultantId"];
            this.sourcingRequestId = _data["sourcingRequestId"];
            this.sourcingRequestConsultantHeadline = _data["sourcingRequestConsultantHeadline"];
        }
    }

    static fromJS(data: any): ConsultantWithSourcingRequestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantWithSourcingRequestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["sourcingRequestConsultantId"] = this.sourcingRequestConsultantId;
        data["sourcingRequestId"] = this.sourcingRequestId;
        data["sourcingRequestConsultantHeadline"] = this.sourcingRequestConsultantHeadline;
        return data;
    }
}

export interface IConsultantWithSourcingRequestResultDto {
    consultant?: ConsultantResultDto;
    sourcingRequestConsultantId?: number | undefined;
    sourcingRequestId?: number | undefined;
    sourcingRequestConsultantHeadline?: string | undefined;
}

export class ContactDto implements IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.owner = _data["owner"] ? EmployeeDto.fromJS(_data["owner"]) : <any>undefined;
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : <any>undefined;
            this.legacyContactId = _data["legacyContactId"] ? LegacyContactId.fromJS(_data["legacyContactId"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.lastCamLogin = _data["lastCamLogin"] ? moment(_data["lastCamLogin"].toString()) : <any>undefined;
            this.hasCamLogin = _data["hasCamLogin"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["legacyContactId"] = this.legacyContactId ? this.legacyContactId.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["lastCamLogin"] = this.lastCamLogin ? this.lastCamLogin.toISOString() : <any>undefined;
        data["hasCamLogin"] = this.hasCamLogin;
        return data;
    }
}

export interface IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;
}

export class ContactResultDto implements IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContactResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data;
    }
}

export interface IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class ContractDocumentInfoDto implements IContractDocumentInfoDto {
    documentStorageGuid?: string;
    name?: string | undefined;
    type?: DocumentTypeEnum;

    constructor(data?: IContractDocumentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentStorageGuid = _data["documentStorageGuid"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ContractDocumentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDocumentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentStorageGuid"] = this.documentStorageGuid;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IContractDocumentInfoDto {
    documentStorageGuid?: string;
    name?: string | undefined;
    type?: DocumentTypeEnum;
}

export enum ContractExpirationNotificationInterval {
    OneWeekBefore = 1,
    TwoWeeksBefore = 2,
    ThreeWeeksBefore = 3,
    FourWeeksBefore = 4,
    FiveWeeksBefore = 5,
    SixWeeksBefore = 6,
    OneMonthBefore = 7,
    TwoMonthsBefore = 8,
}

export enum ContractPaperStatusColorEnum {
    Grey = 0,
    Green = 1,
    Yellow = 2,
    Red = 3,
    Black = 10,
}

export class ContractsClientDataDto implements IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    clientRate?: ClientRateDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    directClientId?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;

    constructor(data?: IContractsClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.clientTimeReportingCapCurrencyId = _data["clientTimeReportingCapCurrencyId"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.directClientId = _data["directClientId"];
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientIdValue = _data["clientInvoicingRecipientIdValue"];
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? ClientResultDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.invoicingReferencePersonIdValue = _data["invoicingReferencePersonIdValue"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractsClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["clientTimeReportingCapCurrencyId"] = this.clientTimeReportingCapCurrencyId;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["directClientId"] = this.directClientId;
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientIdValue"] = this.clientInvoicingRecipientIdValue;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["invoicingReferencePersonIdValue"] = this.invoicingReferencePersonIdValue;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    clientRate?: ClientRateDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    directClientId?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
}

export class ContractSignerDto implements IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;

    constructor(data?: IContractSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signOrder = _data["signOrder"];
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? ContactResultDto.fromJS(_data["contact"]) : <any>undefined;
            this.signerRoleId = _data["signerRoleId"];
        }
    }

    static fromJS(data: any): ContractSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signOrder"] = this.signOrder;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["signerRoleId"] = this.signerRoleId;
        return data;
    }
}

export interface IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;
}

export class ContractsMainDataDto implements IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;

    constructor(data?: IContractsMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): ContractsMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;
}

export class ContractSyncResultDto implements IContractSyncResultDto {
    success?: boolean;
    showManualOption?: boolean;
    readonly message?: string | undefined;
    enableLegalContractsButtons?: boolean;

    constructor(data?: IContractSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.showManualOption = _data["showManualOption"];
            (<any>this).message = _data["message"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
        }
    }

    static fromJS(data: any): ContractSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["showManualOption"] = this.showManualOption;
        data["message"] = this.message;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        return data;
    }
}

export interface IContractSyncResultDto {
    success?: boolean;
    showManualOption?: boolean;
    message?: string | undefined;
    enableLegalContractsButtons?: boolean;
}

export class CountryDto implements ICountryDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
}

export class CurrentEmployeeDto implements ICurrentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    employeeRole?: EmployeeRole;

    constructor(data?: ICurrentEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.employeeRole = _data["employeeRole"];
        }
    }

    static fromJS(data: any): CurrentEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["employeeRole"] = this.employeeRole;
        return data;
    }
}

export interface ICurrentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    employeeRole?: EmployeeRole;
}

export enum DocumentTypeEnum {
    Misc = 0,
    Pdf = 1,
    Word = 2,
    Image = 3,
    Excel = 4,
}

export class DomainEventBase implements IDomainEventBase {
    readonly id?: string;
    readonly dateOccurredUtc?: moment.Moment;

    constructor(data?: IDomainEventBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).dateOccurredUtc = _data["dateOccurredUtc"] ? moment(_data["dateOccurredUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainEventBase {
        data = typeof data === 'object' ? data : {};
        let result = new DomainEventBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateOccurredUtc"] = this.dateOccurredUtc ? this.dateOccurredUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDomainEventBase {
    id?: string;
    dateOccurredUtc?: moment.Moment;
}

export class EmagineOfficeDto implements IEmagineOfficeDto {
    id?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IEmagineOfficeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.address = _data["address"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): EmagineOfficeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmagineOfficeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["address"] = this.address;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IEmagineOfficeDto {
    id?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryName?: string | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class EmployeeNotificationDto implements IEmployeeNotificationDto {
    tenantId?: number | undefined;
    notifications?: EmployeeTenantNotificationItem[] | undefined;

    constructor(data?: IEmployeeNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(EmployeeTenantNotificationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmployeeNotificationDto {
    tenantId?: number | undefined;
    notifications?: EmployeeTenantNotificationItem[] | undefined;
}

export enum EmployeeRole {
    None = 0,
    AccountManager = 1,
    ContractManager = 2,
}

export class EmployeeTenantNotificationItem implements IEmployeeTenantNotificationItem {
    notificationId?: number;
    notificationName?: string | undefined;
    enabled?: boolean;

    constructor(data?: IEmployeeTenantNotificationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.notificationName = _data["notificationName"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): EmployeeTenantNotificationItem {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTenantNotificationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["notificationName"] = this.notificationName;
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IEmployeeTenantNotificationItem {
    notificationId?: number;
    notificationName?: string | undefined;
    enabled?: boolean;
}

export class EmploymentType implements IEmploymentType {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: IEmploymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): EmploymentType {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEmploymentType {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class EnumEntityTypeDto implements IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IEnumEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;
}

export class ExpectedWorkload implements IExpectedWorkload {
    hours?: number;
    expectedWorkloadUnit?: ExpectedWorkloadUnit;

    constructor(data?: IExpectedWorkload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hours = _data["hours"];
            this.expectedWorkloadUnit = _data["expectedWorkloadUnit"] ? ExpectedWorkloadUnit.fromJS(_data["expectedWorkloadUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpectedWorkload {
        data = typeof data === 'object' ? data : {};
        let result = new ExpectedWorkload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hours"] = this.hours;
        data["expectedWorkloadUnit"] = this.expectedWorkloadUnit ? this.expectedWorkloadUnit.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExpectedWorkload {
    hours?: number;
    expectedWorkloadUnit?: ExpectedWorkloadUnit;
}

export class ExpectedWorkloadUnit implements IExpectedWorkloadUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: IExpectedWorkloadUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): ExpectedWorkloadUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ExpectedWorkloadUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IExpectedWorkloadUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class ExtendClientPeriodDto implements IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantIds?: number[] | undefined;

    constructor(data?: IExtendClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["extendConsultantIds"])) {
                this.extendConsultantIds = [] as any;
                for (let item of _data["extendConsultantIds"])
                    this.extendConsultantIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.extendConsultantIds)) {
            data["extendConsultantIds"] = [];
            for (let item of this.extendConsultantIds)
                data["extendConsultantIds"].push(item);
        }
        return data;
    }
}

export interface IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantIds?: number[] | undefined;
}

export class ExtendConsultantPeriodDto implements IExtendConsultantPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IExtendConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtendConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IExtendConsultantPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class GanttRowItem implements IGanttRowItem {
    id?: string;
    processTypeId?: WorkflowProcessType;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;

    constructor(data?: IGanttRowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processTypeId = _data["processTypeId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GanttRowItem {
        data = typeof data === 'object' ? data : {};
        let result = new GanttRowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processTypeId"] = this.processTypeId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IGanttRowItem {
    id?: string;
    processTypeId?: WorkflowProcessType;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
}

export class IdNameDto implements IIdNameDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdNameDto {
    id?: number;
    name?: string | undefined;
}

export class InputWorkflowPeriodInfoForIncomeReportDto implements IInputWorkflowPeriodInfoForIncomeReportDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;

    constructor(data?: IInputWorkflowPeriodInfoForIncomeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.projectLineId = _data["projectLineId"];
        }
    }

    static fromJS(data: any): InputWorkflowPeriodInfoForIncomeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputWorkflowPeriodInfoForIncomeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["projectLineId"] = this.projectLineId;
        return data;
    }
}

export interface IInputWorkflowPeriodInfoForIncomeReportDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
}

export class InternalCommissionDetailsDto implements IInternalCommissionDetailsDto {
    commissionDetailsDto?: CommissionDetailsDto;
    fromEmagineOfficeCountryName?: string | undefined;
    workflowGuid?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;

    constructor(data?: IInternalCommissionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commissionDetailsDto = _data["commissionDetailsDto"] ? CommissionDetailsDto.fromJS(_data["commissionDetailsDto"]) : <any>undefined;
            this.fromEmagineOfficeCountryName = _data["fromEmagineOfficeCountryName"];
            this.workflowGuid = _data["workflowGuid"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InternalCommissionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InternalCommissionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commissionDetailsDto"] = this.commissionDetailsDto ? this.commissionDetailsDto.toJSON() : <any>undefined;
        data["fromEmagineOfficeCountryName"] = this.fromEmagineOfficeCountryName;
        data["workflowGuid"] = this.workflowGuid;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IInternalCommissionDetailsDto {
    commissionDetailsDto?: CommissionDetailsDto;
    fromEmagineOfficeCountryName?: string | undefined;
    workflowGuid?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
}

export class LegacyClientDto implements ILegacyClientDto {
    legacyClientId?: number | undefined;
    clientTenantId?: number | undefined;
    name?: string | undefined;
    ownerInitials?: string | undefined;
    clientAddress?: ClientAddressDto;

    constructor(data?: ILegacyClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legacyClientId = _data["legacyClientId"];
            this.clientTenantId = _data["clientTenantId"];
            this.name = _data["name"];
            this.ownerInitials = _data["ownerInitials"];
            this.clientAddress = _data["clientAddress"] ? ClientAddressDto.fromJS(_data["clientAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LegacyClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegacyClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legacyClientId"] = this.legacyClientId;
        data["clientTenantId"] = this.clientTenantId;
        data["name"] = this.name;
        data["ownerInitials"] = this.ownerInitials;
        data["clientAddress"] = this.clientAddress ? this.clientAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILegacyClientDto {
    legacyClientId?: number | undefined;
    clientTenantId?: number | undefined;
    name?: string | undefined;
    ownerInitials?: string | undefined;
    clientAddress?: ClientAddressDto;
}

export class LegacyContactId implements ILegacyContactId {
    readonly value?: number;

    constructor(data?: ILegacyContactId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): LegacyContactId {
        data = typeof data === 'object' ? data : {};
        let result = new LegacyContactId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ILegacyContactId {
    value?: number;
}

export enum LegalContractStatus {
    NotAccessible = 0,
    NotYetCreated = 1,
    SavedNotGenerated = 2,
    Done = 10,
}

export class MainOverviewItemForConsultantDto implements IMainOverviewItemForConsultantDto {
    workflowId?: string;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    consultant?: ConsultantResultDto;
    consultantPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowConsultantForSales?: MainOverviewStatus;
    readonly isLastConsultantPeriodSyncedAndSalesDataApproved?: boolean | undefined;
    readonly lastConsultantPeriodEndDate?: moment.Moment | undefined;

    constructor(data?: IMainOverviewItemForConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientDisplayName = _data["clientDisplayName"];
            this.salesManager = _data["salesManager"] ? EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            if (Array.isArray(_data["consultantPeriods"])) {
                this.consultantPeriods = [] as any;
                for (let item of _data["consultantPeriods"])
                    this.consultantPeriods!.push(MainOverviewItemPeriodDto.fromJS(item));
            }
            this.mainOverviewStatusOfWorkflowConsultantForSales = _data["mainOverviewStatusOfWorkflowConsultantForSales"];
            (<any>this).isLastConsultantPeriodSyncedAndSalesDataApproved = _data["isLastConsultantPeriodSyncedAndSalesDataApproved"];
            (<any>this).lastConsultantPeriodEndDate = _data["lastConsultantPeriodEndDate"] ? moment(_data["lastConsultantPeriodEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MainOverviewItemForConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientDisplayName"] = this.clientDisplayName;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantPeriods)) {
            data["consultantPeriods"] = [];
            for (let item of this.consultantPeriods)
                data["consultantPeriods"].push(item.toJSON());
        }
        data["mainOverviewStatusOfWorkflowConsultantForSales"] = this.mainOverviewStatusOfWorkflowConsultantForSales;
        data["isLastConsultantPeriodSyncedAndSalesDataApproved"] = this.isLastConsultantPeriodSyncedAndSalesDataApproved;
        data["lastConsultantPeriodEndDate"] = this.lastConsultantPeriodEndDate ? this.lastConsultantPeriodEndDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IMainOverviewItemForConsultantDto {
    workflowId?: string;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    consultant?: ConsultantResultDto;
    consultantPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowConsultantForSales?: MainOverviewStatus;
    isLastConsultantPeriodSyncedAndSalesDataApproved?: boolean | undefined;
    lastConsultantPeriodEndDate?: moment.Moment | undefined;
}

export class MainOverviewItemForConsultantDtoPaginatedList implements IMainOverviewItemForConsultantDtoPaginatedList {
    items?: MainOverviewItemForConsultantDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMainOverviewItemForConsultantDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MainOverviewItemForConsultantDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): MainOverviewItemForConsultantDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForConsultantDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IMainOverviewItemForConsultantDtoPaginatedList {
    items?: MainOverviewItemForConsultantDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MainOverviewItemForWorkflowDto implements IMainOverviewItemForWorkflowDto {
    workflowId?: string;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    clientPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowForSales?: MainOverviewStatus;
    readonly isLastClientPeriodSyncedAndSalesDataApproved?: boolean | undefined;
    readonly lastClientPeriodEndDate?: moment.Moment | undefined;

    constructor(data?: IMainOverviewItemForWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientDisplayName = _data["clientDisplayName"];
            this.salesManager = _data["salesManager"] ? EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(ConsultantResultDto.fromJS(item));
            }
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(MainOverviewItemPeriodDto.fromJS(item));
            }
            this.mainOverviewStatusOfWorkflowForSales = _data["mainOverviewStatusOfWorkflowForSales"];
            (<any>this).isLastClientPeriodSyncedAndSalesDataApproved = _data["isLastClientPeriodSyncedAndSalesDataApproved"];
            (<any>this).lastClientPeriodEndDate = _data["lastClientPeriodEndDate"] ? moment(_data["lastClientPeriodEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MainOverviewItemForWorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientDisplayName"] = this.clientDisplayName;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        data["mainOverviewStatusOfWorkflowForSales"] = this.mainOverviewStatusOfWorkflowForSales;
        data["isLastClientPeriodSyncedAndSalesDataApproved"] = this.isLastClientPeriodSyncedAndSalesDataApproved;
        data["lastClientPeriodEndDate"] = this.lastClientPeriodEndDate ? this.lastClientPeriodEndDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IMainOverviewItemForWorkflowDto {
    workflowId?: string;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    clientPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowForSales?: MainOverviewStatus;
    isLastClientPeriodSyncedAndSalesDataApproved?: boolean | undefined;
    lastClientPeriodEndDate?: moment.Moment | undefined;
}

export class MainOverviewItemForWorkflowDtoPaginatedList implements IMainOverviewItemForWorkflowDtoPaginatedList {
    items?: MainOverviewItemForWorkflowDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMainOverviewItemForWorkflowDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MainOverviewItemForWorkflowDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): MainOverviewItemForWorkflowDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForWorkflowDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IMainOverviewItemForWorkflowDtoPaginatedList {
    items?: MainOverviewItemForWorkflowDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MainOverviewItemPeriodDto implements IMainOverviewItemPeriodDto {
    id?: string;
    periodType?: string | undefined;
    salesStepStatus?: WorkflowStepStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    isSyncedAndSalesDataApproved?: boolean | undefined;

    constructor(data?: IMainOverviewItemPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodType = _data["periodType"];
            this.salesStepStatus = _data["salesStepStatus"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isSyncedAndSalesDataApproved = _data["isSyncedAndSalesDataApproved"];
        }
    }

    static fromJS(data: any): MainOverviewItemPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodType"] = this.periodType;
        data["salesStepStatus"] = this.salesStepStatus;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isSyncedAndSalesDataApproved"] = this.isSyncedAndSalesDataApproved;
        return data;
    }
}

export interface IMainOverviewItemPeriodDto {
    id?: string;
    periodType?: string | undefined;
    salesStepStatus?: WorkflowStepStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    isSyncedAndSalesDataApproved?: boolean | undefined;
}

export enum MainOverviewStatus {
    ExpectedExtension = 1,
    InNegotiation = 2,
    ExpectedToTerminate = 3,
    NoAction = 10,
    Terminated = 12,
    AttentionRequired = 20,
}

export class MainOverviewStatusDto implements IMainOverviewStatusDto {
    id?: number;
    name?: string | undefined;
    canBeSetByUser?: boolean;
    canBeSetAutomatically?: boolean;

    constructor(data?: IMainOverviewStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.canBeSetByUser = _data["canBeSetByUser"];
            this.canBeSetAutomatically = _data["canBeSetAutomatically"];
        }
    }

    static fromJS(data: any): MainOverviewStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["canBeSetByUser"] = this.canBeSetByUser;
        data["canBeSetAutomatically"] = this.canBeSetAutomatically;
        return data;
    }
}

export interface IMainOverviewStatusDto {
    id?: number;
    name?: string | undefined;
    canBeSetByUser?: boolean;
    canBeSetAutomatically?: boolean;
}

export class NewContractRequiredConsultantPeriodDto implements INewContractRequiredConsultantPeriodDto {
    consultantId?: number;
    consultantNewLegalContractRequired?: boolean;

    constructor(data?: INewContractRequiredConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultantNewLegalContractRequired = _data["consultantNewLegalContractRequired"];
        }
    }

    static fromJS(data: any): NewContractRequiredConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewContractRequiredConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultantNewLegalContractRequired"] = this.consultantNewLegalContractRequired;
        return data;
    }
}

export interface INewContractRequiredConsultantPeriodDto {
    consultantId?: number;
    consultantNewLegalContractRequired?: boolean;
}

export class NewWorkflowCreatedDto implements INewWorkflowCreatedDto {
    workflowId?: string;
    clientPeriodId?: string | undefined;

    constructor(data?: INewWorkflowCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientPeriodId = _data["clientPeriodId"];
        }
    }

    static fromJS(data: any): NewWorkflowCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewWorkflowCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientPeriodId"] = this.clientPeriodId;
        return data;
    }
}

export interface INewWorkflowCreatedDto {
    workflowId?: string;
    clientPeriodId?: string | undefined;
}

export class OutputWorkflowPeriodInfoForIncomeReportDto implements IOutputWorkflowPeriodInfoForIncomeReportDto {
    periodMainDataDtos?: ClientPeriodMainDataDto[] | undefined;
    emagineCommissionsFromOtherTenantsDtos?: InternalCommissionDetailsDto[] | undefined;

    constructor(data?: IOutputWorkflowPeriodInfoForIncomeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["periodMainDataDtos"])) {
                this.periodMainDataDtos = [] as any;
                for (let item of _data["periodMainDataDtos"])
                    this.periodMainDataDtos!.push(ClientPeriodMainDataDto.fromJS(item));
            }
            if (Array.isArray(_data["emagineCommissionsFromOtherTenantsDtos"])) {
                this.emagineCommissionsFromOtherTenantsDtos = [] as any;
                for (let item of _data["emagineCommissionsFromOtherTenantsDtos"])
                    this.emagineCommissionsFromOtherTenantsDtos!.push(InternalCommissionDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputWorkflowPeriodInfoForIncomeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutputWorkflowPeriodInfoForIncomeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.periodMainDataDtos)) {
            data["periodMainDataDtos"] = [];
            for (let item of this.periodMainDataDtos)
                data["periodMainDataDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.emagineCommissionsFromOtherTenantsDtos)) {
            data["emagineCommissionsFromOtherTenantsDtos"] = [];
            for (let item of this.emagineCommissionsFromOtherTenantsDtos)
                data["emagineCommissionsFromOtherTenantsDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOutputWorkflowPeriodInfoForIncomeReportDto {
    periodMainDataDtos?: ClientPeriodMainDataDto[] | undefined;
    emagineCommissionsFromOtherTenantsDtos?: InternalCommissionDetailsDto[] | undefined;
}

export class PeriodClientSpecialFeeDto implements IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodClientSpecialRateDto implements IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    rateSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.rateSpecifiedAs = _data["rateSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["rateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["rateSpecifiedAs"] = this.rateSpecifiedAs ? this.rateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    rateSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialFeeDto implements IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialRateDto implements IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    rateSpecifiedAs?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.rateSpecifiedAs = _data["rateSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["rateSpecifiedAs"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["rateSpecifiedAs"] = this.rateSpecifiedAs ? this.rateSpecifiedAs.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    rateSpecifiedAs?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class Pm3EmployeeDto implements IPm3EmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    primaryPhoneNumber?: string | undefined;
    emailAddress?: string | undefined;
    lowerCaseInitials?: string | undefined;

    constructor(data?: IPm3EmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.primaryPhoneNumber = _data["primaryPhoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.lowerCaseInitials = _data["lowerCaseInitials"];
        }
    }

    static fromJS(data: any): Pm3EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new Pm3EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["primaryPhoneNumber"] = this.primaryPhoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["lowerCaseInitials"] = this.lowerCaseInitials;
        return data;
    }
}

export interface IPm3EmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    primaryPhoneNumber?: string | undefined;
    emailAddress?: string | undefined;
    lowerCaseInitials?: string | undefined;
}

export class ProjectLineDto implements IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferenceString?: string | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    invoiceRecipient?: ClientResultDto;
    modifiedById?: number | undefined;
    modifiedBy?: EmployeeDto;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;
    markedForLegacyDeletion?: boolean | undefined;
    wasSynced?: boolean | undefined;

    constructor(data?: IProjectLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.differentInvoicingReferenceNumber = _data["differentInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.differentInvoicingReferencePerson = _data["differentInvoicingReferencePerson"];
            this.invoicingReferencePersonId = _data["invoicingReferencePersonId"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.invoicingReferenceString = _data["invoicingReferenceString"];
            this.optionalInvoicingInfo = _data["optionalInvoicingInfo"];
            this.differentDebtorNumber = _data["differentDebtorNumber"];
            this.debtorNumber = _data["debtorNumber"];
            this.differentInvoiceRecipient = _data["differentInvoiceRecipient"];
            this.invoiceRecipientId = _data["invoiceRecipientId"];
            this.invoiceRecipient = _data["invoiceRecipient"] ? ClientResultDto.fromJS(_data["invoiceRecipient"]) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.modifiedBy = _data["modifiedBy"] ? EmployeeDto.fromJS(_data["modifiedBy"]) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? moment(_data["modificationDate"].toString()) : <any>undefined;
            this.consultantInsuranceOptionId = _data["consultantInsuranceOptionId"];
            this.markedForLegacyDeletion = _data["markedForLegacyDeletion"];
            this.wasSynced = _data["wasSynced"];
        }
    }

    static fromJS(data: any): ProjectLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["differentInvoicingReferenceNumber"] = this.differentInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["differentInvoicingReferencePerson"] = this.differentInvoicingReferencePerson;
        data["invoicingReferencePersonId"] = this.invoicingReferencePersonId;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["invoicingReferenceString"] = this.invoicingReferenceString;
        data["optionalInvoicingInfo"] = this.optionalInvoicingInfo;
        data["differentDebtorNumber"] = this.differentDebtorNumber;
        data["debtorNumber"] = this.debtorNumber;
        data["differentInvoiceRecipient"] = this.differentInvoiceRecipient;
        data["invoiceRecipientId"] = this.invoiceRecipientId;
        data["invoiceRecipient"] = this.invoiceRecipient ? this.invoiceRecipient.toJSON() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["modifiedBy"] = this.modifiedBy ? this.modifiedBy.toJSON() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["consultantInsuranceOptionId"] = this.consultantInsuranceOptionId;
        data["markedForLegacyDeletion"] = this.markedForLegacyDeletion;
        data["wasSynced"] = this.wasSynced;
        return data;
    }
}

export interface IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferenceString?: string | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    invoiceRecipient?: ClientResultDto;
    modifiedById?: number | undefined;
    modifiedBy?: EmployeeDto;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;
    markedForLegacyDeletion?: boolean | undefined;
    wasSynced?: boolean | undefined;
}

export class ProjectTypeConfigurationDto implements IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;

    constructor(data?: IProjectTypeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
        }
    }

    static fromJS(data: any): ProjectTypeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        return data;
    }
}

export interface IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProjectTypeDto {
    id?: number;
    name?: string | undefined;
}

export enum RequestProjectTypeValue {
    NormalHighMargin = 1,
    NormalLowMargin = 2,
    NearShoreHighMargin = 3,
    NearShoreLowMargin = 4,
    VMSReferredHighMargin = 5,
    VMSReferredLowMargin = 6,
    NearShoreVMSReferredHighMargin = 7,
    NearShoreVMSReferredLowMargin = 8,
    OtherHighMargin = 9,
    OtherLowMargin = 10,
}

export class RequestProjectTypeValueValueNameDto implements IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;

    constructor(data?: IRequestProjectTypeValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestProjectTypeValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestProjectTypeValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;
}

export enum RequestStatusValue {
    Open = 1,
    Sold = 2,
    Stop = 3,
    Closed = 4,
    Potential = 7,
    AdRunning = 8,
    TenderSent = 9,
    Cancelled = 10,
}

export class RequestStatusValueValueNameDto implements IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;

    constructor(data?: IRequestStatusValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestStatusValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;
}

export class SalesClientDataDto implements ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;

    constructor(data?: ISalesClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.differentEndClient = _data["differentEndClient"];
            this.directClientIdValue = _data["directClientIdValue"];
            this.directClient = _data["directClient"] ? ClientResultDto.fromJS(_data["directClient"]) : <any>undefined;
            this.endClientIdValue = _data["endClientIdValue"];
            this.endClient = _data["endClient"] ? ClientResultDto.fromJS(_data["endClient"]) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionDurationId = _data["clientExtensionDurationId"];
            this.clientExtensionDeadlineId = _data["clientExtensionDeadlineId"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noInvoicingReferenceNumber = _data["noInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipientIdValue = _data["clientInvoicingRecipientIdValue"];
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? ClientResultDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.noInvoicingReferencePerson = _data["noInvoicingReferencePerson"];
            this.invoicingReferencePersonIdValue = _data["invoicingReferencePersonIdValue"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.evaluationsReferencePersonIdValue = _data["evaluationsReferencePersonIdValue"];
            this.evaluationsReferencePerson = _data["evaluationsReferencePerson"] ? ContactResultDto.fromJS(_data["evaluationsReferencePerson"]) : <any>undefined;
            this.evaluationsDisabled = _data["evaluationsDisabled"];
            this.evaluationsDisabledReason = _data["evaluationsDisabledReason"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["differentEndClient"] = this.differentEndClient;
        data["directClientIdValue"] = this.directClientIdValue;
        data["directClient"] = this.directClient ? this.directClient.toJSON() : <any>undefined;
        data["endClientIdValue"] = this.endClientIdValue;
        data["endClient"] = this.endClient ? this.endClient.toJSON() : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionDurationId"] = this.clientExtensionDurationId;
        data["clientExtensionDeadlineId"] = this.clientExtensionDeadlineId;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noInvoicingReferenceNumber"] = this.noInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipientIdValue"] = this.clientInvoicingRecipientIdValue;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["noInvoicingReferencePerson"] = this.noInvoicingReferencePerson;
        data["invoicingReferencePersonIdValue"] = this.invoicingReferencePersonIdValue;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["evaluationsReferencePersonIdValue"] = this.evaluationsReferencePersonIdValue;
        data["evaluationsReferencePerson"] = this.evaluationsReferencePerson ? this.evaluationsReferencePerson.toJSON() : <any>undefined;
        data["evaluationsDisabled"] = this.evaluationsDisabled;
        data["evaluationsDisabledReason"] = this.evaluationsDisabledReason;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
}

export class SalesMainDataDto implements ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: ContractExpirationNotificationInterval[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;

    constructor(data?: ISalesMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectCategoryId = _data["projectCategoryId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            if (Array.isArray(_data["commissions"])) {
                this.commissions = [] as any;
                for (let item of _data["commissions"])
                    this.commissions!.push(CommissionDto.fromJS(item));
            }
            this.salesAccountManagerIdValue = _data["salesAccountManagerIdValue"];
            this.salesAccountManagerData = _data["salesAccountManagerData"] ? EmployeeDto.fromJS(_data["salesAccountManagerData"]) : <any>undefined;
            this.commissionAccountManagerIdValue = _data["commissionAccountManagerIdValue"];
            this.commissionAccountManagerData = _data["commissionAccountManagerData"] ? EmployeeDto.fromJS(_data["commissionAccountManagerData"]) : <any>undefined;
            if (Array.isArray(_data["contractExpirationNotificationIntervalIds"])) {
                this.contractExpirationNotificationIntervalIds = [] as any;
                for (let item of _data["contractExpirationNotificationIntervalIds"])
                    this.contractExpirationNotificationIntervalIds!.push(item);
            }
            this.customContractExpirationNotificationDate = _data["customContractExpirationNotificationDate"] ? moment(_data["customContractExpirationNotificationDate"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): SalesMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectCategoryId"] = this.projectCategoryId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        if (Array.isArray(this.commissions)) {
            data["commissions"] = [];
            for (let item of this.commissions)
                data["commissions"].push(item.toJSON());
        }
        data["salesAccountManagerIdValue"] = this.salesAccountManagerIdValue;
        data["salesAccountManagerData"] = this.salesAccountManagerData ? this.salesAccountManagerData.toJSON() : <any>undefined;
        data["commissionAccountManagerIdValue"] = this.commissionAccountManagerIdValue;
        data["commissionAccountManagerData"] = this.commissionAccountManagerData ? this.commissionAccountManagerData.toJSON() : <any>undefined;
        if (Array.isArray(this.contractExpirationNotificationIntervalIds)) {
            data["contractExpirationNotificationIntervalIds"] = [];
            for (let item of this.contractExpirationNotificationIntervalIds)
                data["contractExpirationNotificationIntervalIds"].push(item);
        }
        data["customContractExpirationNotificationDate"] = this.customContractExpirationNotificationDate ? this.customContractExpirationNotificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: ContractExpirationNotificationInterval[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;
}

export class SimplePublicObject implements ISimplePublicObject {
    id!: string;
    properties!: { [key: string]: string; };
    createdAt!: moment.Moment;
    updatedAt!: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISimplePublicObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.archivedAt = _data["archivedAt"] ? moment(_data["archivedAt"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimplePublicObject {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePublicObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["archivedAt"] = this.archivedAt ? this.archivedAt.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        return data;
    }
}

export interface ISimplePublicObject {
    id: string;
    properties: { [key: string]: string; };
    createdAt: moment.Moment;
    updatedAt: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SimpleRequestLocationDto implements ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;

    constructor(data?: ISimpleRequestLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"] ? IdNameDto.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"] ? IdNameDto.fromJS(_data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimpleRequestLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleRequestLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;
}

export class SpecialRateReportingUnit implements ISpecialRateReportingUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateReportingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateReportingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateReportingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateReportingUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class SpecialRateSpecifiedAs implements ISpecialRateSpecifiedAs {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateSpecifiedAs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateSpecifiedAs {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateSpecifiedAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateSpecifiedAs {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class StartNewWorkflowInputDto implements IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;

    constructor(data?: IStartNewWorkflowInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
        }
    }

    static fromJS(data: any): StartNewWorkflowInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StartNewWorkflowInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["requestId"] = this.requestId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        return data;
    }
}

export interface IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;
}

export class StepDto implements IStepDto {
    typeId?: StepType;
    readonly name?: string | undefined;
    status?: WorkflowStepStatus;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: boolean; } | undefined;

    constructor(data?: IStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.status = _data["status"];
            this.responsiblePerson = _data["responsiblePerson"] ? EmployeeDto.fromJS(_data["responsiblePerson"]) : <any>undefined;
            if (_data["actionsPermissionsForCurrentUser"]) {
                this.actionsPermissionsForCurrentUser = {} as any;
                for (let key in _data["actionsPermissionsForCurrentUser"]) {
                    if (_data["actionsPermissionsForCurrentUser"].hasOwnProperty(key))
                        (<any>this.actionsPermissionsForCurrentUser)![key] = _data["actionsPermissionsForCurrentUser"][key];
                }
            }
        }
    }

    static fromJS(data: any): StepDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["status"] = this.status;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        if (this.actionsPermissionsForCurrentUser) {
            data["actionsPermissionsForCurrentUser"] = {};
            for (let key in this.actionsPermissionsForCurrentUser) {
                if (this.actionsPermissionsForCurrentUser.hasOwnProperty(key))
                    (<any>data["actionsPermissionsForCurrentUser"])[key] = (<any>this.actionsPermissionsForCurrentUser)[key];
            }
        }
        return data;
    }
}

export interface IStepDto {
    typeId?: StepType;
    name?: string | undefined;
    status?: WorkflowStepStatus;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: boolean; } | undefined;
}

export enum StepType {
    Sales = 1,
    Contract = 2,
    Finance = 3,
    Sourcing = 4,
}

export class SupplierResultDto implements ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    externalId?: string;

    constructor(data?: ISupplierResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): SupplierResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    externalId?: string;
}

export class Tenant implements ITenant {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;

    constructor(data?: ITenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            this.timeZone = _data["timeZone"];
            this.culture = _data["culture"];
        }
    }

    static fromJS(data: any): Tenant {
        data = typeof data === 'object' ? data : {};
        let result = new Tenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["timeZone"] = this.timeZone;
        data["culture"] = this.culture;
        return data;
    }
}

export interface ITenant {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;
}

export enum TerminationReason {
    RequestedByClient = 1,
    RequestedByConsultant = 2,
}

export enum TerminationTime {
    AccordingToContract = 1,
    BeforeEndOfContract = 2,
    ContractDidNotStart = 3,
}

export class UpdateClientAttachmentFileInfoInputDto implements IUpdateClientAttachmentFileInfoInputDto {
    clientAttachmentGuid?: string;
    headline?: string | undefined;
    fileType?: ClientAttachmentTypeEnum;
    file?: string | undefined;

    constructor(data?: IUpdateClientAttachmentFileInfoInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientAttachmentGuid = _data["clientAttachmentGuid"];
            this.headline = _data["headline"];
            this.fileType = _data["fileType"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UpdateClientAttachmentFileInfoInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientAttachmentFileInfoInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientAttachmentGuid"] = this.clientAttachmentGuid;
        data["headline"] = this.headline;
        data["fileType"] = this.fileType;
        data["file"] = this.file;
        return data;
    }
}

export interface IUpdateClientAttachmentFileInfoInputDto {
    clientAttachmentGuid?: string;
    headline?: string | undefined;
    fileType?: ClientAttachmentTypeEnum;
    file?: string | undefined;
}

export class UpdateClientSpecialFeeDto implements IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class UpdateClientSpecialRateDto implements IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class WorkflowAlreadyExistsDto implements IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;

    constructor(data?: IWorkflowAlreadyExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.existingWorkflowId = _data["existingWorkflowId"];
        }
    }

    static fromJS(data: any): WorkflowAlreadyExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAlreadyExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingWorkflowId"] = this.existingWorkflowId;
        return data;
    }
}

export interface IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;
}

export class WorkflowDto implements IWorkflowDto {
    workflowId?: string;
    clientName?: string | undefined;
    clientPeriods?: ClientPeriodDto[] | undefined;
    consultantNamesWithRequestUrls?: ConsultantNameWithRequestUrl[] | undefined;

    constructor(data?: IWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientName = _data["clientName"];
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(ClientPeriodDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantNamesWithRequestUrls"])) {
                this.consultantNamesWithRequestUrls = [] as any;
                for (let item of _data["consultantNamesWithRequestUrls"])
                    this.consultantNamesWithRequestUrls!.push(ConsultantNameWithRequestUrl.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientName"] = this.clientName;
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantNamesWithRequestUrls)) {
            data["consultantNamesWithRequestUrls"] = [];
            for (let item of this.consultantNamesWithRequestUrls)
                data["consultantNamesWithRequestUrls"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowDto {
    workflowId?: string;
    clientName?: string | undefined;
    clientPeriods?: ClientPeriodDto[] | undefined;
    consultantNamesWithRequestUrls?: ConsultantNameWithRequestUrl[] | undefined;
}

export enum WorkflowElementType {
    ClientPeriod = 0,
    ConsultantPeriod = 1,
    ConsultantTermination = 2,
    WorkflowTermination = 3,
}

export class WorkflowHistoryDto implements IWorkflowHistoryDto {
    workflowId?: string;
    elementType?: WorkflowElementType;
    elementId?: string | undefined;
    eventName?: string | undefined;
    initiatedBy?: EmployeeDto;
    operationId?: string | undefined;
    occurredAtUtc?: moment.Moment;

    constructor(data?: IWorkflowHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.elementType = _data["elementType"];
            this.elementId = _data["elementId"];
            this.eventName = _data["eventName"];
            this.initiatedBy = _data["initiatedBy"] ? EmployeeDto.fromJS(_data["initiatedBy"]) : <any>undefined;
            this.operationId = _data["operationId"];
            this.occurredAtUtc = _data["occurredAtUtc"] ? moment(_data["occurredAtUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["elementType"] = this.elementType;
        data["elementId"] = this.elementId;
        data["eventName"] = this.eventName;
        data["initiatedBy"] = this.initiatedBy ? this.initiatedBy.toJSON() : <any>undefined;
        data["operationId"] = this.operationId;
        data["occurredAtUtc"] = this.occurredAtUtc ? this.occurredAtUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWorkflowHistoryDto {
    workflowId?: string;
    elementType?: WorkflowElementType;
    elementId?: string | undefined;
    eventName?: string | undefined;
    initiatedBy?: EmployeeDto;
    operationId?: string | undefined;
    occurredAtUtc?: moment.Moment;
}

export class WorkflowHistoryDtoPaginatedList implements IWorkflowHistoryDtoPaginatedList {
    items?: WorkflowHistoryDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IWorkflowHistoryDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkflowHistoryDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): WorkflowHistoryDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowHistoryDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IWorkflowHistoryDtoPaginatedList {
    items?: WorkflowHistoryDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkflowListItemDto implements IWorkflowListItemDto {
    workflowId?: string;
    clientName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    isDeleted?: boolean;
    consultants?: ConsultantResultDto[] | undefined;
    openProcesses?: WorkflowProcessDto[] | undefined;
    accountManager?: EmployeeDto;

    constructor(data?: IWorkflowListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientName = _data["clientName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.workflowStatusWithEmployee = _data["workflowStatusWithEmployee"] ? WorkflowStatusWithEmployeeDto.fromJS(_data["workflowStatusWithEmployee"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(ConsultantResultDto.fromJS(item));
            }
            if (Array.isArray(_data["openProcesses"])) {
                this.openProcesses = [] as any;
                for (let item of _data["openProcesses"])
                    this.openProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
            this.accountManager = _data["accountManager"] ? EmployeeDto.fromJS(_data["accountManager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientName"] = this.clientName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["workflowStatusWithEmployee"] = this.workflowStatusWithEmployee ? this.workflowStatusWithEmployee.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        if (Array.isArray(this.openProcesses)) {
            data["openProcesses"] = [];
            for (let item of this.openProcesses)
                data["openProcesses"].push(item.toJSON());
        }
        data["accountManager"] = this.accountManager ? this.accountManager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowListItemDto {
    workflowId?: string;
    clientName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    isDeleted?: boolean;
    consultants?: ConsultantResultDto[] | undefined;
    openProcesses?: WorkflowProcessDto[] | undefined;
    accountManager?: EmployeeDto;
}

export class WorkflowListItemDtoPaginatedList implements IWorkflowListItemDtoPaginatedList {
    items?: WorkflowListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IWorkflowListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkflowListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): WorkflowListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IWorkflowListItemDtoPaginatedList {
    items?: WorkflowListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkflowOverviewDto implements IWorkflowOverviewDto {
    incompleteWorkflowProcesses?: WorkflowProcessDto[] | undefined;
    clientGanntRows?: ClientGanttRow[] | undefined;
    consultantGanntRows?: ConsultantGanttRow[] | undefined;

    constructor(data?: IWorkflowOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incompleteWorkflowProcesses"])) {
                this.incompleteWorkflowProcesses = [] as any;
                for (let item of _data["incompleteWorkflowProcesses"])
                    this.incompleteWorkflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["clientGanntRows"])) {
                this.clientGanntRows = [] as any;
                for (let item of _data["clientGanntRows"])
                    this.clientGanntRows!.push(ClientGanttRow.fromJS(item));
            }
            if (Array.isArray(_data["consultantGanntRows"])) {
                this.consultantGanntRows = [] as any;
                for (let item of _data["consultantGanntRows"])
                    this.consultantGanntRows!.push(ConsultantGanttRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incompleteWorkflowProcesses)) {
            data["incompleteWorkflowProcesses"] = [];
            for (let item of this.incompleteWorkflowProcesses)
                data["incompleteWorkflowProcesses"].push(item.toJSON());
        }
        if (Array.isArray(this.clientGanntRows)) {
            data["clientGanntRows"] = [];
            for (let item of this.clientGanntRows)
                data["clientGanntRows"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantGanntRows)) {
            data["consultantGanntRows"] = [];
            for (let item of this.consultantGanntRows)
                data["consultantGanntRows"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowOverviewDto {
    incompleteWorkflowProcesses?: WorkflowProcessDto[] | undefined;
    clientGanntRows?: ClientGanttRow[] | undefined;
    consultantGanntRows?: ConsultantGanttRow[] | undefined;
}

export class WorkflowPeriodForLegacyContractDto implements IWorkflowPeriodForLegacyContractDto {
    workflowId?: string;
    client?: LegacyClientDto;
    endClient?: LegacyClientDto;
    clientInvoicingRecipient?: LegacyClientDto;
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    isFirstPeriod?: boolean;
    isClientPeriod?: boolean;
    firstWorkflowPeriodStartDate?: moment.Moment | undefined;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    clientRateDto?: ClientRateDto;
    consultantRateDto?: ConsultantRateDto;
    noClientExtensionOption?: boolean;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientExtensionDeadlineName?: string | undefined;
    clientExtensionDurationName?: string | undefined;
    clientSpecialContractTerms?: string | undefined;
    consultantSpecialContractTerms?: string | undefined;
    clientProjectDescription?: string | undefined;
    consultantProjectDescription?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
    projectType?: ProjectTypeDto;
    employmentType?: EmploymentType;
    expectedWorkload?: ExpectedWorkload;
    workplace?: WorkplaceDto;
    salesManager?: Pm3EmployeeDto;
    invoicingReferenceContactDto?: ContactResultDto;

    constructor(data?: IWorkflowPeriodForLegacyContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.client = _data["client"] ? LegacyClientDto.fromJS(_data["client"]) : <any>undefined;
            this.endClient = _data["endClient"] ? LegacyClientDto.fromJS(_data["endClient"]) : <any>undefined;
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? LegacyClientDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.legacyConsultantId = _data["legacyConsultantId"];
            this.consultantTenantId = _data["consultantTenantId"];
            this.isFirstPeriod = _data["isFirstPeriod"];
            this.isClientPeriod = _data["isClientPeriod"];
            this.firstWorkflowPeriodStartDate = _data["firstWorkflowPeriodStartDate"] ? moment(_data["firstWorkflowPeriodStartDate"].toString()) : <any>undefined;
            this.periodStartDate = _data["periodStartDate"] ? moment(_data["periodStartDate"].toString()) : <any>undefined;
            this.periodEndDate = _data["periodEndDate"] ? moment(_data["periodEndDate"].toString()) : <any>undefined;
            this.clientRateDto = _data["clientRateDto"] ? ClientRateDto.fromJS(_data["clientRateDto"]) : <any>undefined;
            this.consultantRateDto = _data["consultantRateDto"] ? ConsultantRateDto.fromJS(_data["consultantRateDto"]) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientExtensionDeadlineName = _data["clientExtensionDeadlineName"];
            this.clientExtensionDurationName = _data["clientExtensionDurationName"];
            this.clientSpecialContractTerms = _data["clientSpecialContractTerms"];
            this.consultantSpecialContractTerms = _data["consultantSpecialContractTerms"];
            this.clientProjectDescription = _data["clientProjectDescription"];
            this.consultantProjectDescription = _data["consultantProjectDescription"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
            this.projectType = _data["projectType"] ? ProjectTypeDto.fromJS(_data["projectType"]) : <any>undefined;
            this.employmentType = _data["employmentType"] ? EmploymentType.fromJS(_data["employmentType"]) : <any>undefined;
            this.expectedWorkload = _data["expectedWorkload"] ? ExpectedWorkload.fromJS(_data["expectedWorkload"]) : <any>undefined;
            this.workplace = _data["workplace"] ? WorkplaceDto.fromJS(_data["workplace"]) : <any>undefined;
            this.salesManager = _data["salesManager"] ? Pm3EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.invoicingReferenceContactDto = _data["invoicingReferenceContactDto"] ? ContactResultDto.fromJS(_data["invoicingReferenceContactDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowPeriodForLegacyContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodForLegacyContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["endClient"] = this.endClient ? this.endClient.toJSON() : <any>undefined;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["legacyConsultantId"] = this.legacyConsultantId;
        data["consultantTenantId"] = this.consultantTenantId;
        data["isFirstPeriod"] = this.isFirstPeriod;
        data["isClientPeriod"] = this.isClientPeriod;
        data["firstWorkflowPeriodStartDate"] = this.firstWorkflowPeriodStartDate ? this.firstWorkflowPeriodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? this.periodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodEndDate"] = this.periodEndDate ? this.periodEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["clientRateDto"] = this.clientRateDto ? this.clientRateDto.toJSON() : <any>undefined;
        data["consultantRateDto"] = this.consultantRateDto ? this.consultantRateDto.toJSON() : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientExtensionDeadlineName"] = this.clientExtensionDeadlineName;
        data["clientExtensionDurationName"] = this.clientExtensionDurationName;
        data["clientSpecialContractTerms"] = this.clientSpecialContractTerms;
        data["consultantSpecialContractTerms"] = this.consultantSpecialContractTerms;
        data["clientProjectDescription"] = this.clientProjectDescription;
        data["consultantProjectDescription"] = this.consultantProjectDescription;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["employmentType"] = this.employmentType ? this.employmentType.toJSON() : <any>undefined;
        data["expectedWorkload"] = this.expectedWorkload ? this.expectedWorkload.toJSON() : <any>undefined;
        data["workplace"] = this.workplace ? this.workplace.toJSON() : <any>undefined;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["invoicingReferenceContactDto"] = this.invoicingReferenceContactDto ? this.invoicingReferenceContactDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowPeriodForLegacyContractDto {
    workflowId?: string;
    client?: LegacyClientDto;
    endClient?: LegacyClientDto;
    clientInvoicingRecipient?: LegacyClientDto;
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    isFirstPeriod?: boolean;
    isClientPeriod?: boolean;
    firstWorkflowPeriodStartDate?: moment.Moment | undefined;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    clientRateDto?: ClientRateDto;
    consultantRateDto?: ConsultantRateDto;
    noClientExtensionOption?: boolean;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientExtensionDeadlineName?: string | undefined;
    clientExtensionDurationName?: string | undefined;
    clientSpecialContractTerms?: string | undefined;
    consultantSpecialContractTerms?: string | undefined;
    clientProjectDescription?: string | undefined;
    consultantProjectDescription?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
    projectType?: ProjectTypeDto;
    employmentType?: EmploymentType;
    expectedWorkload?: ExpectedWorkload;
    workplace?: WorkplaceDto;
    salesManager?: Pm3EmployeeDto;
    invoicingReferenceContactDto?: ContactResultDto;
}

export class WorkflowPeriodLegalContractStatusUpdateInputDto implements IWorkflowPeriodLegalContractStatusUpdateInputDto {
    periodId?: string;
    legalContractStatus?: LegalContractStatus;
    isInternalContract?: boolean;

    constructor(data?: IWorkflowPeriodLegalContractStatusUpdateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodId = _data["periodId"];
            this.legalContractStatus = _data["legalContractStatus"];
            this.isInternalContract = _data["isInternalContract"];
        }
    }

    static fromJS(data: any): WorkflowPeriodLegalContractStatusUpdateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodLegalContractStatusUpdateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodId"] = this.periodId;
        data["legalContractStatus"] = this.legalContractStatus;
        data["isInternalContract"] = this.isInternalContract;
        return data;
    }
}

export interface IWorkflowPeriodLegalContractStatusUpdateInputDto {
    periodId?: string;
    legalContractStatus?: LegalContractStatus;
    isInternalContract?: boolean;
}

export class WorkflowProcessDto implements IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    readonly name?: string | undefined;
    consultantPeriodId?: string | undefined;
    consultant?: ConsultantResultDto;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    terminationEndDate?: moment.Moment | undefined;
    steps?: StepDto[] | undefined;

    constructor(data?: IWorkflowProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.periodStartDate = _data["periodStartDate"] ? moment(_data["periodStartDate"].toString()) : <any>undefined;
            this.periodEndDate = _data["periodEndDate"] ? moment(_data["periodEndDate"].toString()) : <any>undefined;
            this.terminationEndDate = _data["terminationEndDate"] ? moment(_data["terminationEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(StepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? this.periodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodEndDate"] = this.periodEndDate ? this.periodEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["terminationEndDate"] = this.terminationEndDate ? this.terminationEndDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    name?: string | undefined;
    consultantPeriodId?: string | undefined;
    consultant?: ConsultantResultDto;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    terminationEndDate?: moment.Moment | undefined;
    steps?: StepDto[] | undefined;
}

export enum WorkflowProcessType {
    StartClientPeriod = 1,
    ChangeClientPeriod = 2,
    ExtendClientPeriod = 3,
    StartConsultantPeriod = 4,
    ChangeConsultantPeriod = 5,
    ExtendConsultantPeriod = 6,
    TerminateWorkflow = 7,
    TerminateConsultant = 8,
}

export enum WorkflowStatus {
    Pending = 1,
    Active = 2,
    Finished = 3,
}

export class WorkflowStatusWithEmployeeDto implements IWorkflowStatusWithEmployeeDto {
    status?: WorkflowStatus;
    responsibleEmployee?: EmployeeDto;
    processType?: WorkflowProcessType;

    constructor(data?: IWorkflowStatusWithEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.responsibleEmployee = _data["responsibleEmployee"] ? EmployeeDto.fromJS(_data["responsibleEmployee"]) : <any>undefined;
            this.processType = _data["processType"];
        }
    }

    static fromJS(data: any): WorkflowStatusWithEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusWithEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["responsibleEmployee"] = this.responsibleEmployee ? this.responsibleEmployee.toJSON() : <any>undefined;
        data["processType"] = this.processType;
        return data;
    }
}

export interface IWorkflowStatusWithEmployeeDto {
    status?: WorkflowStatus;
    responsibleEmployee?: EmployeeDto;
    processType?: WorkflowProcessType;
}

export enum WorkflowStepStatus {
    Upcoming = 1,
    Pending = 2,
    Completed = 3,
}

export class WorkflowTerminationContractDataCommandDto implements IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;
}

export class WorkflowTerminationContractDataQueryDto implements IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;
}

export class WorkflowTerminationSalesDataCommandDto implements IWorkflowTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;

    constructor(data?: IWorkflowTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        return data;
    }
}

export interface IWorkflowTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
}

export class WorkflowTerminationSalesDataQueryDto implements IWorkflowTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    clientId?: number;
    finalEvaluationReferencePerson?: ContactDto;

    constructor(data?: IWorkflowTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.clientId = _data["clientId"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["clientId"] = this.clientId;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    clientId?: number;
    finalEvaluationReferencePerson?: ContactDto;
}

export class WorkflowTerminationSourcingDataCommandDto implements IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;
}

export class WorkflowTerminationSourcingDataQueryDto implements IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;
}

export class WorkplaceDto implements IWorkplaceDto {
    isOnsite?: boolean;
    percentageOnSite?: number | undefined;
    onSiteClientAddress?: ClientAddressDto;
    onSiteClientName?: string | undefined;
    isRemote?: boolean;
    remoteCountryName?: string | undefined;
    isEmagineOffice?: boolean;
    emagineOffice?: EmagineOfficeDto;

    constructor(data?: IWorkplaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isOnsite = _data["isOnsite"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.onSiteClientAddress = _data["onSiteClientAddress"] ? ClientAddressDto.fromJS(_data["onSiteClientAddress"]) : <any>undefined;
            this.onSiteClientName = _data["onSiteClientName"];
            this.isRemote = _data["isRemote"];
            this.remoteCountryName = _data["remoteCountryName"];
            this.isEmagineOffice = _data["isEmagineOffice"];
            this.emagineOffice = _data["emagineOffice"] ? EmagineOfficeDto.fromJS(_data["emagineOffice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkplaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkplaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isOnsite"] = this.isOnsite;
        data["percentageOnSite"] = this.percentageOnSite;
        data["onSiteClientAddress"] = this.onSiteClientAddress ? this.onSiteClientAddress.toJSON() : <any>undefined;
        data["onSiteClientName"] = this.onSiteClientName;
        data["isRemote"] = this.isRemote;
        data["remoteCountryName"] = this.remoteCountryName;
        data["isEmagineOffice"] = this.isEmagineOffice;
        data["emagineOffice"] = this.emagineOffice ? this.emagineOffice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkplaceDto {
    isOnsite?: boolean;
    percentageOnSite?: number | undefined;
    onSiteClientAddress?: ClientAddressDto;
    onSiteClientName?: string | undefined;
    isRemote?: boolean;
    remoteCountryName?: string | undefined;
    isEmagineOffice?: boolean;
    emagineOffice?: EmagineOfficeDto;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}