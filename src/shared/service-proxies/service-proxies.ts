/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param redirectUri (optional) 
     * @return Success
     */
    signIn(scheme: string, redirectUri?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignIn/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param redirectUri (optional) 
     * @param scope (optional) 
     * @param loginHint (optional) 
     * @param domainHint (optional) 
     * @param claims (optional) 
     * @param policy (optional) 
     * @return Success
     */
    challenge(scheme: string, redirectUri?: string | undefined, scope?: string | undefined, loginHint?: string | undefined, domainHint?: string | undefined, claims?: string | undefined, policy?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/Challenge/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (loginHint === null)
            throw new Error("The parameter 'loginHint' cannot be null.");
        else if (loginHint !== undefined)
            url_ += "loginHint=" + encodeURIComponent("" + loginHint) + "&";
        if (domainHint === null)
            throw new Error("The parameter 'domainHint' cannot be null.");
        else if (domainHint !== undefined)
            url_ += "domainHint=" + encodeURIComponent("" + domainHint) + "&";
        if (claims === null)
            throw new Error("The parameter 'claims' cannot be null.");
        else if (claims !== undefined)
            url_ += "claims=" + encodeURIComponent("" + claims) + "&";
        if (policy === null)
            throw new Error("The parameter 'policy' cannot be null.");
        else if (policy !== undefined)
            url_ += "policy=" + encodeURIComponent("" + policy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallenge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallenge(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChallenge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    signOut(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignOut/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    resetPassword(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/ResetPassword/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    editProfile(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/EditProfile/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClientPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesPut(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    salesGet(clientPeriodId: string): Observable<ClientPeriodSalesDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientPeriodSalesDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientPeriodSalesDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processSalesGet(response: HttpResponseBase): Observable<ClientPeriodSalesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodSalesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodSalesDataDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contractsPut(clientPeriodId: string, body?: ClientPeriodContractsDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processContractsPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    contractsGet(clientPeriodId: string): Observable<ClientPeriodContractsDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientPeriodContractsDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientPeriodContractsDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processContractsGet(response: HttpResponseBase): Observable<ClientPeriodContractsDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodContractsDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodContractsDataDto>(<any>null);
    }
}

@Injectable()
export class SalesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountManagerEditFinish(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales/account-manager-edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountManagerEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountManagerEditFinish(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAccountManagerEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    contractManagerEdit(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts/contract-manager-edit";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractManagerEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractManagerEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processContractManagerEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param countryFilter (optional) 
     * @param ownerFilter (optional) 
     * @param isActive (optional) 
     * @param excludeDeleted (optional) 
     * @param onlyWrongfullyDeletedInHubspot (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clients(search?: string | undefined, countryFilter?: number[] | undefined, ownerFilter?: number[] | undefined, isActive?: boolean | undefined, excludeDeleted?: boolean | undefined, onlyWrongfullyDeletedInHubspot?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (countryFilter === null)
            throw new Error("The parameter 'countryFilter' cannot be null.");
        else if (countryFilter !== undefined)
            countryFilter && countryFilter.forEach(item => { url_ += "countryFilter=" + encodeURIComponent("" + item) + "&"; });
        if (ownerFilter === null)
            throw new Error("The parameter 'ownerFilter' cannot be null.");
        else if (ownerFilter !== undefined)
            ownerFilter && ownerFilter.forEach(item => { url_ += "ownerFilter=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        if (onlyWrongfullyDeletedInHubspot === null)
            throw new Error("The parameter 'onlyWrongfullyDeletedInHubspot' cannot be null.");
        else if (onlyWrongfullyDeletedInHubspot !== undefined)
            url_ += "onlyWrongfullyDeletedInHubspot=" + encodeURIComponent("" + onlyWrongfullyDeletedInHubspot) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(<any>response_);
                } catch (e) {
                    return <Observable<ClientListItemDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListItemDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListItemDtoPaginatedList>(<any>null);
    }
}

@Injectable()
export class ClientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param projectTypeFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clientOverview(search?: string | undefined, projectTypeFilter?: string[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientOverviewListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/client-overview?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectTypeFilter === null)
            throw new Error("The parameter 'projectTypeFilter' cannot be null.");
        else if (projectTypeFilter !== undefined)
            projectTypeFilter && projectTypeFilter.forEach(item => { url_ += "projectTypeFilter=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientOverview(<any>response_);
                } catch (e) {
                    return <Observable<ClientOverviewListItemDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientOverviewListItemDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processClientOverview(response: HttpResponseBase): Observable<ClientOverviewListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientOverviewListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientOverviewListItemDtoPaginatedList>(<any>null);
    }

    /**
     * @return Success
     */
    specialRatesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialRateDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientSpecialRateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientSpecialRateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialRatesGet(response: HttpResponseBase): Observable<ClientSpecialRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialRateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialRateDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPost(clientId: number, body?: AddClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialRatesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPut(clientId: number, body?: UpdateClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialRatesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    specialFeesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialFeeDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientSpecialFeeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientSpecialFeeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialFeesGet(response: HttpResponseBase): Observable<ClientSpecialFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialFeeDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPost(clientId: number, body?: AddClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialFeesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPut(clientId: number, body?: UpdateClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSpecialFeesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    requestTrack(legacyClientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientRequestTrackDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{legacyClientId}/request-track?";
        if (legacyClientId === undefined || legacyClientId === null)
            throw new Error("The parameter 'legacyClientId' must be defined.");
        url_ = url_.replace("{legacyClientId}", encodeURIComponent("" + legacyClientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTrack(<any>response_);
                } catch (e) {
                    return <Observable<ClientRequestTrackDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientRequestTrackDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processRequestTrack(response: HttpResponseBase): Observable<ClientRequestTrackDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRequestTrackDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRequestTrackDtoPaginatedList>(<any>null);
    }

    /**
     * @param excludeDeleted (optional) 
     * @return Success
     */
    contacts(clientId: number, excludeDeleted?: boolean | undefined): Observable<ContactDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/contacts?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDto[]>(<any>null);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    countries(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    currencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencies(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCurrencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    tenants(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/tenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenants(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTenants(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    deliveryTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/delivery-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliveryTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliveryTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeliveryTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    invoiceFrequencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoice-frequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceFrequencies(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processInvoiceFrequencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    invoicingTimes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoicing-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicingTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicingTimes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processInvoicingTimes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    rateUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/rate-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateUnitTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processRateUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    salesTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/sales-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSalesTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    signerRoles(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/signer-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerRoles(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSignerRoles(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    margins(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/margins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMargins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMargins(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processMargins(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientSpecialRateSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateSpecifiedAs(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientSpecialRateSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientSpecialRateReportingUnits(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-reporting-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateReportingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateReportingUnits(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientSpecialRateReportingUnits(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientSpecialRateOrFeeDirections(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-or-fee-directions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateOrFeeDirections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateOrFeeDirections(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientSpecialRateOrFeeDirections(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientSpecialFeeSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeSpecifiedAs(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientSpecialFeeSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientSpecialFeeFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeFrequency(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientSpecialFeeFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientExtensionDuration(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDuration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDuration(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientExtensionDuration(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientExtensionDeadline(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-deadline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDeadline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDeadline(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientExtensionDeadline(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    projectType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodType(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    clientTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientTimeReportingCap(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processClientTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    consultantTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTimeReportingCap(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processConsultantTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    consultantPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodType(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processConsultantPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    periodStepType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/period-step-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPeriodStepType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPeriodStepType(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPeriodStepType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    emagineOffice(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/emagine-office";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmagineOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmagineOffice(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processEmagineOffice(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    contractExpirationNotificationInterval(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/contract-expiration-notification-interval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractExpirationNotificationInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractExpirationNotificationInterval(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processContractExpirationNotificationInterval(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    commissionFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionFrequency(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCommissionFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    commissionTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCommissionTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    recipientTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/recipient-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecipientTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecipientTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processRecipientTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(<any>null);
    }
}

@Injectable()
export class HubSpotContractFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    listContracts(userId?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotContractFetch/ListContracts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListContracts(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processListContracts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HubSpotInstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    auth(code?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/auth?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HubSpotSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    syncAllWithHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncAllWithHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllWithHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllWithHubSpot(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAllWithHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    detectCompanyMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyMerges(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDetectCompanyMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    detectContactMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactMerges(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDetectContactMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    detectCompanyRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyRestoreAndHardDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDetectCompanyRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    detectContactRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactRestoreAndHardDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDetectContactRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    syncClientParents(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncClientParents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncClientParents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncClientParents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncClientParents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HubSpotTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testCreateClientInHubSpot(): Observable<SimplePublicObject> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestCreateClientInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCreateClientInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCreateClientInHubSpot(<any>response_);
                } catch (e) {
                    return <Observable<SimplePublicObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimplePublicObject>><any>_observableThrow(response_);
        }));
    }

    protected processTestCreateClientInHubSpot(response: HttpResponseBase): Observable<SimplePublicObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimplePublicObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePublicObject>(<any>null);
    }

    /**
     * @return Success
     */
    testSyncUpdateToLegacy(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestSyncUpdateToLegacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSyncUpdateToLegacy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSyncUpdateToLegacy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestSyncUpdateToLegacy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param nameFilter (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    employees(nameFilter?: string | undefined, idsToExclude?: number[] | undefined): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Employees?";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "nameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDto[]>(<any>null);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartNewWorkflowInputDto | undefined): Observable<NewWorkflowCreatedDto> {
        let url_ = this.baseUrl + "/api/Workflow/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(<any>response_);
                } catch (e) {
                    return <Observable<NewWorkflowCreatedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NewWorkflowCreatedDto>><any>_observableThrow(response_);
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<NewWorkflowCreatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewWorkflowCreatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewWorkflowCreatedDto>(<any>null);
    }

    /**
     * @return Success
     */
    workflowExists(requestConsultantId: number): Observable<WorkflowAlreadyExistsDto> {
        let url_ = this.baseUrl + "/api/Workflow/{requestConsultantId}/workflow-exists";
        if (requestConsultantId === undefined || requestConsultantId === null)
            throw new Error("The parameter 'requestConsultantId' must be defined.");
        url_ = url_.replace("{requestConsultantId}", encodeURIComponent("" + requestConsultantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowExists(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowAlreadyExistsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowAlreadyExistsDto>><any>_observableThrow(response_);
        }));
    }

    protected processWorkflowExists(response: HttpResponseBase): Observable<WorkflowAlreadyExistsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowAlreadyExistsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowAlreadyExistsDto>(<any>null);
    }

    /**
     * @param clientPeriodId (optional) 
     * @param includeProcesses (optional) 
     * @return Success
     */
    clientPeriods(workflowId: string, clientPeriodId?: string | undefined, includeProcesses?: boolean | undefined): Observable<WorkflowDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/clientPeriods?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' cannot be null.");
        else if (clientPeriodId !== undefined)
            url_ += "clientPeriodId=" + encodeURIComponent("" + clientPeriodId) + "&";
        if (includeProcesses === null)
            throw new Error("The parameter 'includeProcesses' cannot be null.");
        else if (includeProcesses !== undefined)
            url_ += "includeProcesses=" + encodeURIComponent("" + includeProcesses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriods(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowDto>><any>_observableThrow(response_);
        }));
    }

    protected processClientPeriods(response: HttpResponseBase): Observable<WorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowDto>(<any>null);
    }
}

export class AddClientSpecialFeeDto implements IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AddClientSpecialRateDto implements IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.specialRateCategoryId = _data["specialRateCategoryId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["specialRateCategoryId"] = this.specialRateCategoryId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class ClientListItemDto implements IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    readonly isDeleted?: boolean;
    readonly isWrongfullyDeletedInHubspot?: boolean;
    readonly isActive?: boolean;

    constructor(data?: IClientListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crmClientId = _data["crmClientId"];
            this.legacyClientId = _data["legacyClientId"];
            this.name = _data["name"];
            this.clientAddress_Address = _data["clientAddress_Address"];
            this.clientAddress_Address2 = _data["clientAddress_Address2"];
            this.clientAddress_PostCode = _data["clientAddress_PostCode"];
            this.clientAddress_City = _data["clientAddress_City"];
            this.clientAddress_Country_Id = _data["clientAddress_Country_Id"];
            this.clientAddress_Country_Name = _data["clientAddress_Country_Name"];
            this.clientAddress_Country_Code = _data["clientAddress_Country_Code"];
            this.phone = _data["phone"];
            this.owner_Id = _data["owner_Id"];
            this.owner_Name = _data["owner_Name"];
            this.tenant_Id = _data["tenant_Id"];
            (<any>this).isDeleted = _data["isDeleted"];
            (<any>this).isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            (<any>this).isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClientListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crmClientId"] = this.crmClientId;
        data["legacyClientId"] = this.legacyClientId;
        data["name"] = this.name;
        data["clientAddress_Address"] = this.clientAddress_Address;
        data["clientAddress_Address2"] = this.clientAddress_Address2;
        data["clientAddress_PostCode"] = this.clientAddress_PostCode;
        data["clientAddress_City"] = this.clientAddress_City;
        data["clientAddress_Country_Id"] = this.clientAddress_Country_Id;
        data["clientAddress_Country_Name"] = this.clientAddress_Country_Name;
        data["clientAddress_Country_Code"] = this.clientAddress_Country_Code;
        data["phone"] = this.phone;
        data["owner_Id"] = this.owner_Id;
        data["owner_Name"] = this.owner_Name;
        data["tenant_Id"] = this.tenant_Id;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;
}

export class ClientListItemDtoPaginatedList implements IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientOverviewListItemDto implements IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;

    constructor(data?: IClientOverviewListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.clientName = _data["clientName"];
            this.consultantName = _data["consultantName"];
            this.note = _data["note"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.contractsCount = _data["contractsCount"];
            this.contractsPendingCount = _data["contractsPendingCount"];
            this.contractsExtensionsOkCount = _data["contractsExtensionsOkCount"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["clientName"] = this.clientName;
        data["consultantName"] = this.consultantName;
        data["note"] = this.note;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["contractsCount"] = this.contractsCount;
        data["contractsPendingCount"] = this.contractsPendingCount;
        data["contractsExtensionsOkCount"] = this.contractsExtensionsOkCount;
        return data;
    }
}

export interface IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;
}

export class ClientOverviewListItemDtoPaginatedList implements IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientOverviewListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientOverviewListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientPeriodContractsDataDto implements IClientPeriodContractsDataDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    consultantData?: ConsultantContractsDataDto[] | undefined;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;

    constructor(data?: IClientPeriodContractsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataDto.fromJS(item));
            }
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        return data;
    }
}

export interface IClientPeriodContractsDataDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    consultantData?: ConsultantContractsDataDto[] | undefined;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
}

export class ClientPeriodDto implements IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    additionalInfo?: string | undefined;
    isCompleted?: boolean;
    workflowProcesses?: WorkflowProcessDto[] | undefined;

    constructor(data?: IClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.additionalInfo = _data["additionalInfo"];
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["workflowProcesses"])) {
                this.workflowProcesses = [] as any;
                for (let item of _data["workflowProcesses"])
                    this.workflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["additionalInfo"] = this.additionalInfo;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.workflowProcesses)) {
            data["workflowProcesses"] = [];
            for (let item of this.workflowProcesses)
                data["workflowProcesses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    additionalInfo?: string | undefined;
    isCompleted?: boolean;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
}

export class ClientPeriodSalesDataDto implements IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;

    constructor(data?: IClientPeriodSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesMainData = _data["salesMainData"] ? SalesMainDataDto.fromJS(_data["salesMainData"]) : <any>undefined;
            this.salesClientData = _data["salesClientData"] ? SalesClientDataDto.fromJS(_data["salesClientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantSalesData"])) {
                this.consultantSalesData = [] as any;
                for (let item of _data["consultantSalesData"])
                    this.consultantSalesData!.push(ConsultantSalesDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesMainData"] = this.salesMainData ? this.salesMainData.toJSON() : <any>undefined;
        data["salesClientData"] = this.salesClientData ? this.salesClientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantSalesData)) {
            data["consultantSalesData"] = [];
            for (let item of this.consultantSalesData)
                data["consultantSalesData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
}

export class ClientRateDto implements IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IClientRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.invoiceCurrencyId = _data["invoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ClientRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["invoiceCurrencyId"] = this.invoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ClientRequestTrackDto implements IClientRequestTrackDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;

    constructor(data?: IClientRequestTrackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.headline = _data["headline"];
            this.status = _data["status"] ? RequestStatusValueValueNameDto.fromJS(_data["status"]) : <any>undefined;
            this.clientDeadline = _data["clientDeadline"] ? moment(_data["clientDeadline"].toString()) : <any>undefined;
            this.dateAdded = _data["dateAdded"] ? moment(_data["dateAdded"].toString()) : <any>undefined;
            this.projectType = _data["projectType"] ? RequestProjectTypeValueValueNameDto.fromJS(_data["projectType"]) : <any>undefined;
            this.priority = _data["priority"];
            this.numberOfConsultants = _data["numberOfConsultants"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(SimpleRequestLocationDto.fromJS(item));
            }
            if (Array.isArray(_data["requestSourcers"])) {
                this.requestSourcers = [] as any;
                for (let item of _data["requestSourcers"])
                    this.requestSourcers!.push(EmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["accountManagers"])) {
                this.accountManagers = [] as any;
                for (let item of _data["accountManagers"])
                    this.accountManagers!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRequestTrackDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["headline"] = this.headline;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["clientDeadline"] = this.clientDeadline ? this.clientDeadline.toISOString() : <any>undefined;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["priority"] = this.priority;
        data["numberOfConsultants"] = this.numberOfConsultants;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.requestSourcers)) {
            data["requestSourcers"] = [];
            for (let item of this.requestSourcers)
                data["requestSourcers"].push(item.toJSON());
        }
        if (Array.isArray(this.accountManagers)) {
            data["accountManagers"] = [];
            for (let item of this.accountManagers)
                data["accountManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientRequestTrackDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;
}

export class ClientRequestTrackDtoPaginatedList implements IClientRequestTrackDtoPaginatedList {
    items?: ClientRequestTrackDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientRequestTrackDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientRequestTrackDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientRequestTrackDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientRequestTrackDtoPaginatedList {
    items?: ClientRequestTrackDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientSpecialFeeDto implements IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirection = _data["specialRateOrFeeDirection"] ? EnumEntityTypeDto.fromJS(_data["specialRateOrFeeDirection"]) : <any>undefined;
            this.clientSpecialFeeFrequency = _data["clientSpecialFeeFrequency"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeFrequency"]) : <any>undefined;
            this.clientSpecialFeeSpecifiedAs = _data["clientSpecialFeeSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrency = _data["prodataToProdataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["prodataToProdataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirection"] = this.specialRateOrFeeDirection ? this.specialRateOrFeeDirection.toJSON() : <any>undefined;
        data["clientSpecialFeeFrequency"] = this.clientSpecialFeeFrequency ? this.clientSpecialFeeFrequency.toJSON() : <any>undefined;
        data["clientSpecialFeeSpecifiedAs"] = this.clientSpecialFeeSpecifiedAs ? this.clientSpecialFeeSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrency"] = this.prodataToProdataRateCurrency ? this.prodataToProdataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientSpecialRateDto implements IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    specialRateCategory?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirection = _data["specialRateOrFeeDirection"] ? EnumEntityTypeDto.fromJS(_data["specialRateOrFeeDirection"]) : <any>undefined;
            this.specialRateReportingUnit = _data["specialRateReportingUnit"] ? SpecialRateReportingUnit.fromJS(_data["specialRateReportingUnit"]) : <any>undefined;
            this.specialRateSpecifiedAs = _data["specialRateSpecifiedAs"] ? SpecialRateSpecifiedAs.fromJS(_data["specialRateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.proDataToProDataRate = _data["proDataToProDataRate"];
            this.proDataToProDataRateCurrency = _data["proDataToProDataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["proDataToProDataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.specialRateCategory = _data["specialRateCategory"] ? EnumEntityTypeDto.fromJS(_data["specialRateCategory"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirection"] = this.specialRateOrFeeDirection ? this.specialRateOrFeeDirection.toJSON() : <any>undefined;
        data["specialRateReportingUnit"] = this.specialRateReportingUnit ? this.specialRateReportingUnit.toJSON() : <any>undefined;
        data["specialRateSpecifiedAs"] = this.specialRateSpecifiedAs ? this.specialRateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["proDataToProDataRate"] = this.proDataToProDataRate;
        data["proDataToProDataRateCurrency"] = this.proDataToProDataRateCurrency ? this.proDataToProDataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["specialRateCategory"] = this.specialRateCategory ? this.specialRateCategory.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    specialRateCategory?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class CommissionDto implements ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    clientId?: number | undefined;

    constructor(data?: ICommissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.tenantId = _data["tenantId"];
            this.consultantId = _data["consultantId"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): CommissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["tenantId"] = this.tenantId;
        data["consultantId"] = this.consultantId;
        data["clientId"] = this.clientId;
        return data;
    }
}

export interface ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    clientId?: number | undefined;
}

export class ConsultantContractsDataDto implements IConsultantContractsDataDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;

    constructor(data?: IConsultantContractsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.consultantTimeReportingCapCurrencyId = _data["consultantTimeReportingCapCurrencyId"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsultantContractsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["consultantTimeReportingCapCurrencyId"] = this.consultantTimeReportingCapCurrencyId;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConsultantContractsDataDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
}

export class ConsultantRateDto implements IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IConsultantRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataCurrencyId = _data["prodataToProdataCurrencyId"];
            this.prodataToProdataInvoiceCurrencyId = _data["prodataToProdataInvoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ConsultantRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataCurrencyId"] = this.prodataToProdataCurrencyId;
        data["prodataToProdataInvoiceCurrencyId"] = this.prodataToProdataInvoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ConsultantSalesDataDto implements IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    nameOnly?: string | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;

    constructor(data?: IConsultantSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.nameOnly = _data["nameOnly"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isOnsiteWorkplace = _data["isOnsiteWorkplace"];
            this.onsiteClientId = _data["onsiteClientId"];
            this.isEmagineOfficeWorkplace = _data["isEmagineOfficeWorkplace"];
            this.emagineOfficeId = _data["emagineOfficeId"];
            this.isRemoteWorkplace = _data["isRemoteWorkplace"];
            this.remoteAddressCountryId = _data["remoteAddressCountryId"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.noExpectedWorkload = _data["noExpectedWorkload"];
            this.expectedWorkloadHours = _data["expectedWorkloadHours"];
            this.expectedWorkloadUnitId = _data["expectedWorkloadUnitId"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.deliveryManagerSameAsAccountManager = _data["deliveryManagerSameAsAccountManager"];
            this.deliveryAccountManagerIdValue = _data["deliveryAccountManagerIdValue"];
        }
    }

    static fromJS(data: any): ConsultantSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["nameOnly"] = this.nameOnly;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isOnsiteWorkplace"] = this.isOnsiteWorkplace;
        data["onsiteClientId"] = this.onsiteClientId;
        data["isEmagineOfficeWorkplace"] = this.isEmagineOfficeWorkplace;
        data["emagineOfficeId"] = this.emagineOfficeId;
        data["isRemoteWorkplace"] = this.isRemoteWorkplace;
        data["remoteAddressCountryId"] = this.remoteAddressCountryId;
        data["percentageOnSite"] = this.percentageOnSite;
        data["noExpectedWorkload"] = this.noExpectedWorkload;
        data["expectedWorkloadHours"] = this.expectedWorkloadHours;
        data["expectedWorkloadUnitId"] = this.expectedWorkloadUnitId;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["deliveryManagerSameAsAccountManager"] = this.deliveryManagerSameAsAccountManager;
        data["deliveryAccountManagerIdValue"] = this.deliveryAccountManagerIdValue;
        return data;
    }
}

export interface IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    nameOnly?: string | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
}

export class ContactDto implements IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.owner = _data["owner"] ? EmployeeDto.fromJS(_data["owner"]) : <any>undefined;
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.lastCamLogin = _data["lastCamLogin"] ? moment(_data["lastCamLogin"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["lastCamLogin"] = this.lastCamLogin ? this.lastCamLogin.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
}

export class ContractsClientDataDto implements IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;

    constructor(data?: IContractsClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.clientTimeReportingCapCurrencyId = _data["clientTimeReportingCapCurrencyId"];
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractsClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["clientTimeReportingCapCurrencyId"] = this.clientTimeReportingCapCurrencyId;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
}

export class ContractSignerDto implements IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    signerRole?: SignerRole;

    constructor(data?: IContractSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signOrder = _data["signOrder"];
            this.contactId = _data["contactId"];
            this.signerRole = _data["signerRole"] ? SignerRole.fromJS(_data["signerRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signOrder"] = this.signOrder;
        data["contactId"] = this.contactId;
        data["signerRole"] = this.signerRole ? this.signerRole.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    signerRole?: SignerRole;
}

export class ContractsMainDataDto implements IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;

    constructor(data?: IContractsMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): ContractsMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;
}

export class DomainEventBase implements IDomainEventBase {
    readonly id?: string;
    readonly dateOccurred?: moment.Moment;

    constructor(data?: IDomainEventBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).dateOccurred = _data["dateOccurred"] ? moment(_data["dateOccurred"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainEventBase {
        data = typeof data === 'object' ? data : {};
        let result = new DomainEventBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateOccurred"] = this.dateOccurred ? this.dateOccurred.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDomainEventBase {
    id?: string;
    dateOccurred?: moment.Moment;
}

export class EmployeeDto implements IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class EnumEntityTypeDto implements IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IEnumEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;
}

export class IdNameDto implements IIdNameDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdNameDto {
    id?: number;
    name?: string | undefined;
}

export class NewWorkflowCreatedDto implements INewWorkflowCreatedDto {
    workflowId?: string;

    constructor(data?: INewWorkflowCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): NewWorkflowCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewWorkflowCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        return data;
    }
}

export interface INewWorkflowCreatedDto {
    workflowId?: string;
}

export class PeriodClientSpecialFeeDto implements IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.feeDirection = _data["feeDirection"] ? EnumEntityTypeDto.fromJS(_data["feeDirection"]) : <any>undefined;
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["feeDirection"] = this.feeDirection ? this.feeDirection.toJSON() : <any>undefined;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodClientSpecialRateDto implements IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.rateDirection = _data["rateDirection"] ? EnumEntityTypeDto.fromJS(_data["rateDirection"]) : <any>undefined;
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["rateDirection"] = this.rateDirection ? this.rateDirection.toJSON() : <any>undefined;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialFeeDto implements IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.feeDirection = _data["feeDirection"] ? EnumEntityTypeDto.fromJS(_data["feeDirection"]) : <any>undefined;
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["feeDirection"] = this.feeDirection ? this.feeDirection.toJSON() : <any>undefined;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialRateDto implements IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.rateDirection = _data["rateDirection"] ? EnumEntityTypeDto.fromJS(_data["rateDirection"]) : <any>undefined;
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["rateDirection"] = this.rateDirection ? this.rateDirection.toJSON() : <any>undefined;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class PeriodStepDto implements IPeriodStepDto {
    name?: string | undefined;
    typeId?: number;
    isCompleted?: boolean | undefined;
    responsiblePerson?: EmployeeDto;

    constructor(data?: IPeriodStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.isCompleted = _data["isCompleted"];
            this.responsiblePerson = _data["responsiblePerson"] ? EmployeeDto.fromJS(_data["responsiblePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PeriodStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["isCompleted"] = this.isCompleted;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPeriodStepDto {
    name?: string | undefined;
    typeId?: number;
    isCompleted?: boolean | undefined;
    responsiblePerson?: EmployeeDto;
}

export class ProjectLineDto implements IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
    invoicingReferenceNumber?: string | undefined;
    invoicingReferencePersonId?: number | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    modifiedById?: number | undefined;
    modificationDate?: moment.Moment | undefined;

    constructor(data?: IProjectLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.invoicingReferencePersonId = _data["invoicingReferencePersonId"];
            this.optionalInvoicingInfo = _data["optionalInvoicingInfo"];
            this.differentDebtorNumber = _data["differentDebtorNumber"];
            this.debtorNumber = _data["debtorNumber"];
            this.differentInvoiceRecipient = _data["differentInvoiceRecipient"];
            this.invoiceRecipientId = _data["invoiceRecipientId"];
            this.modifiedById = _data["modifiedById"];
            this.modificationDate = _data["modificationDate"] ? moment(_data["modificationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["invoicingReferencePersonId"] = this.invoicingReferencePersonId;
        data["optionalInvoicingInfo"] = this.optionalInvoicingInfo;
        data["differentDebtorNumber"] = this.differentDebtorNumber;
        data["debtorNumber"] = this.debtorNumber;
        data["differentInvoiceRecipient"] = this.differentInvoiceRecipient;
        data["invoiceRecipientId"] = this.invoiceRecipientId;
        data["modifiedById"] = this.modifiedById;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
    invoicingReferenceNumber?: string | undefined;
    invoicingReferencePersonId?: number | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    modifiedById?: number | undefined;
    modificationDate?: moment.Moment | undefined;
}

export enum RequestProjectTypeValue {
    NormalHighMargin = 1,
    NormalLowMargin = 2,
    NearShoreHighMargin = 3,
    NearShoreLowMargin = 4,
    VMSReferredHighMargin = 5,
    VMSReferredLowMargin = 6,
    NearShoreVMSReferredHighMargin = 7,
    NearShoreVMSReferredLowMargin = 8,
    OtherHighMargin = 9,
    OtherLowMargin = 10,
}

export class RequestProjectTypeValueValueNameDto implements IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;

    constructor(data?: IRequestProjectTypeValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestProjectTypeValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestProjectTypeValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;
}

export enum RequestStatusValue {
    Open = 1,
    Sold = 2,
    Stop = 3,
    Closed = 4,
    Potential = 7,
    AdRunning = 8,
    TenderSent = 9,
    Cancelled = 10,
}

export class RequestStatusValueValueNameDto implements IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;

    constructor(data?: IRequestStatusValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestStatusValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;
}

export class SalesClientDataDto implements ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    endClientIdValue?: number | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;

    constructor(data?: ISalesClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.differentEndClient = _data["differentEndClient"];
            this.directClientIdValue = _data["directClientIdValue"];
            this.endClientIdValue = _data["endClientIdValue"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionDurationId = _data["clientExtensionDurationId"];
            this.clientExtensionDeadlineId = _data["clientExtensionDeadlineId"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noInvoicingReferenceNumber = _data["noInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipientIdValue = _data["clientInvoicingRecipientIdValue"];
            this.noInvoicingReferencePerson = _data["noInvoicingReferencePerson"];
            this.invoicingReferencePersonIdValue = _data["invoicingReferencePersonIdValue"];
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.evaluationsReferencePersonIdValue = _data["evaluationsReferencePersonIdValue"];
            this.evaluationsDisabled = _data["evaluationsDisabled"];
            this.evaluationsDisabledReason = _data["evaluationsDisabledReason"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["differentEndClient"] = this.differentEndClient;
        data["directClientIdValue"] = this.directClientIdValue;
        data["endClientIdValue"] = this.endClientIdValue;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionDurationId"] = this.clientExtensionDurationId;
        data["clientExtensionDeadlineId"] = this.clientExtensionDeadlineId;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noInvoicingReferenceNumber"] = this.noInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipientIdValue"] = this.clientInvoicingRecipientIdValue;
        data["noInvoicingReferencePerson"] = this.noInvoicingReferencePerson;
        data["invoicingReferencePersonIdValue"] = this.invoicingReferencePersonIdValue;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["evaluationsReferencePersonIdValue"] = this.evaluationsReferencePersonIdValue;
        data["evaluationsDisabled"] = this.evaluationsDisabled;
        data["evaluationsDisabledReason"] = this.evaluationsDisabledReason;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    endClientIdValue?: number | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
}

export class SalesMainDataDto implements ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    commissionAccountManagerIdValue?: number | undefined;
    contractExpirationNotificationIntervalIds?: number[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;

    constructor(data?: ISalesMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectCategoryId = _data["projectCategoryId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            if (Array.isArray(_data["commissions"])) {
                this.commissions = [] as any;
                for (let item of _data["commissions"])
                    this.commissions!.push(CommissionDto.fromJS(item));
            }
            this.salesAccountManagerIdValue = _data["salesAccountManagerIdValue"];
            this.commissionAccountManagerIdValue = _data["commissionAccountManagerIdValue"];
            if (Array.isArray(_data["contractExpirationNotificationIntervalIds"])) {
                this.contractExpirationNotificationIntervalIds = [] as any;
                for (let item of _data["contractExpirationNotificationIntervalIds"])
                    this.contractExpirationNotificationIntervalIds!.push(item);
            }
            this.customContractExpirationNotificationDate = _data["customContractExpirationNotificationDate"] ? moment(_data["customContractExpirationNotificationDate"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): SalesMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectCategoryId"] = this.projectCategoryId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        if (Array.isArray(this.commissions)) {
            data["commissions"] = [];
            for (let item of this.commissions)
                data["commissions"].push(item.toJSON());
        }
        data["salesAccountManagerIdValue"] = this.salesAccountManagerIdValue;
        data["commissionAccountManagerIdValue"] = this.commissionAccountManagerIdValue;
        if (Array.isArray(this.contractExpirationNotificationIntervalIds)) {
            data["contractExpirationNotificationIntervalIds"] = [];
            for (let item of this.contractExpirationNotificationIntervalIds)
                data["contractExpirationNotificationIntervalIds"].push(item);
        }
        data["customContractExpirationNotificationDate"] = this.customContractExpirationNotificationDate ? this.customContractExpirationNotificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    commissionAccountManagerIdValue?: number | undefined;
    contractExpirationNotificationIntervalIds?: number[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;
}

export class SignerRole implements ISignerRole {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISignerRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SignerRole {
        data = typeof data === 'object' ? data : {};
        let result = new SignerRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISignerRole {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class SimplePublicObject implements ISimplePublicObject {
    id!: string;
    properties!: { [key: string]: string; };
    createdAt!: moment.Moment;
    updatedAt!: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISimplePublicObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.archivedAt = _data["archivedAt"] ? moment(_data["archivedAt"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimplePublicObject {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePublicObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["archivedAt"] = this.archivedAt ? this.archivedAt.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISimplePublicObject {
    id: string;
    properties: { [key: string]: string; };
    createdAt: moment.Moment;
    updatedAt: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SimpleRequestLocationDto implements ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;

    constructor(data?: ISimpleRequestLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"] ? IdNameDto.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"] ? IdNameDto.fromJS(_data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimpleRequestLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleRequestLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;
}

export class SpecialRateReportingUnit implements ISpecialRateReportingUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateReportingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateReportingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateReportingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateReportingUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class SpecialRateSpecifiedAs implements ISpecialRateSpecifiedAs {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateSpecifiedAs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateSpecifiedAs {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateSpecifiedAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateSpecifiedAs {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class StartNewWorkflowInputDto implements IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;

    constructor(data?: IStartNewWorkflowInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
        }
    }

    static fromJS(data: any): StartNewWorkflowInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StartNewWorkflowInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["requestId"] = this.requestId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        return data;
    }
}

export interface IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;
}

export class UpdateClientSpecialFeeDto implements IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class UpdateClientSpecialRateDto implements IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.specialRateCategoryId = _data["specialRateCategoryId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["specialRateCategoryId"] = this.specialRateCategoryId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class WorkflowAlreadyExistsDto implements IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;

    constructor(data?: IWorkflowAlreadyExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.existingWorkflowId = _data["existingWorkflowId"];
        }
    }

    static fromJS(data: any): WorkflowAlreadyExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAlreadyExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingWorkflowId"] = this.existingWorkflowId;
        return data;
    }
}

export interface IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;
}

export class WorkflowDto implements IWorkflowDto {
    workflowId?: string;
    clientPeriods?: ClientPeriodDto[] | undefined;

    constructor(data?: IWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(ClientPeriodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowDto {
    workflowId?: string;
    clientPeriods?: ClientPeriodDto[] | undefined;
}

export class WorkflowProcessDto implements IWorkflowProcessDto {
    name?: string | undefined;
    typeId?: WorkflowProcessType;
    additionalInfo?: string | undefined;
    periodSteps?: PeriodStepDto[] | undefined;

    constructor(data?: IWorkflowProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.additionalInfo = _data["additionalInfo"];
            if (Array.isArray(_data["periodSteps"])) {
                this.periodSteps = [] as any;
                for (let item of _data["periodSteps"])
                    this.periodSteps!.push(PeriodStepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["additionalInfo"] = this.additionalInfo;
        if (Array.isArray(this.periodSteps)) {
            data["periodSteps"] = [];
            for (let item of this.periodSteps)
                data["periodSteps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowProcessDto {
    name?: string | undefined;
    typeId?: WorkflowProcessType;
    additionalInfo?: string | undefined;
    periodSteps?: PeriodStepDto[] | undefined;
}

export enum WorkflowProcessType {
    StartClientPeriod = 1,
    ChangeClientPeriod = 2,
    ExtendClientPeriod = 3,
    StartConsultantPeriod = 4,
    ChangeConsultantPeriod = 5,
    ExtendConsultantPeriod = 6,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}