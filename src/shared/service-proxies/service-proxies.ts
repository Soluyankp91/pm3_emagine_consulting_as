//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param redirectUri (optional) 
     * @return Success
     */
    signIn(scheme: string, redirectUri?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignIn/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param redirectUri (optional) 
     * @param scope (optional) 
     * @param loginHint (optional) 
     * @param domainHint (optional) 
     * @param claims (optional) 
     * @param policy (optional) 
     * @return Success
     */
    challenge(scheme: string, redirectUri?: string | undefined, scope?: string | undefined, loginHint?: string | undefined, domainHint?: string | undefined, claims?: string | undefined, policy?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/Challenge/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (loginHint === null)
            throw new Error("The parameter 'loginHint' cannot be null.");
        else if (loginHint !== undefined)
            url_ += "loginHint=" + encodeURIComponent("" + loginHint) + "&";
        if (domainHint === null)
            throw new Error("The parameter 'domainHint' cannot be null.");
        else if (domainHint !== undefined)
            url_ += "domainHint=" + encodeURIComponent("" + domainHint) + "&";
        if (claims === null)
            throw new Error("The parameter 'claims' cannot be null.");
        else if (claims !== undefined)
            url_ += "claims=" + encodeURIComponent("" + claims) + "&";
        if (policy === null)
            throw new Error("The parameter 'policy' cannot be null.");
        else if (policy !== undefined)
            url_ += "policy=" + encodeURIComponent("" + policy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallenge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallenge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChallenge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    signOut(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignOut/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    resetPassword(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/ResetPassword/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editProfile(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/EditProfile/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    dropAndCreateIndex(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/workflow/drop-and-create-index";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropAndCreateIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropAndCreateIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDropAndCreateIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param customBatchSize (optional) 
     * @return Success
     */
    fillIndexWithData(customBatchSize?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/workflow/fill-index-with-data?";
        if (customBatchSize === null)
            throw new Error("The parameter 'customBatchSize' cannot be null.");
        else if (customBatchSize !== undefined)
            url_ += "customBatchSize=" + encodeURIComponent("" + customBatchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillIndexWithData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillIndexWithData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFillIndexWithData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @return Success
     */
    fillSingleWorkflowIndexWithData(workflowId?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/workflow/fill-single-workflow-index-with-data?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "workflowId=" + encodeURIComponent("" + workflowId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillSingleWorkflowIndexWithData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillSingleWorkflowIndexWithData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFillSingleWorkflowIndexWithData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param testsCount (optional) 
     * @return Success
     */
    testOfFetchingDataFromAzureSearchIndex(maxResultCount?: number | undefined, testsCount?: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Admin/search-service/workflow/test-of-fetching-data-from-AzureSearchIndex?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (testsCount === null)
            throw new Error("The parameter 'testsCount' cannot be null.");
        else if (testsCount !== undefined)
            url_ += "testsCount=" + encodeURIComponent("" + testsCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestOfFetchingDataFromAzureSearchIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestOfFetchingDataFromAzureSearchIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processTestOfFetchingDataFromAzureSearchIndex(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param customBatchSize (optional) 
     * @return Success
     */
    setWorkflowsStatusesOnContractExpirationPeriod(customBatchSize?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/workflow-status-service/set-workflows-statuses-on-contract-expiration-period?";
        if (customBatchSize === null)
            throw new Error("The parameter 'customBatchSize' cannot be null.");
        else if (customBatchSize !== undefined)
            url_ += "customBatchSize=" + encodeURIComponent("" + customBatchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWorkflowsStatusesOnContractExpirationPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWorkflowsStatusesOnContractExpirationPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetWorkflowsStatusesOnContractExpirationPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    dropAndCreateIndex2(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/agreement/drop-and-create-index";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropAndCreateIndex2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropAndCreateIndex2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDropAndCreateIndex2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    fillIndexWithData2(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/agreement/fill-index-with-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillIndexWithData2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillIndexWithData2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFillIndexWithData2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param agreementId (optional) 
     * @return Success
     */
    indexSingle(agreementId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/search-service/agreement/index-single?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "agreementId=" + encodeURIComponent("" + agreementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndexSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndexSingle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processIndexSingle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    values(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Admin/config/values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processValues(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    clientsFullHubspotToPm3Sync(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Admin/clients-full-hubspot-to-pm3-sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsFullHubspotToPm3Sync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsFullHubspotToPm3Sync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processClientsFullHubspotToPm3Sync(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocusignEnvelopeStatus(body?: UpdateDocuSignEnvelopeStatusCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/update-docusign-envelope-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocusignEnvelopeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocusignEnvelopeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDocusignEnvelopeStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clearUsersCache(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/clear-users-cache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUsersCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUsersCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearUsersCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    synchronizeUserManagementData(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/synchronize-user-management-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronizeUserManagementData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronizeUserManagementData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSynchronizeUserManagementData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param batchSize (optional) 
     * @return Success
     */
    fillMissingClientPeriodsSeqNumbers(batchSize?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/temp/fill-missing-client-periods-seq-numbers?";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillMissingClientPeriodsSeqNumbers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillMissingClientPeriodsSeqNumbers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFillMissingClientPeriodsSeqNumbers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param batchSize (optional) 
     * @return Success
     */
    migrateInvoicingReferenceNumbersToPOs(batchSize?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/temp/migrate-InvoicingReferenceNumbers-to-POs?";
        if (batchSize === null)
            throw new Error("The parameter 'batchSize' cannot be null.");
        else if (batchSize !== undefined)
            url_ += "batchSize=" + encodeURIComponent("" + batchSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMigrateInvoicingReferenceNumbersToPOs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMigrateInvoicingReferenceNumbersToPOs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMigrateInvoicingReferenceNumbersToPOs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    matchupEmployeesToCrmOwners(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/MatchupEmployeesToCrmOwners";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatchupEmployeesToCrmOwners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatchupEmployeesToCrmOwners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMatchupEmployeesToCrmOwners(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientsSyncParentsFromHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/ClientsSyncParentsFromHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsSyncParentsFromHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsSyncParentsFromHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientsSyncParentsFromHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param limitToMaxEvents (optional) 
     * @return Success
     */
    triggerMissingClientDomainEvents(limitToMaxEvents?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/TriggerMissingClientDomainEvents?";
        if (limitToMaxEvents === null)
            throw new Error("The parameter 'limitToMaxEvents' cannot be null.");
        else if (limitToMaxEvents !== undefined)
            url_ += "limitToMaxEvents=" + encodeURIComponent("" + limitToMaxEvents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerMissingClientDomainEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerMissingClientDomainEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerMissingClientDomainEvents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param limitToMaxEvents (optional) 
     * @return Success
     */
    triggerMissingContactDomainEvents(limitToMaxEvents?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/TriggerMissingContactDomainEvents?";
        if (limitToMaxEvents === null)
            throw new Error("The parameter 'limitToMaxEvents' cannot be null.");
        else if (limitToMaxEvents !== undefined)
            url_ += "limitToMaxEvents=" + encodeURIComponent("" + limitToMaxEvents) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerMissingContactDomainEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerMissingContactDomainEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerMissingContactDomainEvents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    updateAllContactAddressesInHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/UpdateAllContactAddressesInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllContactAddressesInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllContactAddressesInHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllContactAddressesInHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    sendFinanceDataToLegacyPm(): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/SendFinanceDataToLegacyPm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendFinanceDataToLegacyPm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendFinanceDataToLegacyPm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendFinanceDataToLegacyPm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    retrieveFinanceDataFromLegacyPm(tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/migration-sync/RetrieveFinanceDataFromLegacyPm?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveFinanceDataFromLegacyPm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveFinanceDataFromLegacyPm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRetrieveFinanceDataFromLegacyPm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    updateClientsVatNumber(fillEmptyOnly: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/temp/update-clients-vat-number/{fillEmptyOnly}";
        if (fillEmptyOnly === undefined || fillEmptyOnly === null)
            throw new Error("The parameter 'fillEmptyOnly' must be defined.");
        url_ = url_.replace("{fillEmptyOnly}", encodeURIComponent("" + fillEmptyOnly));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClientsVatNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClientsVatNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateClientsVatNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param dryRun (optional) 
     * @return Success
     */
    remove(dryRun?: boolean | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Admin/temp/orphans/remove?";
        if (dryRun === null)
            throw new Error("The parameter 'dryRun' cannot be null.");
        else if (dryRun !== undefined)
            url_ += "dryRun=" + encodeURIComponent("" + dryRun) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }
}

@Injectable()
export class AgreementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param agreementId (optional) 
     * @param agreementName (optional) 
     * @param languages (optional) 
     * @param clientName (optional) 
     * @param consultantName (optional) 
     * @param companyName (optional) 
     * @param actualRecipientName (optional) 
     * @param legalEntities (optional) 
     * @param tenantIds (optional) 
     * @param agreementTypes (optional) 
     * @param recipientTypes (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param contractTypes (optional) 
     * @param validities (optional) 
     * @param statuses (optional) 
     * @param salesManagers (optional) 
     * @param contractManagers (optional) 
     * @param search (optional) 
     * @param isWorkflowRelated (optional) 
     * @param envelopeProcessingPaths (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    list(agreementId?: number | undefined, agreementName?: string | undefined, languages?: number[] | undefined, clientName?: string | undefined, consultantName?: string | undefined, companyName?: string | undefined, actualRecipientName?: string | undefined, legalEntities?: number[] | undefined, tenantIds?: number[] | undefined, agreementTypes?: number[] | undefined, recipientTypes?: number[] | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, contractTypes?: number[] | undefined, validities?: number[] | undefined, statuses?: number[] | undefined, salesManagers?: number[] | undefined, contractManagers?: number[] | undefined, search?: string | undefined, isWorkflowRelated?: boolean | undefined, envelopeProcessingPaths?: number[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Agreement/list?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (agreementName === null)
            throw new Error("The parameter 'agreementName' cannot be null.");
        else if (agreementName !== undefined)
            url_ += "AgreementName=" + encodeURIComponent("" + agreementName) + "&";
        if (languages === null)
            throw new Error("The parameter 'languages' cannot be null.");
        else if (languages !== undefined)
            languages && languages.forEach(item => { url_ += "Languages=" + encodeURIComponent("" + item) + "&"; });
        if (clientName === null)
            throw new Error("The parameter 'clientName' cannot be null.");
        else if (clientName !== undefined)
            url_ += "ClientName=" + encodeURIComponent("" + clientName) + "&";
        if (consultantName === null)
            throw new Error("The parameter 'consultantName' cannot be null.");
        else if (consultantName !== undefined)
            url_ += "ConsultantName=" + encodeURIComponent("" + consultantName) + "&";
        if (companyName === null)
            throw new Error("The parameter 'companyName' cannot be null.");
        else if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (actualRecipientName === null)
            throw new Error("The parameter 'actualRecipientName' cannot be null.");
        else if (actualRecipientName !== undefined)
            url_ += "ActualRecipientName=" + encodeURIComponent("" + actualRecipientName) + "&";
        if (legalEntities === null)
            throw new Error("The parameter 'legalEntities' cannot be null.");
        else if (legalEntities !== undefined)
            legalEntities && legalEntities.forEach(item => { url_ += "LegalEntities=" + encodeURIComponent("" + item) + "&"; });
        if (tenantIds === null)
            throw new Error("The parameter 'tenantIds' cannot be null.");
        else if (tenantIds !== undefined)
            tenantIds && tenantIds.forEach(item => { url_ += "TenantIds=" + encodeURIComponent("" + item) + "&"; });
        if (agreementTypes === null)
            throw new Error("The parameter 'agreementTypes' cannot be null.");
        else if (agreementTypes !== undefined)
            agreementTypes && agreementTypes.forEach(item => { url_ += "AgreementTypes=" + encodeURIComponent("" + item) + "&"; });
        if (recipientTypes === null)
            throw new Error("The parameter 'recipientTypes' cannot be null.");
        else if (recipientTypes !== undefined)
            recipientTypes && recipientTypes.forEach(item => { url_ += "RecipientTypes=" + encodeURIComponent("" + item) + "&"; });
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (contractTypes === null)
            throw new Error("The parameter 'contractTypes' cannot be null.");
        else if (contractTypes !== undefined)
            contractTypes && contractTypes.forEach(item => { url_ += "ContractTypes=" + encodeURIComponent("" + item) + "&"; });
        if (validities === null)
            throw new Error("The parameter 'validities' cannot be null.");
        else if (validities !== undefined)
            validities && validities.forEach(item => { url_ += "Validities=" + encodeURIComponent("" + item) + "&"; });
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (salesManagers === null)
            throw new Error("The parameter 'salesManagers' cannot be null.");
        else if (salesManagers !== undefined)
            salesManagers && salesManagers.forEach(item => { url_ += "SalesManagers=" + encodeURIComponent("" + item) + "&"; });
        if (contractManagers === null)
            throw new Error("The parameter 'contractManagers' cannot be null.");
        else if (contractManagers !== undefined)
            contractManagers && contractManagers.forEach(item => { url_ += "ContractManagers=" + encodeURIComponent("" + item) + "&"; });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (isWorkflowRelated === null)
            throw new Error("The parameter 'isWorkflowRelated' cannot be null.");
        else if (isWorkflowRelated !== undefined)
            url_ += "IsWorkflowRelated=" + encodeURIComponent("" + isWorkflowRelated) + "&";
        if (envelopeProcessingPaths === null)
            throw new Error("The parameter 'envelopeProcessingPaths' cannot be null.");
        else if (envelopeProcessingPaths !== undefined)
            envelopeProcessingPaths && envelopeProcessingPaths.forEach(item => { url_ += "EnvelopeProcessingPaths=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementListItemDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<AgreementListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param agreementId (optional) 
     * @param search (optional) 
     * @param clientId (optional) 
     * @param agreementType (optional) 
     * @param validity (optional) 
     * @param legalEntityId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param deliveryTypeId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    simpleList(agreementId?: number | undefined, search?: string | undefined, clientId?: number | undefined, agreementType?: AgreementType | undefined, validity?: AgreementValidityState[] | undefined, legalEntityId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, deliveryTypeId?: number | undefined, startDate?: moment.Moment | undefined, endDate?: moment.Moment | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementSimpleListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Agreement/simple-list?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (agreementType === null)
            throw new Error("The parameter 'agreementType' cannot be null.");
        else if (agreementType !== undefined)
            url_ += "AgreementType=" + encodeURIComponent("" + agreementType) + "&";
        if (validity === null)
            throw new Error("The parameter 'validity' cannot be null.");
        else if (validity !== undefined)
            validity && validity.forEach(item => { url_ += "Validity=" + encodeURIComponent("" + item) + "&"; });
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            url_ += "LegalEntityId=" + encodeURIComponent("" + legalEntityId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimpleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimpleList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
        }));
    }

    protected processSimpleList(response: HttpResponseBase): Observable<AgreementSimpleListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementSimpleListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementSimpleListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementPOST(body?: SaveAgreementDto | undefined): Observable<SaveAgreementCommandResult> {
        let url_ = this.baseUrl + "/api/Agreement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaveAgreementCommandResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaveAgreementCommandResult>;
        }));
    }

    protected processAgreementPOST(response: HttpResponseBase): Observable<SaveAgreementCommandResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveAgreementCommandResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SaveAgreementCommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementPATCH(agreementId: number, body?: SaveAgreementDto | undefined): Observable<SaveAgreementCommandResult> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementPATCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementPATCH(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaveAgreementCommandResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaveAgreementCommandResult>;
        }));
    }

    protected processAgreementPATCH(response: HttpResponseBase): Observable<SaveAgreementCommandResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveAgreementCommandResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SaveAgreementCommandResult>(null as any);
    }

    /**
     * @return Success
     */
    agreementGET(agreementId: number): Observable<AgreementDetailsDto> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementDetailsDto>;
        }));
    }

    protected processAgreementGET(response: HttpResponseBase): Observable<AgreementDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    agreementDELETE(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    auxiliaryPATCH(agreementId: number, body?: SaveAgreementAuxiliaryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/auxiliary";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuxiliaryPATCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuxiliaryPATCH(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuxiliaryPATCH(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    auxiliaryGET(agreementId: number): Observable<AgreementAuxiliaryDetailsDto> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/auxiliary";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuxiliaryGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuxiliaryGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementAuxiliaryDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementAuxiliaryDetailsDto>;
        }));
    }

    protected processAuxiliaryGET(response: HttpResponseBase): Observable<AgreementAuxiliaryDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementAuxiliaryDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementAuxiliaryDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    preview(agreementId: number): Observable<AgreementDetailsPreviewDto> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/preview";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementDetailsPreviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementDetailsPreviewDto>;
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<AgreementDetailsPreviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementDetailsPreviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementDetailsPreviewDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    documentFilePUT(agreementId: number, forceUpdate: boolean, body?: StringWrappedValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/{forceUpdate}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (forceUpdate === undefined || forceUpdate === null)
            throw new Error("The parameter 'forceUpdate' must be defined.");
        url_ = url_.replace("{forceUpdate}", encodeURIComponent("" + forceUpdate));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentFilePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentFilePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDocumentFilePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeAgreement(agreementId: number, forceUpdate: boolean, body?: CompleteAgreementDocumentFileDraftDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/complete-agreement/{forceUpdate}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (forceUpdate === undefined || forceUpdate === null)
            throw new Error("The parameter 'forceUpdate' must be defined.");
        url_ = url_.replace("{forceUpdate}", encodeURIComponent("" + forceUpdate));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteAgreement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompleteAgreement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    latestAgreementVersion(agreementId: number, getDraftIfAvailable: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/latest-agreement-version/{getDraftIfAvailable}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (getDraftIfAvailable === undefined || getDraftIfAvailable === null)
            throw new Error("The parameter 'getDraftIfAvailable' must be defined.");
        url_ = url_.replace("{getDraftIfAvailable}", encodeURIComponent("" + getDraftIfAvailable));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLatestAgreementVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLatestAgreementVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLatestAgreementVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    documentFileGET(agreementId: number, documentFileVersion: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/{documentFileVersion}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (documentFileVersion === undefined || documentFileVersion === null)
            throw new Error("The parameter 'documentFileVersion' must be defined.");
        url_ = url_.replace("{documentFileVersion}", encodeURIComponent("" + documentFileVersion));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentFileGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentFileGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDocumentFileGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    pdf(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/pdf";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    agreementVersions(agreementId: number): Observable<AgreementDocumentFileVersionDto[]> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/document-file/agreement-versions";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementVersions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementDocumentFileVersionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementDocumentFileVersionDto[]>;
        }));
    }

    protected processAgreementVersions(response: HttpResponseBase): Observable<AgreementDocumentFileVersionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementDocumentFileVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementDocumentFileVersionDto[]>(null as any);
    }

    /**
     * @param agreementIds (optional) 
     * @return Success
     */
    singleEnvelopeCheck(agreementIds?: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/single-envelope-check?";
        if (agreementIds === null)
            throw new Error("The parameter 'agreementIds' cannot be null.");
        else if (agreementIds !== undefined)
            agreementIds && agreementIds.forEach(item => { url_ += "agreementIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSingleEnvelopeCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSingleEnvelopeCheck(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSingleEnvelopeCheck(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param agreementIds (optional) 
     * @param singleEnvelope (optional) 
     * @return Success
     */
    envelopeRecipientsPreview(agreementIds?: number[] | undefined, singleEnvelope?: boolean | undefined): Observable<EnvelopePreviewDto[]> {
        let url_ = this.baseUrl + "/api/Agreement/envelope-recipients-preview?";
        if (agreementIds === null)
            throw new Error("The parameter 'agreementIds' cannot be null.");
        else if (agreementIds !== undefined)
            agreementIds && agreementIds.forEach(item => { url_ += "agreementIds=" + encodeURIComponent("" + item) + "&"; });
        if (singleEnvelope === null)
            throw new Error("The parameter 'singleEnvelope' cannot be null.");
        else if (singleEnvelope !== undefined)
            url_ += "singleEnvelope=" + encodeURIComponent("" + singleEnvelope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnvelopeRecipientsPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnvelopeRecipientsPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnvelopePreviewDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnvelopePreviewDto[]>;
        }));
    }

    protected processEnvelopeRecipientsPreview(response: HttpResponseBase): Observable<EnvelopePreviewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvelopePreviewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnvelopePreviewDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    docusignEnvelopeEmailTemplates(search?: string | undefined, skip?: number | undefined, take?: number | undefined): Observable<TemplateListItem[]> {
        let url_ = this.baseUrl + "/api/Agreement/docusign-envelope-email-templates?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocusignEnvelopeEmailTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocusignEnvelopeEmailTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateListItem[]>;
        }));
    }

    protected processDocusignEnvelopeEmailTemplates(response: HttpResponseBase): Observable<TemplateListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateListItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateListItem[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendDocusignEnvelope(body?: SendDocuSignEnvelopeCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/send-docusign-envelope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendDocusignEnvelope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendDocusignEnvelope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendDocusignEnvelope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailEnvelope(body?: SendEmailEnvelopeCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/send-email-envelope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailEnvelope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailEnvelope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailEnvelope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    envelopeRelatedAgreements(agreementId: number): Observable<EnvelopeRelatedAgreementDto[]> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/envelope-related-agreements";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnvelopeRelatedAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnvelopeRelatedAgreements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnvelopeRelatedAgreementDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnvelopeRelatedAgreementDto[]>;
        }));
    }

    protected processEnvelopeRelatedAgreements(response: HttpResponseBase): Observable<EnvelopeRelatedAgreementDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvelopeRelatedAgreementDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnvelopeRelatedAgreementDto[]>(null as any);
    }

    /**
     * @param reason (optional) 
     * @return Success
     */
    voidEnvelope(agreementId: number, reason?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/void-envelope?";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (reason === null)
            throw new Error("The parameter 'reason' cannot be null.");
        else if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoidEnvelope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoidEnvelope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVoidEnvelope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param agreementIds (optional) 
     * @return Success
     */
    resendDocusignEnvelope(agreementIds?: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/resend-docusign-envelope?";
        if (agreementIds === null)
            throw new Error("The parameter 'agreementIds' cannot be null.");
        else if (agreementIds !== undefined)
            agreementIds && agreementIds.forEach(item => { url_ += "agreementIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendDocusignEnvelope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendDocusignEnvelope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResendDocusignEnvelope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    signedDocument(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/signed-document";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignedDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignedDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignedDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param agreementIds (optional) 
     * @return Success
     */
    signedDocuments(agreementIds?: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/signed-documents?";
        if (agreementIds === null)
            throw new Error("The parameter 'agreementIds' cannot be null.");
        else if (agreementIds !== undefined)
            agreementIds && agreementIds.forEach(item => { url_ += "agreementIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignedDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignedDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignedDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param agreementIds (optional) 
     * @param includeAuxiliaryAttachments (optional) 
     * @return Success
     */
    files(agreementIds?: number[] | undefined, includeAuxiliaryAttachments?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/files?";
        if (agreementIds === null)
            throw new Error("The parameter 'agreementIds' cannot be null.");
        else if (agreementIds !== undefined)
            agreementIds && agreementIds.forEach(item => { url_ += "agreementIds=" + encodeURIComponent("" + item) + "&"; });
        if (includeAuxiliaryAttachments === null)
            throw new Error("The parameter 'includeAuxiliaryAttachments' cannot be null.");
        else if (includeAuxiliaryAttachments !== undefined)
            url_ += "includeAuxiliaryAttachments=" + encodeURIComponent("" + includeAuxiliaryAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    logs(agreementId: number, newestFirst: boolean): Observable<AgreementLogQueryResultDto> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/logs/{newestFirst}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (newestFirst === undefined || newestFirst === null)
            throw new Error("The parameter 'newestFirst' must be defined.");
        url_ = url_.replace("{newestFirst}", encodeURIComponent("" + newestFirst));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementLogQueryResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementLogQueryResultDto>;
        }));
    }

    protected processLogs(response: HttpResponseBase): Observable<AgreementLogQueryResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementLogQueryResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementLogQueryResultDto>(null as any);
    }

    /**
     * @return Success
     */
    envelopeEvents(agreementId: number, newestFirst: boolean): Observable<EnvelopeEventListItemDto[]> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/envelopeEvents/{newestFirst}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (newestFirst === undefined || newestFirst === null)
            throw new Error("The parameter 'newestFirst' must be defined.");
        url_ = url_.replace("{newestFirst}", encodeURIComponent("" + newestFirst));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnvelopeEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnvelopeEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnvelopeEventListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnvelopeEventListItemDto[]>;
        }));
    }

    protected processEnvelopeEvents(response: HttpResponseBase): Observable<EnvelopeEventListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvelopeEventListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnvelopeEventListItemDto[]>(null as any);
    }

    /**
     * @return Success
     */
    statusHistory(agreementId: number): Observable<AgreementStatusHistoryDto[]> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/status-history";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementStatusHistoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementStatusHistoryDto[]>;
        }));
    }

    protected processStatusHistory(response: HttpResponseBase): Observable<AgreementStatusHistoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementStatusHistoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementStatusHistoryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    openEdit(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/open-edit";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOpenEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    markCompleted(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/mark-completed";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkCompleted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkCompleted(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    notifyInEdit(agreementId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/notify-in-edit";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyInEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyInEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotifyInEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadSigned(agreementId: number, forceUpdate: boolean, file?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Agreement/{agreementId}/upload-signed/{forceUpdate}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (forceUpdate === undefined || forceUpdate === null)
            throw new Error("The parameter 'forceUpdate' must be defined.");
        url_ = url_.replace("{forceUpdate}", encodeURIComponent("" + forceUpdate));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSigned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSigned(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadSigned(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AgreementAttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    agreementAttachment(agreementAttachmentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementAttachment/{agreementAttachmentId}";
        if (agreementAttachmentId === undefined || agreementAttachmentId === null)
            throw new Error("The parameter 'agreementAttachmentId' must be defined.");
        url_ = url_.replace("{agreementAttachmentId}", encodeURIComponent("" + agreementAttachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    auxiliaryGET2(agreementAuxiliaryAttachmentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementAttachment/auxiliary/{agreementAuxiliaryAttachmentId}";
        if (agreementAuxiliaryAttachmentId === undefined || agreementAuxiliaryAttachmentId === null)
            throw new Error("The parameter 'agreementAuxiliaryAttachmentId' must be defined.");
        url_ = url_.replace("{agreementAuxiliaryAttachmentId}", encodeURIComponent("" + agreementAuxiliaryAttachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuxiliaryGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuxiliaryGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuxiliaryGET2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AgreementCommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    agreementCommentAll(agreementId: number): Observable<AgreementCommentDto[]> {
        let url_ = this.baseUrl + "/api/AgreementComment/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementCommentAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementCommentAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementCommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementCommentDto[]>;
        }));
    }

    protected processAgreementCommentAll(response: HttpResponseBase): Observable<AgreementCommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementCommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementCommentDto[]>(null as any);
    }

    /**
     * @param parentAgreementCommentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    agreementCommentPUT(agreementId: number, parentAgreementCommentId?: number | undefined, body?: CommentInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/AgreementComment/{agreementId}?";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        if (parentAgreementCommentId === null)
            throw new Error("The parameter 'parentAgreementCommentId' cannot be null.");
        else if (parentAgreementCommentId !== undefined)
            url_ += "parentAgreementCommentId=" + encodeURIComponent("" + parentAgreementCommentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementCommentPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementCommentPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAgreementCommentPUT(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementCommentPATCH(agreementCommentId: number, body?: CommentInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementComment/{agreementCommentId}";
        if (agreementCommentId === undefined || agreementCommentId === null)
            throw new Error("The parameter 'agreementCommentId' must be defined.");
        url_ = url_.replace("{agreementCommentId}", encodeURIComponent("" + agreementCommentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementCommentPATCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementCommentPATCH(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementCommentPATCH(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    agreementCommentDELETE(agreementCommentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementComment/{agreementCommentId}";
        if (agreementCommentId === undefined || agreementCommentId === null)
            throw new Error("The parameter 'agreementCommentId' must be defined.");
        url_ = url_.replace("{agreementCommentId}", encodeURIComponent("" + agreementCommentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementCommentDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementCommentDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementCommentDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdate(body?: UpdateCommentInputDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementComment/bulk-update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkDelete(body?: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementComment/bulk-delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AgreementTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isClientTemplate (optional) 
     * @param agreementTemplateId (optional) 
     * @param search (optional) 
     * @param tenantId (optional) 
     * @param legalEntityId (optional) 
     * @param name (optional) 
     * @param clientId (optional) 
     * @param language (optional) 
     * @param agreementType (optional) 
     * @param agreementRecipients (optional) 
     * @param contractTypes (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param lastUpdatedByEmployeeId (optional) 
     * @param isEnabled (optional) 
     * @param linkStates (optional) 
     * @param linkStateAccepted (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    list2(isClientTemplate?: boolean | undefined, agreementTemplateId?: number | undefined, search?: string | undefined, tenantId?: number[] | undefined, legalEntityId?: number[] | undefined, name?: string | undefined, clientId?: number[] | undefined, language?: AgreementLanguage[] | undefined, agreementType?: AgreementType[] | undefined, agreementRecipients?: number[] | undefined, contractTypes?: number[] | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, lastUpdatedByEmployeeId?: number[] | undefined, isEnabled?: boolean[] | undefined, linkStates?: AgreementTemplateParentChildLinkStateFilter[] | undefined, linkStateAccepted?: boolean[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementTemplatesListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/list?";
        if (isClientTemplate === null)
            throw new Error("The parameter 'isClientTemplate' cannot be null.");
        else if (isClientTemplate !== undefined)
            url_ += "IsClientTemplate=" + encodeURIComponent("" + isClientTemplate) + "&";
        if (agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' cannot be null.");
        else if (agreementTemplateId !== undefined)
            url_ += "AgreementTemplateId=" + encodeURIComponent("" + agreementTemplateId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            tenantId && tenantId.forEach(item => { url_ += "TenantId=" + encodeURIComponent("" + item) + "&"; });
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            legalEntityId && legalEntityId.forEach(item => { url_ += "LegalEntityId=" + encodeURIComponent("" + item) + "&"; });
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            clientId && clientId.forEach(item => { url_ += "ClientId=" + encodeURIComponent("" + item) + "&"; });
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            language && language.forEach(item => { url_ += "Language=" + encodeURIComponent("" + item) + "&"; });
        if (agreementType === null)
            throw new Error("The parameter 'agreementType' cannot be null.");
        else if (agreementType !== undefined)
            agreementType && agreementType.forEach(item => { url_ += "AgreementType=" + encodeURIComponent("" + item) + "&"; });
        if (agreementRecipients === null)
            throw new Error("The parameter 'agreementRecipients' cannot be null.");
        else if (agreementRecipients !== undefined)
            agreementRecipients && agreementRecipients.forEach(item => { url_ += "AgreementRecipients=" + encodeURIComponent("" + item) + "&"; });
        if (contractTypes === null)
            throw new Error("The parameter 'contractTypes' cannot be null.");
        else if (contractTypes !== undefined)
            contractTypes && contractTypes.forEach(item => { url_ += "ContractTypes=" + encodeURIComponent("" + item) + "&"; });
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (lastUpdatedByEmployeeId === null)
            throw new Error("The parameter 'lastUpdatedByEmployeeId' cannot be null.");
        else if (lastUpdatedByEmployeeId !== undefined)
            lastUpdatedByEmployeeId && lastUpdatedByEmployeeId.forEach(item => { url_ += "LastUpdatedByEmployeeId=" + encodeURIComponent("" + item) + "&"; });
        if (isEnabled === null)
            throw new Error("The parameter 'isEnabled' cannot be null.");
        else if (isEnabled !== undefined)
            isEnabled && isEnabled.forEach(item => { url_ += "IsEnabled=" + encodeURIComponent("" + item) + "&"; });
        if (linkStates === null)
            throw new Error("The parameter 'linkStates' cannot be null.");
        else if (linkStates !== undefined)
            linkStates && linkStates.forEach(item => { url_ += "LinkStates=" + encodeURIComponent("" + item) + "&"; });
        if (linkStateAccepted === null)
            throw new Error("The parameter 'linkStateAccepted' cannot be null.");
        else if (linkStateAccepted !== undefined)
            linkStateAccepted && linkStateAccepted.forEach(item => { url_ += "LinkStateAccepted=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplatesListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplatesListItemDtoPaginatedList>;
        }));
    }

    protected processList2(response: HttpResponseBase): Observable<AgreementTemplatesListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementTemplatesListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplatesListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param isClientTemplate (optional) 
     * @param agreementTemplateId (optional) 
     * @param legalEntityId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param deliveryTypeId (optional) 
     * @param clientId (optional) 
     * @param recipientTypeId (optional) 
     * @param isEnabled (optional) 
     * @param search (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    simpleList2(isClientTemplate?: boolean | undefined, agreementTemplateId?: number | undefined, legalEntityId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, deliveryTypeId?: number | undefined, clientId?: number | undefined, recipientTypeId?: number | undefined, isEnabled?: boolean | undefined, search?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<SimpleAgreementTemplatesListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/simple-list?";
        if (isClientTemplate === null)
            throw new Error("The parameter 'isClientTemplate' cannot be null.");
        else if (isClientTemplate !== undefined)
            url_ += "IsClientTemplate=" + encodeURIComponent("" + isClientTemplate) + "&";
        if (agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' cannot be null.");
        else if (agreementTemplateId !== undefined)
            url_ += "AgreementTemplateId=" + encodeURIComponent("" + agreementTemplateId) + "&";
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            url_ += "LegalEntityId=" + encodeURIComponent("" + legalEntityId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (recipientTypeId === null)
            throw new Error("The parameter 'recipientTypeId' cannot be null.");
        else if (recipientTypeId !== undefined)
            url_ += "RecipientTypeId=" + encodeURIComponent("" + recipientTypeId) + "&";
        if (isEnabled === null)
            throw new Error("The parameter 'isEnabled' cannot be null.");
        else if (isEnabled !== undefined)
            url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimpleList2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimpleList2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleAgreementTemplatesListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleAgreementTemplatesListItemDtoPaginatedList>;
        }));
    }

    protected processSimpleList2(response: HttpResponseBase): Observable<SimpleAgreementTemplatesListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleAgreementTemplatesListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleAgreementTemplatesListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param recipientTypeId (optional) 
     * @param legalEntityId (optional) 
     * @param deliveryTypeId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    defaultTemplateId(recipientTypeId?: number | undefined, legalEntityId?: number | undefined, deliveryTypeId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, clientId?: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/default-template-id?";
        if (recipientTypeId === null)
            throw new Error("The parameter 'recipientTypeId' cannot be null.");
        else if (recipientTypeId !== undefined)
            url_ += "RecipientTypeId=" + encodeURIComponent("" + recipientTypeId) + "&";
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            url_ += "LegalEntityId=" + encodeURIComponent("" + legalEntityId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDefaultTemplateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDefaultTemplateId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDefaultTemplateId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    clientOtherTemplates(clientId?: number | undefined): Observable<SimpleAgreementTemplatesListItemDto[]> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/client-other-templates?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientOtherTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientOtherTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimpleAgreementTemplatesListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimpleAgreementTemplatesListItemDto[]>;
        }));
    }

    protected processClientOtherTemplates(response: HttpResponseBase): Observable<SimpleAgreementTemplatesListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleAgreementTemplatesListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleAgreementTemplatesListItemDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementTemplatePOST(body?: SaveAgreementTemplateDto | undefined): Observable<SaveAgreementTemplateCommandResult> {
        let url_ = this.baseUrl + "/api/AgreementTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplatePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplatePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaveAgreementTemplateCommandResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaveAgreementTemplateCommandResult>;
        }));
    }

    protected processAgreementTemplatePOST(response: HttpResponseBase): Observable<SaveAgreementTemplateCommandResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveAgreementTemplateCommandResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SaveAgreementTemplateCommandResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementTemplatePATCH(agreementTemplateId: number, body?: SaveAgreementTemplateDto | undefined): Observable<SaveAgreementTemplateCommandResult> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplatePATCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplatePATCH(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaveAgreementTemplateCommandResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaveAgreementTemplateCommandResult>;
        }));
    }

    protected processAgreementTemplatePATCH(response: HttpResponseBase): Observable<SaveAgreementTemplateCommandResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveAgreementTemplateCommandResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SaveAgreementTemplateCommandResult>(null as any);
    }

    /**
     * @return Success
     */
    agreementTemplateGET(agreementTemplateId: number): Observable<AgreementTemplateDetailsDto> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateDetailsDto>;
        }));
    }

    protected processAgreementTemplateGET(response: HttpResponseBase): Observable<AgreementTemplateDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementTemplateDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    agreementTemplateDELETE(agreementTemplateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementTemplateDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    preview2(agreementTemplateId: number): Observable<AgreementTemplateDetailsPreviewDto> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/preview";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateDetailsPreviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateDetailsPreviewDto>;
        }));
    }

    protected processPreview2(response: HttpResponseBase): Observable<AgreementTemplateDetailsPreviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementTemplateDetailsPreviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateDetailsPreviewDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    documentFilePUT2(agreementTemplateId: number, forceUpdate: boolean, body?: StringWrappedValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/{forceUpdate}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (forceUpdate === undefined || forceUpdate === null)
            throw new Error("The parameter 'forceUpdate' must be defined.");
        url_ = url_.replace("{forceUpdate}", encodeURIComponent("" + forceUpdate));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentFilePUT2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentFilePUT2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDocumentFilePUT2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completeTemplate(agreementTemplateId: number, forceUpdate: boolean, body?: CompleteTemplateDocumentFileDraftDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/complete-template/{forceUpdate}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (forceUpdate === undefined || forceUpdate === null)
            throw new Error("The parameter 'forceUpdate' must be defined.");
        url_ = url_.replace("{forceUpdate}", encodeURIComponent("" + forceUpdate));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompleteTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompleted(agreementTemplateId: number, body?: UpdateCompletedTemplateDocumentFileDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/update-completed";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompleted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCompleted(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    latestTemplateVersion(agreementTemplateId: number, getDraftIfAvailable: boolean): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/latest-template-version/{getDraftIfAvailable}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (getDraftIfAvailable === undefined || getDraftIfAvailable === null)
            throw new Error("The parameter 'getDraftIfAvailable' must be defined.");
        url_ = url_.replace("{getDraftIfAvailable}", encodeURIComponent("" + getDraftIfAvailable));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLatestTemplateVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLatestTemplateVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLatestTemplateVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    documentFileGET2(agreementTemplateId: number, documentFileVersion: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/{documentFileVersion}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (documentFileVersion === undefined || documentFileVersion === null)
            throw new Error("The parameter 'documentFileVersion' must be defined.");
        url_ = url_.replace("{documentFileVersion}", encodeURIComponent("" + documentFileVersion));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentFileGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentFileGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDocumentFileGET2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    templateVersions(agreementTemplateId: number): Observable<AgreementTemplateDocumentFileVersionDto[]> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/document-file/template-versions";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplateVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplateVersions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateDocumentFileVersionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateDocumentFileVersionDto[]>;
        }));
    }

    protected processTemplateVersions(response: HttpResponseBase): Observable<AgreementTemplateDocumentFileVersionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementTemplateDocumentFileVersionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateDocumentFileVersionDto[]>(null as any);
    }

    /**
     * @param search (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    childTemplates(agreementTemplateId: number, search?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementTemplateChildTemplateDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/child-templates?";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateChildTemplateDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateChildTemplateDtoPaginatedList>;
        }));
    }

    protected processChildTemplates(response: HttpResponseBase): Observable<AgreementTemplateChildTemplateDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementTemplateChildTemplateDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateChildTemplateDtoPaginatedList>(null as any);
    }

    /**
     * @param search (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    childAgreements(agreementTemplateId: number, search?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementTemplateChildAgreementDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/child-agreements?";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildAgreements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateChildAgreementDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateChildAgreementDtoPaginatedList>;
        }));
    }

    protected processChildAgreements(response: HttpResponseBase): Observable<AgreementTemplateChildAgreementDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementTemplateChildAgreementDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateChildAgreementDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    metadataLog(agreementTemplateId: number, newestFirst: boolean): Observable<AgreementTemplateMetadataLogListItemDto[]> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/metadata-log/{newestFirst}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (newestFirst === undefined || newestFirst === null)
            throw new Error("The parameter 'newestFirst' must be defined.");
        url_ = url_.replace("{newestFirst}", encodeURIComponent("" + newestFirst));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMetadataLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMetadataLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateMetadataLogListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateMetadataLogListItemDto[]>;
        }));
    }

    protected processMetadataLog(response: HttpResponseBase): Observable<AgreementTemplateMetadataLogListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementTemplateMetadataLogListItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateMetadataLogListItemDto[]>(null as any);
    }

    /**
     * @return Success
     */
    acceptLinkState(agreementTemplateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplate/{agreementTemplateId}/accept-link-state";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptLinkState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptLinkState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptLinkState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AgreementTemplateAttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    agreementTemplateAttachment(agreementTemplateAttachmentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplateAttachment/{agreementTemplateAttachmentId}";
        if (agreementTemplateAttachmentId === undefined || agreementTemplateAttachmentId === null)
            throw new Error("The parameter 'agreementTemplateAttachmentId' must be defined.");
        url_ = url_.replace("{agreementTemplateAttachmentId}", encodeURIComponent("" + agreementTemplateAttachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementTemplateAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class AgreementTemplateCommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    agreementTemplateCommentAll(agreementTemplateId: number): Observable<AgreementTemplateCommentDto[]> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/{agreementTemplateId}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateCommentAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateCommentAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementTemplateCommentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementTemplateCommentDto[]>;
        }));
    }

    protected processAgreementTemplateCommentAll(response: HttpResponseBase): Observable<AgreementTemplateCommentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgreementTemplateCommentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementTemplateCommentDto[]>(null as any);
    }

    /**
     * @param parentCommentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    agreementTemplateCommentPUT(agreementTemplateId: number, parentCommentId?: number | undefined, body?: CommentInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/{agreementTemplateId}?";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        if (parentCommentId === null)
            throw new Error("The parameter 'parentCommentId' cannot be null.");
        else if (parentCommentId !== undefined)
            url_ += "parentCommentId=" + encodeURIComponent("" + parentCommentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateCommentPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateCommentPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAgreementTemplateCommentPUT(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    agreementTemplateCommentPATCH(agreementTemplateCommentId: number, body?: CommentInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/{agreementTemplateCommentId}";
        if (agreementTemplateCommentId === undefined || agreementTemplateCommentId === null)
            throw new Error("The parameter 'agreementTemplateCommentId' must be defined.");
        url_ = url_.replace("{agreementTemplateCommentId}", encodeURIComponent("" + agreementTemplateCommentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateCommentPATCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateCommentPATCH(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementTemplateCommentPATCH(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    agreementTemplateCommentDELETE(agreementTemplateCommentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/{agreementTemplateCommentId}";
        if (agreementTemplateCommentId === undefined || agreementTemplateCommentId === null)
            throw new Error("The parameter 'agreementTemplateCommentId' must be defined.");
        url_ = url_.replace("{agreementTemplateCommentId}", encodeURIComponent("" + agreementTemplateCommentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateCommentDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateCommentDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAgreementTemplateCommentDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkUpdate2(body?: UpdateCommentInputDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/bulk-update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkUpdate2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkDelete2(body?: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AgreementTemplateComment/bulk-delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBulkDelete2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientAddressesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clientAddressesGET(clientId: number): Observable<ClientAddressDto[]> {
        let url_ = this.baseUrl + "/api/ClientAddresses/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientAddressesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientAddressesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAddressDto[]>;
        }));
    }

    protected processClientAddressesGET(response: HttpResponseBase): Observable<ClientAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAddressDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAddressesPOST(clientId: number, body?: ClientAddressDto | undefined): Observable<ClientAddressDto[]> {
        let url_ = this.baseUrl + "/api/ClientAddresses/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientAddressesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientAddressesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAddressDto[]>;
        }));
    }

    protected processClientAddressesPOST(response: HttpResponseBase): Observable<ClientAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAddressDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientAddressesPUT(body?: ClientAddressDto | undefined): Observable<ClientAddressDto[]> {
        let url_ = this.baseUrl + "/api/ClientAddresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientAddressesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientAddressesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAddressDto[]>;
        }));
    }

    protected processClientAddressesPUT(response: HttpResponseBase): Observable<ClientAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAddressDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientAddressesDELETE(clientAddressId: number): Observable<ClientAddressDto[]> {
        let url_ = this.baseUrl + "/api/ClientAddresses/{clientAddressId}";
        if (clientAddressId === undefined || clientAddressId === null)
            throw new Error("The parameter 'clientAddressId' must be defined.");
        url_ = url_.replace("{clientAddressId}", encodeURIComponent("" + clientAddressId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientAddressesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientAddressesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAddressDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAddressDto[]>;
        }));
    }

    protected processClientAddressesDELETE(response: HttpResponseBase): Observable<ClientAddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAddressDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAddressDto[]>(null as any);
    }
}

@Injectable()
export class ClientDocumentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    document(documentGuid: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientDocuments/Document/{documentGuid}";
        if (documentGuid === undefined || documentGuid === null)
            throw new Error("The parameter 'documentGuid' must be defined.");
        url_ = url_.replace("{documentGuid}", encodeURIComponent("" + documentGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDocument(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    contractDocuments(clientId: number, includeLinkedClients: boolean, includeExpired: boolean): Observable<ClientContractViewRootDto> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/ContractDocuments/{includeLinkedClients}/{includeExpired}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        if (includeExpired === undefined || includeExpired === null)
            throw new Error("The parameter 'includeExpired' must be defined.");
        url_ = url_.replace("{includeExpired}", encodeURIComponent("" + includeExpired));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientContractViewRootDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientContractViewRootDto>;
        }));
    }

    protected processContractDocuments(response: HttpResponseBase): Observable<ClientContractViewRootDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientContractViewRootDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientContractViewRootDto>(null as any);
    }

    /**
     * @return Success
     */
    generalAttachments(clientId: number, includeLinkedClients: boolean): Observable<ClientAttachmentInfoOutputDto[]> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralAttachments/{includeLinkedClients}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientAttachmentInfoOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientAttachmentInfoOutputDto[]>;
        }));
    }

    protected processGeneralAttachments(response: HttpResponseBase): Observable<ClientAttachmentInfoOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientAttachmentInfoOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAttachmentInfoOutputDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAvailableStatusForClientAttachments(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/ClientDocuments/GetAvailableStatusForClientAttachmentsAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableStatusForClientAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableStatusForClientAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdNameDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdNameDto[]>;
        }));
    }

    protected processGetAvailableStatusForClientAttachments(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(null as any);
    }

    /**
     * @param formFile (optional) 
     * @return Success
     */
    generalFilePOST(clientId: number, attachmentFileTypeId: number, formFile?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile/{attachmentFileTypeId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (attachmentFileTypeId === undefined || attachmentFileTypeId === null)
            throw new Error("The parameter 'attachmentFileTypeId' must be defined.");
        url_ = url_.replace("{attachmentFileTypeId}", encodeURIComponent("" + attachmentFileTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile === null || formFile === undefined)
            throw new Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFilePOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFilePOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFilePOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    generalFileDELETE(clientId: number, clientAttachmentGuid: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile/{clientAttachmentGuid}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientAttachmentGuid === undefined || clientAttachmentGuid === null)
            throw new Error("The parameter 'clientAttachmentGuid' must be defined.");
        url_ = url_.replace("{clientAttachmentGuid}", encodeURIComponent("" + clientAttachmentGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFileDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFileDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFileDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    generalFilePUT(clientId: number, body?: UpdateClientAttachmentFileInfoInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/GeneralFile";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralFilePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralFilePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGeneralFilePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    evaluations(clientId: number, includeLinkedClients: boolean, fromDate?: moment.Moment | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientEvaluationOutputDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{clientId}/Evaluations/{includeLinkedClients}?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (includeLinkedClients === undefined || includeLinkedClients === null)
            throw new Error("The parameter 'includeLinkedClients' must be defined.");
        url_ = url_.replace("{includeLinkedClients}", encodeURIComponent("" + includeLinkedClients));
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientEvaluationOutputDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientEvaluationOutputDtoPaginatedList>;
        }));
    }

    protected processEvaluations(response: HttpResponseBase): Observable<ClientEvaluationOutputDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientEvaluationOutputDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientEvaluationOutputDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    evaluation(legacyConsultantId: number, evalTenantId: number, evalGuid: string, useLocalLanguage: boolean, forcePdf: boolean): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientDocuments/{legacyConsultantId}/Evaluation/{evalTenantId}/{evalGuid}/{useLocalLanguage}/{forcePdf}";
        if (legacyConsultantId === undefined || legacyConsultantId === null)
            throw new Error("The parameter 'legacyConsultantId' must be defined.");
        url_ = url_.replace("{legacyConsultantId}", encodeURIComponent("" + legacyConsultantId));
        if (evalTenantId === undefined || evalTenantId === null)
            throw new Error("The parameter 'evalTenantId' must be defined.");
        url_ = url_.replace("{evalTenantId}", encodeURIComponent("" + evalTenantId));
        if (evalGuid === undefined || evalGuid === null)
            throw new Error("The parameter 'evalGuid' must be defined.");
        url_ = url_.replace("{evalGuid}", encodeURIComponent("" + evalGuid));
        if (useLocalLanguage === undefined || useLocalLanguage === null)
            throw new Error("The parameter 'useLocalLanguage' must be defined.");
        url_ = url_.replace("{useLocalLanguage}", encodeURIComponent("" + useLocalLanguage));
        if (forcePdf === undefined || forcePdf === null)
            throw new Error("The parameter 'forcePdf' must be defined.");
        url_ = url_.replace("{forcePdf}", encodeURIComponent("" + forcePdf));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEvaluation(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

@Injectable()
export class ClientPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientSalesPUT(clientPeriodId: string, body?: ClientPeriodSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSalesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSalesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientSalesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientSalesGET(clientPeriodId: string): Observable<ClientPeriodSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSalesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSalesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodSalesDataQueryDto>;
        }));
    }

    protected processClientSalesGET(response: HttpResponseBase): Observable<ClientPeriodSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodSalesDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    reopen(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-sales/reopen";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReopen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReopen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReopen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editStart(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts/edit-start";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientContractsPUT(clientPeriodId: string, body?: ClientPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientContractsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientContractsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientContractsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientContractsGET(clientPeriodId: string): Observable<ClientPeriodContractsDataQueryDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientContractsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientContractsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodContractsDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodContractsDataQueryDto>;
        }));
    }

    protected processClientContractsGET(response: HttpResponseBase): Observable<ClientPeriodContractsDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodContractsDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodContractsDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish2(clientPeriodId: string, body?: ClientPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-contracts/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientAgreements(clientPeriodId: string): Observable<ClientPeriodAgreementsDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-agreements";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientAgreements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodAgreementsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodAgreementsDto>;
        }));
    }

    protected processClientAgreements(response: HttpResponseBase): Observable<ClientPeriodAgreementsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodAgreementsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodAgreementsDto>(null as any);
    }

    /**
     * @return Success
     */
    notifyCreation(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-agreements/notify-creation";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyCreation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyCreation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotifyCreation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editStart2(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance/edit-start";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientFinancePUT(clientPeriodId: string, body?: ClientPeriodFinanceDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientFinancePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientFinancePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientFinancePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientFinanceGET(clientPeriodId: string): Observable<ClientPeriodFinanceDataQueryDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientFinanceGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientFinanceGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodFinanceDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodFinanceDataQueryDto>;
        }));
    }

    protected processClientFinanceGET(response: HttpResponseBase): Observable<ClientPeriodFinanceDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodFinanceDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodFinanceDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish3(clientPeriodId: string, body?: ClientPeriodFinanceDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-finance/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientExtend(clientPeriodId: string, body?: ExtendClientPeriodDto | undefined): Observable<ExtendClientPeriodResultDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-extend";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExtendClientPeriodResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExtendClientPeriodResultDto>;
        }));
    }

    protected processClientExtend(response: HttpResponseBase): Observable<ExtendClientPeriodResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtendClientPeriodResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtendClientPeriodResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientChange(clientPeriodId: string, body?: ChangeClientPeriodDto | undefined): Observable<ChangeClientPeriodResultDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/client-change";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangeClientPeriodResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangeClientPeriodResultDto>;
        }));
    }

    protected processClientChange(response: HttpResponseBase): Observable<ChangeClientPeriodResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeClientPeriodResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangeClientPeriodResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addConsultantPeriod(clientPeriodId: string, body?: ConsultantPeriodAddDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/add-consultant-period";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddConsultantPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddConsultantPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddConsultantPeriod(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    projectType(projectTypeId: number): Observable<ProjectTypeConfigurationDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/project-type/{projectTypeId}";
        if (projectTypeId === undefined || projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' must be defined.");
        url_ = url_.replace("{projectTypeId}", encodeURIComponent("" + projectTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectTypeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectTypeConfigurationDto>;
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<ProjectTypeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectTypeConfigurationDto>(null as any);
    }

    /**
     * @return Success
     */
    availableConsultants(clientPeriodId: string): Observable<AvailableConsultantDto[]> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/available-consultants";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableConsultantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableConsultantDto[]>;
        }));
    }

    protected processAvailableConsultants(response: HttpResponseBase): Observable<AvailableConsultantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AvailableConsultantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableConsultantDto[]>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    stepResponsible(clientPeriodId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/{stepType}/step-responsible?";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param newSalesAccountManagerId (optional) 
     * @return Success
     */
    salesAccountManager(clientPeriodId: string, newSalesAccountManagerId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales-account-manager?";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        if (newSalesAccountManagerId === null)
            throw new Error("The parameter 'newSalesAccountManagerId' cannot be null.");
        else if (newSalesAccountManagerId !== undefined)
            url_ += "newSalesAccountManagerId=" + encodeURIComponent("" + newSalesAccountManagerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesAccountManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesAccountManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSalesAccountManager(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    clientPeriod(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClientPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param countryFilter (optional) 
     * @param ownerFilter (optional) 
     * @param isActive (optional) 
     * @param excludeDeleted (optional) 
     * @param onlyWrongfullyDeletedInHubspot (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    list3(search?: string | undefined, countryFilter?: number[] | undefined, ownerFilter?: number[] | undefined, isActive?: boolean | undefined, excludeDeleted?: boolean | undefined, onlyWrongfullyDeletedInHubspot?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/list?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (countryFilter === null)
            throw new Error("The parameter 'countryFilter' cannot be null.");
        else if (countryFilter !== undefined)
            countryFilter && countryFilter.forEach(item => { url_ += "countryFilter=" + encodeURIComponent("" + item) + "&"; });
        if (ownerFilter === null)
            throw new Error("The parameter 'ownerFilter' cannot be null.");
        else if (ownerFilter !== undefined)
            ownerFilter && ownerFilter.forEach(item => { url_ += "ownerFilter=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        if (onlyWrongfullyDeletedInHubspot === null)
            throw new Error("The parameter 'onlyWrongfullyDeletedInHubspot' cannot be null.");
        else if (onlyWrongfullyDeletedInHubspot !== undefined)
            url_ += "onlyWrongfullyDeletedInHubspot=" + encodeURIComponent("" + onlyWrongfullyDeletedInHubspot) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientListItemDtoPaginatedList>;
        }));
    }

    protected processList3(response: HttpResponseBase): Observable<ClientListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListItemDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    clients(clientId: number): Observable<ClientDetailsDto> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDetailsDto>;
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailsDto>(null as any);
    }

    /**
     * @param consultantShownOnClientInvoiceAs (optional) 
     * @return Success
     */
    invoicingSettings(clientId: number, consultantShownOnClientInvoiceAs?: ConsultantShownOnClientInvoiceAs | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/invoicing-settings?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (consultantShownOnClientInvoiceAs === null)
            throw new Error("The parameter 'consultantShownOnClientInvoiceAs' cannot be null.");
        else if (consultantShownOnClientInvoiceAs !== undefined)
            url_ += "consultantShownOnClientInvoiceAs=" + encodeURIComponent("" + consultantShownOnClientInvoiceAs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicingSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicingSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvoicingSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    specialRatesAll(clientId: number, showHidden: boolean): Observable<ClientSpecialRateDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialRateDto[]>;
        }));
    }

    protected processSpecialRatesAll(response: HttpResponseBase): Observable<ClientSpecialRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialRateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialRateDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPOST(clientId: number, body?: AddClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPUT(clientId: number, body?: UpdateClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete(clientId: number, clientSpecialRateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{clientSpecialRateId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialRateId === undefined || clientSpecialRateId === null)
            throw new Error("The parameter 'clientSpecialRateId' must be defined.");
        url_ = url_.replace("{clientSpecialRateId}", encodeURIComponent("" + clientSpecialRateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    specialFeesAll(clientId: number, showHidden: boolean): Observable<ClientSpecialFeeDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialFeeDto[]>;
        }));
    }

    protected processSpecialFeesAll(response: HttpResponseBase): Observable<ClientSpecialFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialFeeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPOST(clientId: number, body?: AddClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPUT(clientId: number, body?: UpdateClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete2(clientId: number, clientSpecialFeeId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{clientSpecialFeeId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialFeeId === undefined || clientSpecialFeeId === null)
            throw new Error("The parameter 'clientSpecialFeeId' must be defined.");
        url_ = url_.replace("{clientSpecialFeeId}", encodeURIComponent("" + clientSpecialFeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    requestTrack(clientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientRequestTrackItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/request-track?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTrack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientRequestTrackItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientRequestTrackItemDtoPaginatedList>;
        }));
    }

    protected processRequestTrack(response: HttpResponseBase): Observable<ClientRequestTrackItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRequestTrackItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRequestTrackItemDtoPaginatedList>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflowTrack(clientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientWorkflowTrackItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/workflow-track?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowTrack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientWorkflowTrackItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientWorkflowTrackItemDtoPaginatedList>;
        }));
    }

    protected processWorkflowTrack(response: HttpResponseBase): Observable<ClientWorkflowTrackItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientWorkflowTrackItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientWorkflowTrackItemDtoPaginatedList>(null as any);
    }

    /**
     * @param excludeDeleted (optional) 
     * @return Success
     */
    contacts(clientId: number, excludeDeleted?: boolean | undefined): Observable<ContactDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/contacts?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDto[]>(null as any);
    }

    /**
     * @param clientAddressId (optional) 
     * @return Success
     */
    contactAddress(contactId: number, clientAddressId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/contact-address/{contactId}?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        if (clientAddressId === null)
            throw new Error("The parameter 'clientAddressId' cannot be null.");
        else if (clientAddressId !== undefined)
            url_ += "clientAddressId=" + encodeURIComponent("" + clientAddressId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrl(clientId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrl";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrlEditContactLogin(clientId: number, contactId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrlEditContactLogin/{contactId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrlEditContactLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrlEditContactLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrlEditContactLogin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    hubspotClientUrl(clientId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/HubspotClientUrlAsync";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHubspotClientUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHubspotClientUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processHubspotClientUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    hubspotPartialUrl(): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/HubspotPartialUrlAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHubspotPartialUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHubspotPartialUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processHubspotPartialUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    crmSync(clientId: number): Observable<SyncClientFromCrmResultDto> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/crm-sync";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCrmSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCrmSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncClientFromCrmResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncClientFromCrmResultDto>;
        }));
    }

    protected processCrmSync(response: HttpResponseBase): Observable<SyncClientFromCrmResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyncClientFromCrmResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncClientFromCrmResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getWFResponsible(clientId: number): Observable<ClientWFResponsibleDto> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/GetWFResponsible";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWFResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWFResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientWFResponsibleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientWFResponsibleDto>;
        }));
    }

    protected processGetWFResponsible(response: HttpResponseBase): Observable<ClientWFResponsibleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientWFResponsibleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientWFResponsibleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postWFResponsible(body?: UpdateClientWFResponsibleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/PostWFResponsible";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostWFResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWFResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostWFResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    contractsEnabled(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Configuration/contracts-enabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsEnabled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processContractsEnabled(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class ConsultantPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    consultantSalesGET(consultantPeriodId: string): Observable<ConsultantPeriodSalesDataDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantSalesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantSalesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodSalesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodSalesDataDto>;
        }));
    }

    protected processConsultantSalesGET(response: HttpResponseBase): Observable<ConsultantPeriodSalesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodSalesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodSalesDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantSalesPUT(consultantPeriodId: string, body?: ConsultantPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantSalesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantSalesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantSalesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish4(consultantPeriodId: string, body?: ConsultantPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    reopen2(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-sales/reopen";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReopen2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReopen2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReopen2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantContractsGET(consultantPeriodId: string): Observable<ConsultantPeriodContractsDataQueryDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantContractsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantContractsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodContractsDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodContractsDataQueryDto>;
        }));
    }

    protected processConsultantContractsGET(response: HttpResponseBase): Observable<ConsultantPeriodContractsDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodContractsDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodContractsDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantContractsPUT(consultantPeriodId: string, body?: ConsultantPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantContractsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantContractsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantContractsPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editStart3(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts/edit-start";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish5(consultantPeriodId: string, body?: ConsultantPeriodContractsDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-contracts/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish5(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantAgreements(consultantPeriodId: string): Observable<ConsultantPeriodAgreementsDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-agreements";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantAgreements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodAgreementsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodAgreementsDto>;
        }));
    }

    protected processConsultantAgreements(response: HttpResponseBase): Observable<ConsultantPeriodAgreementsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodAgreementsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodAgreementsDto>(null as any);
    }

    /**
     * @return Success
     */
    notifyCreation2(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-agreements/notify-creation";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotifyCreation2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotifyCreation2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotifyCreation2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantFinanceGET(consultantPeriodId: string): Observable<ConsultantPeriodFinanceDataDto> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantFinanceGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantFinanceGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodFinanceDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodFinanceDataDto>;
        }));
    }

    protected processConsultantFinanceGET(response: HttpResponseBase): Observable<ConsultantPeriodFinanceDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodFinanceDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodFinanceDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantFinancePUT(consultantPeriodId: string, body?: ConsultantPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantFinancePUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantFinancePUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantFinancePUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editStart4(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance/edit-start";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditStart4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditStart4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditStart4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish6(consultantPeriodId: string, body?: ConsultantPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/consultant-finance/edit-finish";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish6(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extend(consultantPeriodId: string, body?: ExtendConsultantPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/extend";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    change(consultantPeriodId: string, body?: ChangeConsultantPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/change";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processChange(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    stepResponsible2(consultantPeriodId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}/{stepType}/step-responsible?";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepResponsible2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepResponsible2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStepResponsible2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriod(consultantPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ConsultantPeriod/{consultantPeriodId}";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsultantPeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clientPeriodSync(clientPeriodId: string, body?: ClientPeriodContractsDataCommandDto | undefined): Observable<ClientPeriodSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{clientPeriodId}/ClientPeriodSync";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodSyncResultDto>;
        }));
    }

    protected processClientPeriodSync(response: HttpResponseBase): Observable<ClientPeriodSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodSyncResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantPeriodSync(consultantPeriodId: string, body?: ConsultantPeriodContractsDataCommandDto | undefined): Observable<ConsultantPeriodSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{consultantPeriodId}/ConsultantPeriodSync";
        if (consultantPeriodId === undefined || consultantPeriodId === null)
            throw new Error("The parameter 'consultantPeriodId' must be defined.");
        url_ = url_.replace("{consultantPeriodId}", encodeURIComponent("" + consultantPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodSyncResultDto>;
        }));
    }

    protected processConsultantPeriodSync(response: HttpResponseBase): Observable<ConsultantPeriodSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantPeriodSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodSyncResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    workflowTerminationSync(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<WorkflowTerminationSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{workflowId}/WorkflowTerminationSync";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowTerminationSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowTerminationSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSyncResultDto>;
        }));
    }

    protected processWorkflowTerminationSync(response: HttpResponseBase): Observable<WorkflowTerminationSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSyncResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    consultantTerminationSync(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<ConsultantTerminationSyncResultDto> {
        let url_ = this.baseUrl + "/api/ContractSync/{workflowId}/ConsultantTerminationSync";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTerminationSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTerminationSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSyncResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSyncResultDto>;
        }));
    }

    protected processConsultantTerminationSync(response: HttpResponseBase): Observable<ConsultantTerminationSyncResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSyncResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSyncResultDto>(null as any);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    current(): Observable<CurrentEmployeeDto> {
        let url_ = this.baseUrl + "/api/Employee/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentEmployeeDto>;
        }));
    }

    protected processCurrent(response: HttpResponseBase): Observable<CurrentEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentEmployeeDto>(null as any);
    }
}

@Injectable()
export class EmployeeNotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    enabledNotifications(): Observable<EmployeeNotificationDto[]> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/enabled-notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnabledNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnabledNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeNotificationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeNotificationDto[]>;
        }));
    }

    protected processEnabledNotifications(response: HttpResponseBase): Observable<EmployeeNotificationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeNotificationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeNotificationDto[]>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    addNotification(notificationId?: number | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/add-notification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeNotification(notificationId?: number | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/remove-notification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    countries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Enum/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    currencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCurrencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tenants(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/tenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processTenants(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    deliveryTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/delivery-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliveryTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliveryTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDeliveryTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoiceFrequencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoice-frequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceFrequencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoiceFrequencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoicingTimes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoicing-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicingTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicingTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoicingTimes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    rateUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/rate-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRateUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    valueUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/value-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValueUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValueUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processValueUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    periodUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/period-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPeriodUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPeriodUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processPeriodUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    salesTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/sales-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSalesTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    signerRoles(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/signer-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSignerRoles(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    margins(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/margins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMargins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMargins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processMargins(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantShownOnClientInvoiceAs(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/consultant-shown-on-client-invoice-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantShownOnClientInvoiceAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantShownOnClientInvoiceAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processConsultantShownOnClientInvoiceAs(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateReportingUnits(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-reporting-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateReportingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateReportingUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateReportingUnits(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDuration(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDuration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDuration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDuration(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDeadline(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-deadline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDeadline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDeadline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDeadline(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectTypeAll(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectTypeAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectTypeAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectTypeAll(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    purchaseOrderCapType(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/purchase-order-cap-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchaseOrderCapType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchaseOrderCapType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processPurchaseOrderCapType(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    workflowStatuses(): Observable<WorkflowStatusDto[]> {
        let url_ = this.baseUrl + "/api/Enum/workflow-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowStatusDto[]>;
        }));
    }

    protected processWorkflowStatuses(response: HttpResponseBase): Observable<WorkflowStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowStatusDto[]>(null as any);
    }

    /**
     * @return Success
     */
    stepTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/step-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processStepTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    workflowProcessTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/workflow-process-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowProcessTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowProcessTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processWorkflowProcessTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    terminationReasons(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/termination-reasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTerminationReasons(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    terminationTimes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/termination-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTerminationTimes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    emagineOffice(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/emagine-office";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmagineOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmagineOffice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmagineOffice(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contractExpirationNotificationInterval(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/contract-expiration-notification-interval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractExpirationNotificationInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractExpirationNotificationInterval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processContractExpirationNotificationInterval(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    commissionFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    commissionTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    recipientTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/recipient-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecipientTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecipientTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRecipientTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectCategory(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectCategory(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    employmentType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/employment-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmploymentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmploymentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmploymentType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    discount(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/discount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDiscount(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    expectedWorkloadUnit(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/expected-workload-unit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpectedWorkloadUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpectedWorkloadUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processExpectedWorkloadUnit(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantInsuranceOption(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/consultant-insurance-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantInsuranceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantInsuranceOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processConsultantInsuranceOption(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    legalContractStatuses(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/legal-contract-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLegalContractStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLegalContractStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processLegalContractStatuses(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    agreementLanguages(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/agreement-languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreementLanguages(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    agreementTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/agreement-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreementTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    agreementRecipientTypes(): Observable<RecipientTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/agreement-recipient-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementRecipientTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementRecipientTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipientTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipientTypeDto[]>;
        }));
    }

    protected processAgreementRecipientTypes(response: HttpResponseBase): Observable<RecipientTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipientTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecipientTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    agreementTemplateLinkStates(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/agreement-template-link-states";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplateLinkStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplateLinkStates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreementTemplateLinkStates(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    signerTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/signer-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processSignerTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    logOperationTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/log-operation-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOperationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOperationTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processLogOperationTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    legalEntities(): Observable<LegalEntityDto[]> {
        let url_ = this.baseUrl + "/api/Enum/legal-entities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLegalEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLegalEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LegalEntityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LegalEntityDto[]>;
        }));
    }

    protected processLegalEntities(response: HttpResponseBase): Observable<LegalEntityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LegalEntityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LegalEntityDto[]>(null as any);
    }

    /**
     * @return Success
     */
    syncStateStatuses(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/sync-state-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncStateStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncStateStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processSyncStateStatuses(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    agreementValidityStates(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/agreement-validity-states";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementValidityStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementValidityStates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreementValidityStates(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    envelopeProcessingPaths(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/envelope-processing-paths";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnvelopeProcessingPaths(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnvelopeProcessingPaths(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processEnvelopeProcessingPaths(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    envelopeStatuses(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/envelope-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnvelopeStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnvelopeStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processEnvelopeStatuses(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    temporaryPOST(file?: FileParameter | undefined): Observable<StringWrappedValueDto> {
        let url_ = this.baseUrl + "/api/File/temporary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemporaryPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemporaryPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringWrappedValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringWrappedValueDto>;
        }));
    }

    protected processTemporaryPOST(response: HttpResponseBase): Observable<StringWrappedValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringWrappedValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringWrappedValueDto>(null as any);
    }

    /**
     * @param fileId (optional) 
     * @return Success
     */
    temporaryDELETE(fileId?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/temporary?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemporaryDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemporaryDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTemporaryDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FrameAgreementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param agreementId (optional) 
     * @param search (optional) 
     * @param legalEntityId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param deliveryTypeId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param recipientConsultantId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    consultantFrameAgreementList(agreementId?: number | undefined, search?: string | undefined, legalEntityId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, deliveryTypeId?: number | undefined, startDate?: moment.Moment | undefined, endDate?: moment.Moment | undefined, recipientConsultantId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementSimpleListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/FrameAgreement/consultant-frame-agreement-list?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            url_ += "LegalEntityId=" + encodeURIComponent("" + legalEntityId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (recipientConsultantId === null)
            throw new Error("The parameter 'recipientConsultantId' cannot be null.");
        else if (recipientConsultantId !== undefined)
            url_ += "RecipientConsultantId=" + encodeURIComponent("" + recipientConsultantId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantFrameAgreementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantFrameAgreementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
        }));
    }

    protected processConsultantFrameAgreementList(response: HttpResponseBase): Observable<AgreementSimpleListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementSimpleListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementSimpleListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param agreementId (optional) 
     * @param search (optional) 
     * @param clientId (optional) 
     * @param legalEntityId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param deliveryTypeId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param recipientClientIds (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clientFrameAgreementList(agreementId?: number | undefined, search?: string | undefined, clientId?: number | undefined, legalEntityId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, deliveryTypeId?: number | undefined, startDate?: moment.Moment | undefined, endDate?: moment.Moment | undefined, recipientClientIds?: number[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementSimpleListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/FrameAgreement/client-frame-agreement-list?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' cannot be null.");
        else if (legalEntityId !== undefined)
            url_ += "LegalEntityId=" + encodeURIComponent("" + legalEntityId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (recipientClientIds === null)
            throw new Error("The parameter 'recipientClientIds' cannot be null.");
        else if (recipientClientIds !== undefined)
            recipientClientIds && recipientClientIds.forEach(item => { url_ += "RecipientClientIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientFrameAgreementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientFrameAgreementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
        }));
    }

    protected processClientFrameAgreementList(response: HttpResponseBase): Observable<AgreementSimpleListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementSimpleListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementSimpleListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param agreementId (optional) 
     * @param search (optional) 
     * @param payingLegalEntityId (optional) 
     * @param salesTypeId (optional) 
     * @param contractTypeId (optional) 
     * @param deliveryTypeId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param recipientLegalEntityId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    emagineToEmagineFrameAgreementList(agreementId?: number | undefined, search?: string | undefined, payingLegalEntityId?: number | undefined, salesTypeId?: number | undefined, contractTypeId?: number | undefined, deliveryTypeId?: number | undefined, startDate?: moment.Moment | undefined, endDate?: moment.Moment | undefined, recipientLegalEntityId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<AgreementSimpleListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/FrameAgreement/emagine-to-emagine-frame-agreement-list?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (payingLegalEntityId === null)
            throw new Error("The parameter 'payingLegalEntityId' cannot be null.");
        else if (payingLegalEntityId !== undefined)
            url_ += "PayingLegalEntityId=" + encodeURIComponent("" + payingLegalEntityId) + "&";
        if (salesTypeId === null)
            throw new Error("The parameter 'salesTypeId' cannot be null.");
        else if (salesTypeId !== undefined)
            url_ += "SalesTypeId=" + encodeURIComponent("" + salesTypeId) + "&";
        if (contractTypeId === null)
            throw new Error("The parameter 'contractTypeId' cannot be null.");
        else if (contractTypeId !== undefined)
            url_ += "ContractTypeId=" + encodeURIComponent("" + contractTypeId) + "&";
        if (deliveryTypeId === null)
            throw new Error("The parameter 'deliveryTypeId' cannot be null.");
        else if (deliveryTypeId !== undefined)
            url_ += "DeliveryTypeId=" + encodeURIComponent("" + deliveryTypeId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (recipientLegalEntityId === null)
            throw new Error("The parameter 'recipientLegalEntityId' cannot be null.");
        else if (recipientLegalEntityId !== undefined)
            url_ += "RecipientLegalEntityId=" + encodeURIComponent("" + recipientLegalEntityId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmagineToEmagineFrameAgreementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmagineToEmagineFrameAgreementList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgreementSimpleListItemDtoPaginatedList>;
        }));
    }

    protected processEmagineToEmagineFrameAgreementList(response: HttpResponseBase): Observable<AgreementSimpleListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgreementSimpleListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgreementSimpleListItemDtoPaginatedList>(null as any);
    }
}

@Injectable()
export class HistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    filterNames(): Observable<HistoryFilterNamesDto[]> {
        let url_ = this.baseUrl + "/api/History/workflow/filter-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryFilterNamesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryFilterNamesDto[]>;
        }));
    }

    protected processFilterNames(response: HttpResponseBase): Observable<HistoryFilterNamesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistoryFilterNamesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryFilterNamesDto[]>(null as any);
    }

    /**
     * @return Success
     */
    filterNames2(): Observable<HistoryFilterNamesDto[]> {
        let url_ = this.baseUrl + "/api/History/client/filter-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterNames2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterNames2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryFilterNamesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryFilterNamesDto[]>;
        }));
    }

    protected processFilterNames2(response: HttpResponseBase): Observable<HistoryFilterNamesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistoryFilterNamesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryFilterNamesDto[]>(null as any);
    }

    /**
     * @param entityName (optional) 
     * @param propertyName (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflow(workflowId: string, entityName?: string | undefined, propertyName?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<HistoryPropertiesDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/History/workflow/{workflowId}?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (entityName === null)
            throw new Error("The parameter 'entityName' cannot be null.");
        else if (entityName !== undefined)
            url_ += "entityName=" + encodeURIComponent("" + entityName) + "&";
        if (propertyName === null)
            throw new Error("The parameter 'propertyName' cannot be null.");
        else if (propertyName !== undefined)
            url_ += "propertyName=" + encodeURIComponent("" + propertyName) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryPropertiesDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryPropertiesDtoPaginatedList>;
        }));
    }

    protected processWorkflow(response: HttpResponseBase): Observable<HistoryPropertiesDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryPropertiesDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryPropertiesDtoPaginatedList>(null as any);
    }

    /**
     * @param entityName (optional) 
     * @param propertyName (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    client(clientId: number, entityName?: string | undefined, propertyName?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<HistoryPropertiesDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/History/client/{clientId}?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (entityName === null)
            throw new Error("The parameter 'entityName' cannot be null.");
        else if (entityName !== undefined)
            url_ += "entityName=" + encodeURIComponent("" + entityName) + "&";
        if (propertyName === null)
            throw new Error("The parameter 'propertyName' cannot be null.");
        else if (propertyName !== undefined)
            url_ += "propertyName=" + encodeURIComponent("" + propertyName) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryPropertiesDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryPropertiesDtoPaginatedList>;
        }));
    }

    protected processClient(response: HttpResponseBase): Observable<HistoryPropertiesDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryPropertiesDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryPropertiesDtoPaginatedList>(null as any);
    }
}

@Injectable()
export class HubSpotCardDataFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    workflows(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Workflows?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processWorkflows(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    requests(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Requests?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequests(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    contactPerson(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/ContactPerson?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContactPerson(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    camLoginLink(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/CamLoginLink?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamLoginLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamLoginLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotContractFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    listContracts(userId?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotContractFetch/ListContracts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListContracts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processListContracts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotInstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    generateInstallationUrl(): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/generate-installation-url";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateInstallationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateInstallationUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerateInstallationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    auth(code?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/auth?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    syncAllWithHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncAllWithHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllWithHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllWithHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncAllWithHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    syncClientParents(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncClientParents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncClientParents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncClientParents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncClientParents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param showAll (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    employees(filter?: string | undefined, showAll?: boolean | undefined, idsToExclude?: number[] | undefined): Observable<EmployeeSearchEmployeeDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Employees?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (showAll === null)
            throw new Error("The parameter 'showAll' cannot be null.");
        else if (showAll !== undefined)
            url_ += "showAll=" + encodeURIComponent("" + showAll) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeSearchEmployeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeSearchEmployeeDto[]>;
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<EmployeeSearchEmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeSearchEmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeSearchEmployeeDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    consultants(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<ConsultantResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Consultants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantResultDto[]>;
        }));
    }

    protected processConsultants(response: HttpResponseBase): Observable<ConsultantResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantResultDto[]>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    consultantsWithSourcingRequest(clientId?: number | undefined, filter?: string | undefined, maxRecords?: number | undefined): Observable<ConsultantWithSourcingRequestResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Consultants-With-Sourcing-Request?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantsWithSourcingRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantsWithSourcingRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantWithSourcingRequestResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantWithSourcingRequestResultDto[]>;
        }));
    }

    protected processConsultantsWithSourcingRequest(response: HttpResponseBase): Observable<ConsultantWithSourcingRequestResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantWithSourcingRequestResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantWithSourcingRequestResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    suppliers(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<SupplierResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Suppliers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierResultDto[]>;
        }));
    }

    protected processSuppliers(response: HttpResponseBase): Observable<SupplierResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    clientsAll(filter?: string | undefined, maxRecords?: number | undefined): Observable<ClientResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Clients?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientResultDto[]>;
        }));
    }

    protected processClientsAll(response: HttpResponseBase): Observable<ClientResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientResultDto[]>(null as any);
    }

    /**
     * @param clientIds (optional) 
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    contacts(clientIds?: number[] | undefined, filter?: string | undefined, maxRecords?: number | undefined): Observable<ContactResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Contacts?";
        if (clientIds === null)
            throw new Error("The parameter 'clientIds' cannot be null.");
        else if (clientIds !== undefined)
            clientIds && clientIds.forEach(item => { url_ += "clientIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactResultDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    signerContacts(filter?: string | undefined, maxRecords?: number | undefined): Observable<ContactSignerResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/SignerContacts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactSignerResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactSignerResultDto[]>;
        }));
    }

    protected processSignerContacts(response: HttpResponseBase): Observable<ContactSignerResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSignerResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactSignerResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param supplierId (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    signerSupplierMembers(filter?: string | undefined, supplierId?: number | undefined, maxRecords?: number | undefined): Observable<SupplierMemberResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/SignerSupplierMembers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "supplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerSupplierMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerSupplierMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierMemberResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierMemberResultDto[]>;
        }));
    }

    protected processSignerSupplierMembers(response: HttpResponseBase): Observable<SupplierMemberResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierMemberResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierMemberResultDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tree(): Observable<RoleTreeDto> {
        let url_ = this.baseUrl + "/api/Lookup/ProfessionalRoles/Tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleTreeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleTreeDto>;
        }));
    }

    protected processTree(response: HttpResponseBase): Observable<RoleTreeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleTreeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleTreeDto>(null as any);
    }
}

@Injectable()
export class MainOverviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param mainOverviewStatusesForSales (optional) 
     * @param accountManagers (optional) 
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param margins (optional) 
     * @param search (optional) 
     * @param cutOffDate (optional) 
     * @param showDeleted (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflows(mainOverviewStatusesForSales?: MainOverviewStatus[] | undefined, accountManagers?: number[] | undefined, invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, margins?: number[] | undefined, search?: string | undefined, cutOffDate?: moment.Moment | undefined, showDeleted?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<MainOverviewItemForWorkflowDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/MainOverview/workflows?";
        if (mainOverviewStatusesForSales === null)
            throw new Error("The parameter 'mainOverviewStatusesForSales' cannot be null.");
        else if (mainOverviewStatusesForSales !== undefined)
            mainOverviewStatusesForSales && mainOverviewStatusesForSales.forEach(item => { url_ += "MainOverviewStatusesForSales=" + encodeURIComponent("" + item) + "&"; });
        if (accountManagers === null)
            throw new Error("The parameter 'accountManagers' cannot be null.");
        else if (accountManagers !== undefined)
            accountManagers && accountManagers.forEach(item => { url_ += "AccountManagers=" + encodeURIComponent("" + item) + "&"; });
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (margins === null)
            throw new Error("The parameter 'margins' cannot be null.");
        else if (margins !== undefined)
            margins && margins.forEach(item => { url_ += "Margins=" + encodeURIComponent("" + item) + "&"; });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (cutOffDate === null)
            throw new Error("The parameter 'cutOffDate' cannot be null.");
        else if (cutOffDate !== undefined)
            url_ += "CutOffDate=" + encodeURIComponent(cutOffDate ? "" + cutOffDate.toISOString() : "") + "&";
        if (showDeleted === null)
            throw new Error("The parameter 'showDeleted' cannot be null.");
        else if (showDeleted !== undefined)
            url_ += "ShowDeleted=" + encodeURIComponent("" + showDeleted) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewItemForWorkflowDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewItemForWorkflowDtoPaginatedList>;
        }));
    }

    protected processWorkflows(response: HttpResponseBase): Observable<MainOverviewItemForWorkflowDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainOverviewItemForWorkflowDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewItemForWorkflowDtoPaginatedList>(null as any);
    }

    /**
     * @param mainOverviewStatusesForSales (optional) 
     * @param accountManagers (optional) 
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesTypes (optional) 
     * @param deliveryTypes (optional) 
     * @param margins (optional) 
     * @param search (optional) 
     * @param cutOffDate (optional) 
     * @param showDeleted (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    consultants(mainOverviewStatusesForSales?: MainOverviewStatus[] | undefined, accountManagers?: number[] | undefined, invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesTypes?: number[] | undefined, deliveryTypes?: number[] | undefined, margins?: number[] | undefined, search?: string | undefined, cutOffDate?: moment.Moment | undefined, showDeleted?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<MainOverviewItemForConsultantDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/MainOverview/consultants?";
        if (mainOverviewStatusesForSales === null)
            throw new Error("The parameter 'mainOverviewStatusesForSales' cannot be null.");
        else if (mainOverviewStatusesForSales !== undefined)
            mainOverviewStatusesForSales && mainOverviewStatusesForSales.forEach(item => { url_ += "MainOverviewStatusesForSales=" + encodeURIComponent("" + item) + "&"; });
        if (accountManagers === null)
            throw new Error("The parameter 'accountManagers' cannot be null.");
        else if (accountManagers !== undefined)
            accountManagers && accountManagers.forEach(item => { url_ += "AccountManagers=" + encodeURIComponent("" + item) + "&"; });
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesTypes === null)
            throw new Error("The parameter 'salesTypes' cannot be null.");
        else if (salesTypes !== undefined)
            salesTypes && salesTypes.forEach(item => { url_ += "SalesTypes=" + encodeURIComponent("" + item) + "&"; });
        if (deliveryTypes === null)
            throw new Error("The parameter 'deliveryTypes' cannot be null.");
        else if (deliveryTypes !== undefined)
            deliveryTypes && deliveryTypes.forEach(item => { url_ += "DeliveryTypes=" + encodeURIComponent("" + item) + "&"; });
        if (margins === null)
            throw new Error("The parameter 'margins' cannot be null.");
        else if (margins !== undefined)
            margins && margins.forEach(item => { url_ += "Margins=" + encodeURIComponent("" + item) + "&"; });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (cutOffDate === null)
            throw new Error("The parameter 'cutOffDate' cannot be null.");
        else if (cutOffDate !== undefined)
            url_ += "CutOffDate=" + encodeURIComponent(cutOffDate ? "" + cutOffDate.toISOString() : "") + "&";
        if (showDeleted === null)
            throw new Error("The parameter 'showDeleted' cannot be null.");
        else if (showDeleted !== undefined)
            url_ += "ShowDeleted=" + encodeURIComponent("" + showDeleted) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewItemForConsultantDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewItemForConsultantDtoPaginatedList>;
        }));
    }

    protected processConsultants(response: HttpResponseBase): Observable<MainOverviewItemForConsultantDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainOverviewItemForConsultantDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewItemForConsultantDtoPaginatedList>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @param mainOverviewUserSelectedStatusForSales (optional) 
     * @return Success
     */
    setUserSelectedStatusForWorkflow(workflowId?: string | undefined, mainOverviewUserSelectedStatusForSales?: MainOverviewStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MainOverview/setUserSelectedStatusForWorkflow?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (mainOverviewUserSelectedStatusForSales === null)
            throw new Error("The parameter 'mainOverviewUserSelectedStatusForSales' cannot be null.");
        else if (mainOverviewUserSelectedStatusForSales !== undefined)
            url_ += "MainOverviewUserSelectedStatusForSales=" + encodeURIComponent("" + mainOverviewUserSelectedStatusForSales) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserSelectedStatusForWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserSelectedStatusForWorkflow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserSelectedStatusForWorkflow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @param consultantId (optional) 
     * @param mainOverviewUserSelectedStatusForSales (optional) 
     * @return Success
     */
    setUserSelectedStatusForConsultant(workflowId?: string | undefined, consultantId?: number | undefined, mainOverviewUserSelectedStatusForSales?: MainOverviewStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MainOverview/setUserSelectedStatusForConsultant?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "ConsultantId=" + encodeURIComponent("" + consultantId) + "&";
        if (mainOverviewUserSelectedStatusForSales === null)
            throw new Error("The parameter 'mainOverviewUserSelectedStatusForSales' cannot be null.");
        else if (mainOverviewUserSelectedStatusForSales !== undefined)
            url_ += "MainOverviewUserSelectedStatusForSales=" + encodeURIComponent("" + mainOverviewUserSelectedStatusForSales) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserSelectedStatusForConsultant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserSelectedStatusForConsultant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserSelectedStatusForConsultant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    viewTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/MainOverview/view-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processViewTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    statuses(): Observable<MainOverviewStatusDto[]> {
        let url_ = this.baseUrl + "/api/MainOverview/statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MainOverviewStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MainOverviewStatusDto[]>;
        }));
    }

    protected processStatuses(response: HttpResponseBase): Observable<MainOverviewStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MainOverviewStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainOverviewStatusDto[]>(null as any);
    }
}

@Injectable()
export class MergeFieldsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    agreementTemplate(agreementTemplateId: number): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/MergeFields/agreementTemplate/{agreementTemplateId}";
        if (agreementTemplateId === undefined || agreementTemplateId === null)
            throw new Error("The parameter 'agreementTemplateId' must be defined.");
        url_ = url_.replace("{agreementTemplateId}", encodeURIComponent("" + agreementTemplateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreementTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreementTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreementTemplate(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    agreement(agreementId: number): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/MergeFields/agreement/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgreement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processAgreement(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    fields(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/MergeFields/agreementNameTemplate/fields";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processFields(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param agreementId (optional) 
     * @param agreementNameTemplate (optional) 
     * @return Success
     */
    format(agreementId?: number | undefined, agreementNameTemplate?: string | undefined): Observable<StringWrappedValueDto> {
        let url_ = this.baseUrl + "/api/MergeFields/agreementNameTemplate/format?";
        if (agreementId === null)
            throw new Error("The parameter 'agreementId' cannot be null.");
        else if (agreementId !== undefined)
            url_ += "AgreementId=" + encodeURIComponent("" + agreementId) + "&";
        if (agreementNameTemplate === null)
            throw new Error("The parameter 'agreementNameTemplate' cannot be null.");
        else if (agreementNameTemplate !== undefined)
            url_ += "AgreementNameTemplate=" + encodeURIComponent("" + agreementNameTemplate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringWrappedValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringWrappedValueDto>;
        }));
    }

    protected processFormat(response: HttpResponseBase): Observable<StringWrappedValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringWrappedValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringWrappedValueDto>(null as any);
    }
}

@Injectable()
export class PurchaseOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPurchaseOrdersForWorkflowOverview(workflowId: string): Observable<PurchaseOrderDto[]> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/getPurchaseOrdersForWorkflowOverview/{workflowId}";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersForWorkflowOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersForWorkflowOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrderDto[]>;
        }));
    }

    protected processGetPurchaseOrdersForWorkflowOverview(response: HttpResponseBase): Observable<PurchaseOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PurchaseOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getPurchaseOrdersAvailableForClientPeriod(clientPeriodId: string, directClientId: number): Observable<PurchaseOrderDto[]> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/getPurchaseOrdersAvailableForClientPeriod/{clientPeriodId}/{directClientId}";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        if (directClientId === undefined || directClientId === null)
            throw new Error("The parameter 'directClientId' must be defined.");
        url_ = url_.replace("{directClientId}", encodeURIComponent("" + directClientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersAvailableForClientPeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersAvailableForClientPeriod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrderDto[]>;
        }));
    }

    protected processGetPurchaseOrdersAvailableForClientPeriod(response: HttpResponseBase): Observable<PurchaseOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PurchaseOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchaseOrderPOST(currentClientPeriodId: string, body?: PurchaseOrderDto | undefined): Observable<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/{currentClientPeriodId}";
        if (currentClientPeriodId === undefined || currentClientPeriodId === null)
            throw new Error("The parameter 'currentClientPeriodId' must be defined.");
        url_ = url_.replace("{currentClientPeriodId}", encodeURIComponent("" + currentClientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchaseOrderPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchaseOrderPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrderDto>;
        }));
    }

    protected processPurchaseOrderPOST(response: HttpResponseBase): Observable<PurchaseOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchaseOrderPUT(currentClientPeriodId: string, body?: PurchaseOrderDto | undefined): Observable<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/{currentClientPeriodId}";
        if (currentClientPeriodId === undefined || currentClientPeriodId === null)
            throw new Error("The parameter 'currentClientPeriodId' must be defined.");
        url_ = url_.replace("{currentClientPeriodId}", encodeURIComponent("" + currentClientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchaseOrderPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchaseOrderPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrderDto>;
        }));
    }

    protected processPurchaseOrderPUT(response: HttpResponseBase): Observable<PurchaseOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderDto>(null as any);
    }
}

@Injectable()
export class TenantConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    workflowStepEmployeeAssignments(): Observable<TenantConfigDto[]> {
        let url_ = this.baseUrl + "/api/TenantConfig/workflow-step-employee-assignments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowStepEmployeeAssignments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowStepEmployeeAssignments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantConfigDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantConfigDto[]>;
        }));
    }

    protected processWorkflowStepEmployeeAssignments(response: HttpResponseBase): Observable<TenantConfigDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantConfigDto[]>(null as any);
    }
}

@Injectable()
export class TestDocuSignServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    testDocuSign(body?: SendToDocuSignTestCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TestDocuSign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestDocuSign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestDocuSign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processTestDocuSign(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class TestHubSpotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testCreateClientInHubSpot(): Observable<SimplePublicObject> {
        let url_ = this.baseUrl + "/api/TestHubSpot/TestCreateClientInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCreateClientInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCreateClientInHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimplePublicObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimplePublicObject>;
        }));
    }

    protected processTestCreateClientInHubSpot(response: HttpResponseBase): Observable<SimplePublicObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimplePublicObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePublicObject>(null as any);
    }

    /**
     * @return Success
     */
    testSyncUpdateToLegacy(): Observable<void> {
        let url_ = this.baseUrl + "/api/TestHubSpot/TestSyncUpdateToLegacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSyncUpdateToLegacy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSyncUpdateToLegacy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSyncUpdateToLegacy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getBigCompany(): Observable<HubSpotClientDto> {
        let url_ = this.baseUrl + "/api/TestHubSpot/GetBigCompanyAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBigCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBigCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubSpotClientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubSpotClientDto>;
        }));
    }

    protected processGetBigCompany(response: HttpResponseBase): Observable<HubSpotClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HubSpotClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HubSpotClientDto>(null as any);
    }
}

@Injectable()
export class TestNotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendActionRequired(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TestNotification/send-action-required?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendActionRequired(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendActionRequired(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendActionRequired(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendContractExpiration(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TestNotification/send-contract-expiration?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendContractExpiration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendContractExpiration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendContractExpiration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendConsultantExtension(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TestNotification/send-consultant-extension?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendConsultantExtension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendConsultantExtension(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendConsultantExtension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendWorkflowStepResponsibleChanged(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TestNotification/send-Workflow-Step-Responsible-Changed?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendWorkflowStepResponsibleChanged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendWorkflowStepResponsibleChanged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendWorkflowStepResponsibleChanged(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TestPdfExportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    testPdfExport(file?: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TestPdfExport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestPdfExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestPdfExport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestPdfExport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TestSignalRServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    testSignalR(value?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/test/TestSignalR?";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSignalR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSignalR(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSignalR(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    permissions(): Observable<ClientApplicationPermissionsModel> {
        let url_ = this.baseUrl + "/api/UserManagement/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientApplicationPermissionsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientApplicationPermissionsModel>;
        }));
    }

    protected processPermissions(response: HttpResponseBase): Observable<ClientApplicationPermissionsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientApplicationPermissionsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientApplicationPermissionsModel>(null as any);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param invoicingEntity (optional) 
     * @param paymentEntity (optional) 
     * @param salesType (optional) 
     * @param deliveryType (optional) 
     * @param workflowStatus (optional) 
     * @param responsibleEmployees (optional) 
     * @param syncStateStatuses (optional) 
     * @param showNewSales (optional) 
     * @param showExtensions (optional) 
     * @param showPendingSteps (optional) 
     * @param showPendingStepType (optional) 
     * @param showUpcomingSteps (optional) 
     * @param showUpcomingStepType (optional) 
     * @param showCompleted (optional) 
     * @param showDeleted (optional) 
     * @param showWorkflowsWithProjectLinesMarkedAsPoMissing (optional) 
     * @param search (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    workflow(invoicingEntity?: number | undefined, paymentEntity?: number | undefined, salesType?: number | undefined, deliveryType?: number | undefined, workflowStatus?: WorkflowStatus | undefined, responsibleEmployees?: number[] | undefined, syncStateStatuses?: SyncStateStatus[] | undefined, showNewSales?: boolean | undefined, showExtensions?: boolean | undefined, showPendingSteps?: boolean | undefined, showPendingStepType?: StepType | undefined, showUpcomingSteps?: boolean | undefined, showUpcomingStepType?: StepType | undefined, showCompleted?: boolean | undefined, showDeleted?: boolean | undefined, showWorkflowsWithProjectLinesMarkedAsPoMissing?: boolean | undefined, search?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<WorkflowListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Workflow?";
        if (invoicingEntity === null)
            throw new Error("The parameter 'invoicingEntity' cannot be null.");
        else if (invoicingEntity !== undefined)
            url_ += "InvoicingEntity=" + encodeURIComponent("" + invoicingEntity) + "&";
        if (paymentEntity === null)
            throw new Error("The parameter 'paymentEntity' cannot be null.");
        else if (paymentEntity !== undefined)
            url_ += "PaymentEntity=" + encodeURIComponent("" + paymentEntity) + "&";
        if (salesType === null)
            throw new Error("The parameter 'salesType' cannot be null.");
        else if (salesType !== undefined)
            url_ += "SalesType=" + encodeURIComponent("" + salesType) + "&";
        if (deliveryType === null)
            throw new Error("The parameter 'deliveryType' cannot be null.");
        else if (deliveryType !== undefined)
            url_ += "DeliveryType=" + encodeURIComponent("" + deliveryType) + "&";
        if (workflowStatus === null)
            throw new Error("The parameter 'workflowStatus' cannot be null.");
        else if (workflowStatus !== undefined)
            url_ += "WorkflowStatus=" + encodeURIComponent("" + workflowStatus) + "&";
        if (responsibleEmployees === null)
            throw new Error("The parameter 'responsibleEmployees' cannot be null.");
        else if (responsibleEmployees !== undefined)
            responsibleEmployees && responsibleEmployees.forEach(item => { url_ += "ResponsibleEmployees=" + encodeURIComponent("" + item) + "&"; });
        if (syncStateStatuses === null)
            throw new Error("The parameter 'syncStateStatuses' cannot be null.");
        else if (syncStateStatuses !== undefined)
            syncStateStatuses && syncStateStatuses.forEach(item => { url_ += "SyncStateStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (showNewSales === null)
            throw new Error("The parameter 'showNewSales' cannot be null.");
        else if (showNewSales !== undefined)
            url_ += "ShowNewSales=" + encodeURIComponent("" + showNewSales) + "&";
        if (showExtensions === null)
            throw new Error("The parameter 'showExtensions' cannot be null.");
        else if (showExtensions !== undefined)
            url_ += "ShowExtensions=" + encodeURIComponent("" + showExtensions) + "&";
        if (showPendingSteps === null)
            throw new Error("The parameter 'showPendingSteps' cannot be null.");
        else if (showPendingSteps !== undefined)
            url_ += "ShowPendingSteps=" + encodeURIComponent("" + showPendingSteps) + "&";
        if (showPendingStepType === null)
            throw new Error("The parameter 'showPendingStepType' cannot be null.");
        else if (showPendingStepType !== undefined)
            url_ += "ShowPendingStepType=" + encodeURIComponent("" + showPendingStepType) + "&";
        if (showUpcomingSteps === null)
            throw new Error("The parameter 'showUpcomingSteps' cannot be null.");
        else if (showUpcomingSteps !== undefined)
            url_ += "ShowUpcomingSteps=" + encodeURIComponent("" + showUpcomingSteps) + "&";
        if (showUpcomingStepType === null)
            throw new Error("The parameter 'showUpcomingStepType' cannot be null.");
        else if (showUpcomingStepType !== undefined)
            url_ += "ShowUpcomingStepType=" + encodeURIComponent("" + showUpcomingStepType) + "&";
        if (showCompleted === null)
            throw new Error("The parameter 'showCompleted' cannot be null.");
        else if (showCompleted !== undefined)
            url_ += "ShowCompleted=" + encodeURIComponent("" + showCompleted) + "&";
        if (showDeleted === null)
            throw new Error("The parameter 'showDeleted' cannot be null.");
        else if (showDeleted !== undefined)
            url_ += "ShowDeleted=" + encodeURIComponent("" + showDeleted) + "&";
        if (showWorkflowsWithProjectLinesMarkedAsPoMissing === null)
            throw new Error("The parameter 'showWorkflowsWithProjectLinesMarkedAsPoMissing' cannot be null.");
        else if (showWorkflowsWithProjectLinesMarkedAsPoMissing !== undefined)
            url_ += "ShowWorkflowsWithProjectLinesMarkedAsPoMissing=" + encodeURIComponent("" + showWorkflowsWithProjectLinesMarkedAsPoMissing) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowListItemDtoPaginatedList>;
        }));
    }

    protected processWorkflow(response: HttpResponseBase): Observable<WorkflowListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param workflowId (optional) 
     * @param workflowStatus (optional) 
     * @return Success
     */
    setWorkflowStatus(workflowId?: string | undefined, workflowStatus?: WorkflowStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/set-workflow-status?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "WorkflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (workflowStatus === null)
            throw new Error("The parameter 'workflowStatus' cannot be null.");
        else if (workflowStatus !== undefined)
            url_ += "WorkflowStatus=" + encodeURIComponent("" + workflowStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWorkflowStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWorkflowStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetWorkflowStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartNewWorkflowInputDto | undefined): Observable<NewWorkflowCreatedDto> {
        let url_ = this.baseUrl + "/api/Workflow/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewWorkflowCreatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewWorkflowCreatedDto>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<NewWorkflowCreatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewWorkflowCreatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewWorkflowCreatedDto>(null as any);
    }

    /**
     * @return Success
     */
    workflowExists(requestConsultantId: number): Observable<WorkflowAlreadyExistsDto> {
        let url_ = this.baseUrl + "/api/Workflow/{requestConsultantId}/workflow-exists";
        if (requestConsultantId === undefined || requestConsultantId === null)
            throw new Error("The parameter 'requestConsultantId' must be defined.");
        url_ = url_.replace("{requestConsultantId}", encodeURIComponent("" + requestConsultantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowAlreadyExistsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowAlreadyExistsDto>;
        }));
    }

    protected processWorkflowExists(response: HttpResponseBase): Observable<WorkflowAlreadyExistsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowAlreadyExistsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowAlreadyExistsDto>(null as any);
    }

    /**
     * @param clientPeriodId (optional) 
     * @param includeProcesses (optional) 
     * @return Success
     */
    clientPeriods(workflowId: string, clientPeriodId?: string | undefined, includeProcesses?: boolean | undefined): Observable<WorkflowDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/clientPeriods?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' cannot be null.");
        else if (clientPeriodId !== undefined)
            url_ += "clientPeriodId=" + encodeURIComponent("" + clientPeriodId) + "&";
        if (includeProcesses === null)
            throw new Error("The parameter 'includeProcesses' cannot be null.");
        else if (includeProcesses !== undefined)
            url_ += "includeProcesses=" + encodeURIComponent("" + includeProcesses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowDto>;
        }));
    }

    protected processClientPeriods(response: HttpResponseBase): Observable<WorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowDto>(null as any);
    }

    /**
     * @return Success
     */
    overview(workflowId: string): Observable<WorkflowOverviewDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/overview";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowOverviewDto>;
        }));
    }

    protected processOverview(response: HttpResponseBase): Observable<WorkflowOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowOverviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowOverviewDto>(null as any);
    }

    /**
     * @return Success
     */
    notesGET(workflowId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/notes";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processNotesGET(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notesPUT(workflowId: string, body?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/notes";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNotesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationStart(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-start";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getCategoryForMigrate(workflowId: string): Observable<CategoryForMigrateDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/get-category-for-migrate";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryForMigrate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryForMigrate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryForMigrateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryForMigrateDto>;
        }));
    }

    protected processGetCategoryForMigrate(response: HttpResponseBase): Observable<CategoryForMigrateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryForMigrateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryForMigrateDto>(null as any);
    }

    /**
     * @return Success
     */
    terminationSalesGET(workflowId: string): Observable<WorkflowTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationSalesGET(response: HttpResponseBase): Observable<WorkflowTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesPUT(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesComplete(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSalesReopen(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales-reopen";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesReopen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesReopen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesReopen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractGET(workflowId: string): Observable<WorkflowTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationContractGET(response: HttpResponseBase): Observable<WorkflowTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractPUT(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractComplete(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingGET(workflowId: string): Observable<WorkflowTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationSourcingGET(response: HttpResponseBase): Observable<WorkflowTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingPUT(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingComplete(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    terminationStepResponsible(workflowId: string, stepType: StepType, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/{stepType}/termination-step-responsible?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationDelete(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantStart(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-start?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSalesGET(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSalesGET(response: HttpResponseBase): Observable<ConsultantTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesPUT(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesComplete(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales-complete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSalesReopen(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales-reopen?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesReopen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesReopen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesReopen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractGET(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationConsultantContractGET(response: HttpResponseBase): Observable<ConsultantTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractPUT(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractComplete(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingGET(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSourcingGET(response: HttpResponseBase): Observable<ConsultantTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingPUT(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingComplete(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantTerminationId (optional) 
     * @param newResponsibleEmployeeId (optional) 
     * @return Success
     */
    terminationConsultantStepResponsible(stepType: StepType, workflowId: string, consultantTerminationId?: string | undefined, newResponsibleEmployeeId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/{stepType}/termination-consultant-step-responsible?";
        if (stepType === undefined || stepType === null)
            throw new Error("The parameter 'stepType' must be defined.");
        url_ = url_.replace("{stepType}", encodeURIComponent("" + stepType));
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantTerminationId === null)
            throw new Error("The parameter 'consultantTerminationId' cannot be null.");
        else if (consultantTerminationId !== undefined)
            url_ += "consultantTerminationId=" + encodeURIComponent("" + consultantTerminationId) + "&";
        if (newResponsibleEmployeeId === null)
            throw new Error("The parameter 'newResponsibleEmployeeId' cannot be null.");
        else if (newResponsibleEmployeeId !== undefined)
            url_ += "newResponsibleEmployeeId=" + encodeURIComponent("" + newResponsibleEmployeeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantStepResponsible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantStepResponsible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantStepResponsible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantDelete(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-delete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete3(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    restore(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/restore";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkflowDocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param clientPeriodId (optional) 
     * @return Success
     */
    overviewAll(workflowId: string, clientPeriodId?: string | undefined): Observable<WorkflowDocumentQueryDto[]> {
        let url_ = this.baseUrl + "/api/WorkflowDocument/overview/{workflowId}?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' cannot be null.");
        else if (clientPeriodId !== undefined)
            url_ += "clientPeriodId=" + encodeURIComponent("" + clientPeriodId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOverviewAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOverviewAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowDocumentQueryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowDocumentQueryDto[]>;
        }));
    }

    protected processOverviewAll(response: HttpResponseBase): Observable<WorkflowDocumentQueryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowDocumentQueryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    workflowDocumentGET(workflowDocumentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkflowDocument/{workflowDocumentId}";
        if (workflowDocumentId === undefined || workflowDocumentId === null)
            throw new Error("The parameter 'workflowDocumentId' must be defined.");
        url_ = url_.replace("{workflowDocumentId}", encodeURIComponent("" + workflowDocumentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowDocumentGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowDocumentGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkflowDocumentGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    workflowDocumentDELETE(workflowDocumentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkflowDocument/{workflowDocumentId}";
        if (workflowDocumentId === undefined || workflowDocumentId === null)
            throw new Error("The parameter 'workflowDocumentId' must be defined.");
        url_ = url_.replace("{workflowDocumentId}", encodeURIComponent("" + workflowDocumentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowDocumentDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowDocumentDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkflowDocumentDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkflowIntegrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isInternalContract (optional) 
     * @param pm3ConsultantId (optional) 
     * @return Success
     */
    workflowIntegration(periodId: string, isInternalContract?: boolean | undefined, pm3ConsultantId?: number | undefined): Observable<WorkflowPeriodForLegacyContractDto> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/{periodId}?";
        if (periodId === undefined || periodId === null)
            throw new Error("The parameter 'periodId' must be defined.");
        url_ = url_.replace("{periodId}", encodeURIComponent("" + periodId));
        if (isInternalContract === null)
            throw new Error("The parameter 'isInternalContract' cannot be null.");
        else if (isInternalContract !== undefined)
            url_ += "isInternalContract=" + encodeURIComponent("" + isInternalContract) + "&";
        if (pm3ConsultantId === null)
            throw new Error("The parameter 'pm3ConsultantId' cannot be null.");
        else if (pm3ConsultantId !== undefined)
            url_ += "pm3ConsultantId=" + encodeURIComponent("" + pm3ConsultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowIntegration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowIntegration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowPeriodForLegacyContractDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowPeriodForLegacyContractDto>;
        }));
    }

    protected processWorkflowIntegration(response: HttpResponseBase): Observable<WorkflowPeriodForLegacyContractDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowPeriodForLegacyContractDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowPeriodForLegacyContractDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    workflowPeriodLegalContractStatus(body?: WorkflowPeriodLegalContractStatusUpdateInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/WorkflowPeriodLegalContractStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowPeriodLegalContractStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowPeriodLegalContractStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWorkflowPeriodLegalContractStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeCommissionFromOtherTenants (optional) 
     * @param body (optional) 
     * @return Success
     */
    workflowPeriodInfosForIncomeReport(tenantId?: number | undefined, fromDate?: moment.Moment | undefined, toDate?: moment.Moment | undefined, includeCommissionFromOtherTenants?: boolean | undefined, body?: InputWorkflowPeriodInfoForIncomeReportDto[] | undefined): Observable<OutputWorkflowPeriodInfoForIncomeReportDto> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/WorkflowPeriodInfosForIncomeReport?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (includeCommissionFromOtherTenants === null)
            throw new Error("The parameter 'includeCommissionFromOtherTenants' cannot be null.");
        else if (includeCommissionFromOtherTenants !== undefined)
            url_ += "includeCommissionFromOtherTenants=" + encodeURIComponent("" + includeCommissionFromOtherTenants) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowPeriodInfosForIncomeReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowPeriodInfosForIncomeReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputWorkflowPeriodInfoForIncomeReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputWorkflowPeriodInfoForIncomeReportDto>;
        }));
    }

    protected processWorkflowPeriodInfosForIncomeReport(response: HttpResponseBase): Observable<OutputWorkflowPeriodInfoForIncomeReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputWorkflowPeriodInfoForIncomeReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputWorkflowPeriodInfoForIncomeReportDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getWorkflowPeriodInfoForEvaluations(body?: number[] | undefined): Observable<WorkflowPeriodInfoForEvaluationDto[]> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/GetWorkflowPeriodInfoForEvaluations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkflowPeriodInfoForEvaluations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkflowPeriodInfoForEvaluations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowPeriodInfoForEvaluationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowPeriodInfoForEvaluationDto[]>;
        }));
    }

    protected processGetWorkflowPeriodInfoForEvaluations(response: HttpResponseBase): Observable<WorkflowPeriodInfoForEvaluationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowPeriodInfoForEvaluationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowPeriodInfoForEvaluationDto[]>(null as any);
    }

    /**
     * @param tenantIdForAllLegacyClientIds (optional) 
     * @param includeExpiredPeriods (optional) 
     * @param body (optional) 
     * @return Success
     */
    getConsultantPeriodInfoBasicsForLegacyClient(tenantIdForAllLegacyClientIds?: number | undefined, includeExpiredPeriods?: boolean | undefined, body?: number[] | undefined): Observable<ConsultantPeriodMainDataBasicDto[]> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/GetConsultantPeriodInfoBasicsForLegacyClient?";
        if (tenantIdForAllLegacyClientIds === null)
            throw new Error("The parameter 'tenantIdForAllLegacyClientIds' cannot be null.");
        else if (tenantIdForAllLegacyClientIds !== undefined)
            url_ += "tenantIdForAllLegacyClientIds=" + encodeURIComponent("" + tenantIdForAllLegacyClientIds) + "&";
        if (includeExpiredPeriods === null)
            throw new Error("The parameter 'includeExpiredPeriods' cannot be null.");
        else if (includeExpiredPeriods !== undefined)
            url_ += "includeExpiredPeriods=" + encodeURIComponent("" + includeExpiredPeriods) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsultantPeriodInfoBasicsForLegacyClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsultantPeriodInfoBasicsForLegacyClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantPeriodMainDataBasicDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantPeriodMainDataBasicDto[]>;
        }));
    }

    protected processGetConsultantPeriodInfoBasicsForLegacyClient(response: HttpResponseBase): Observable<ConsultantPeriodMainDataBasicDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantPeriodMainDataBasicDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantPeriodMainDataBasicDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    projectLineUpdate(body?: UpdateProjectLineFromLegacyCommand | undefined): Observable<None> {
        let url_ = this.baseUrl + "/api/WorkflowIntegration/ProjectLineUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectLineUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectLineUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<None>;
                }
            } else
                return _observableThrow(response_) as any as Observable<None>;
        }));
    }

    protected processProjectLineUpdate(response: HttpResponseBase): Observable<None> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = None.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<None>(null as any);
    }
}

export class AddClientSpecialFeeDto implements IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AddClientSpecialRateDto implements IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AgreementAttachmentDto implements IAgreementAttachmentDto {
    agreementAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAgreementAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementAttachmentId = _data["agreementAttachmentId"];
            this.temporaryFileId = _data["temporaryFileId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementAttachmentId"] = this.agreementAttachmentId;
        data["temporaryFileId"] = this.temporaryFileId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementAttachmentDto {
    agreementAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;
}

export class AgreementAuxiliaryAttachmentDto implements IAgreementAuxiliaryAttachmentDto {
    agreementAuxiliaryAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAgreementAuxiliaryAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementAuxiliaryAttachmentId = _data["agreementAuxiliaryAttachmentId"];
            this.temporaryFileId = _data["temporaryFileId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementAuxiliaryAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementAuxiliaryAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementAuxiliaryAttachmentId"] = this.agreementAuxiliaryAttachmentId;
        data["temporaryFileId"] = this.temporaryFileId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementAuxiliaryAttachmentDto {
    agreementAuxiliaryAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;
}

export class AgreementAuxiliaryDetailsAttachmentDto implements IAgreementAuxiliaryDetailsAttachmentDto {
    agreementAuxiliaryAttachmentId?: number;
    name?: string | undefined;

    constructor(data?: IAgreementAuxiliaryDetailsAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementAuxiliaryAttachmentId = _data["agreementAuxiliaryAttachmentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementAuxiliaryDetailsAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementAuxiliaryDetailsAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementAuxiliaryAttachmentId"] = this.agreementAuxiliaryAttachmentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementAuxiliaryDetailsAttachmentDto {
    agreementAuxiliaryAttachmentId?: number;
    name?: string | undefined;
}

export class AgreementAuxiliaryDetailsDto implements IAgreementAuxiliaryDetailsDto {
    auxiliaryAttachments?: AgreementAuxiliaryDetailsAttachmentDto[] | undefined;

    constructor(data?: IAgreementAuxiliaryDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["auxiliaryAttachments"])) {
                this.auxiliaryAttachments = [] as any;
                for (let item of _data["auxiliaryAttachments"])
                    this.auxiliaryAttachments!.push(AgreementAuxiliaryDetailsAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgreementAuxiliaryDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementAuxiliaryDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auxiliaryAttachments)) {
            data["auxiliaryAttachments"] = [];
            for (let item of this.auxiliaryAttachments)
                data["auxiliaryAttachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgreementAuxiliaryDetailsDto {
    auxiliaryAttachments?: AgreementAuxiliaryDetailsAttachmentDto[] | undefined;
}

export class AgreementCommentDto implements IAgreementCommentDto {
    id?: number;
    parentId?: number | undefined;
    text?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    metadata?: string | undefined;

    constructor(data?: IAgreementCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.text = _data["text"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): AgreementCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["text"] = this.text;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface IAgreementCommentDto {
    id?: number;
    parentId?: number | undefined;
    text?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    metadata?: string | undefined;
}

export enum AgreementCreationMode {
    FromScratch = 1,
    InheritedFromParent = 2,
    Duplicated = 3,
    ProvidedByOtherParty = 4,
}

export class AgreementDetailsAttachmentDto implements IAgreementDetailsAttachmentDto {
    agreementAttachmentId?: number;
    name?: string | undefined;

    constructor(data?: IAgreementDetailsAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementAttachmentId = _data["agreementAttachmentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementDetailsAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementAttachmentId"] = this.agreementAttachmentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementDetailsAttachmentDto {
    agreementAttachmentId?: number;
    name?: string | undefined;
}

export class AgreementDetailsDto implements IAgreementDetailsDto {
    agreementId?: number;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateVersion?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementId?: number | undefined;
    duplicationSourceAgreementName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementDetailsSignerDto[] | undefined;
    attachments?: AgreementDetailsAttachmentDto[] | undefined;
    attachmentsFromParent?: ParentAgreementTemplateDetailsAttachmentDto[] | undefined;
    isLocked?: boolean;
    isWorkflowRelated?: boolean;
    saleManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    isReadOnly?: boolean;

    constructor(data?: IAgreementDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.creationMode = _data["creationMode"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.parentAgreementTemplateVersion = _data["parentAgreementTemplateVersion"];
            this.parentAgreementTemplateName = _data["parentAgreementTemplateName"];
            this.duplicationSourceAgreementId = _data["duplicationSourceAgreementId"];
            this.duplicationSourceAgreementName = _data["duplicationSourceAgreementName"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.recipientId = _data["recipientId"];
            this.nameTemplate = _data["nameTemplate"];
            this.definition = _data["definition"];
            this.legalEntityId = _data["legalEntityId"];
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            this.language = _data["language"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(AgreementDetailsSignerDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementDetailsAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsFromParent"])) {
                this.attachmentsFromParent = [] as any;
                for (let item of _data["attachmentsFromParent"])
                    this.attachmentsFromParent!.push(ParentAgreementTemplateDetailsAttachmentDto.fromJS(item));
            }
            this.isLocked = _data["isLocked"];
            this.isWorkflowRelated = _data["isWorkflowRelated"];
            this.saleManager = _data["saleManager"] ? EmployeeDto.fromJS(_data["saleManager"]) : <any>undefined;
            this.contractManager = _data["contractManager"] ? EmployeeDto.fromJS(_data["contractManager"]) : <any>undefined;
            this.consultantName = _data["consultantName"];
            this.companyName = _data["companyName"];
            this.isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): AgreementDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        data["clientPeriodId"] = this.clientPeriodId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["creationMode"] = this.creationMode;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["parentAgreementTemplateVersion"] = this.parentAgreementTemplateVersion;
        data["parentAgreementTemplateName"] = this.parentAgreementTemplateName;
        data["duplicationSourceAgreementId"] = this.duplicationSourceAgreementId;
        data["duplicationSourceAgreementName"] = this.duplicationSourceAgreementName;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["recipientId"] = this.recipientId;
        data["nameTemplate"] = this.nameTemplate;
        data["definition"] = this.definition;
        data["legalEntityId"] = this.legalEntityId;
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        data["language"] = this.language;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["note"] = this.note;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        data["isSignatureRequired"] = this.isSignatureRequired;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsFromParent)) {
            data["attachmentsFromParent"] = [];
            for (let item of this.attachmentsFromParent)
                data["attachmentsFromParent"].push(item.toJSON());
        }
        data["isLocked"] = this.isLocked;
        data["isWorkflowRelated"] = this.isWorkflowRelated;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>undefined;
        data["contractManager"] = this.contractManager ? this.contractManager.toJSON() : <any>undefined;
        data["consultantName"] = this.consultantName;
        data["companyName"] = this.companyName;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }
}

export interface IAgreementDetailsDto {
    agreementId?: number;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateVersion?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementId?: number | undefined;
    duplicationSourceAgreementName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementDetailsSignerDto[] | undefined;
    attachments?: AgreementDetailsAttachmentDto[] | undefined;
    attachmentsFromParent?: ParentAgreementTemplateDetailsAttachmentDto[] | undefined;
    isLocked?: boolean;
    isWorkflowRelated?: boolean;
    saleManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    isReadOnly?: boolean;
}

export class AgreementDetailsPreviewAttachmentDto implements IAgreementDetailsPreviewAttachmentDto {
    agreementAttachmentId?: number;
    name?: string | undefined;

    constructor(data?: IAgreementDetailsPreviewAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementAttachmentId = _data["agreementAttachmentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementDetailsPreviewAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsPreviewAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementAttachmentId"] = this.agreementAttachmentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementDetailsPreviewAttachmentDto {
    agreementAttachmentId?: number;
    name?: string | undefined;
}

export class AgreementDetailsPreviewDto implements IAgreementDetailsPreviewDto {
    agreementId?: number;
    contractNumber?: string | undefined;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateVersion?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementId?: number | undefined;
    duplicationSourceAgreementName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    name?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementDetailsPreviewSignerDto[] | undefined;
    attachments?: AgreementDetailsPreviewAttachmentDto[] | undefined;
    attachmentsFromParent?: AgreementDetailsPreviewTemplateAttachmentDto[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    outdatedMergeFieldsInUse?: boolean;
    agreementStatus?: EnvelopeStatus;
    agreementStatusDate?: moment.Moment | undefined;
    agreementStatusModifier?: EmployeeDto;
    validity?: AgreementValidityState;
    isLocked?: boolean;
    isWorkflowRelated?: boolean;
    saleManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    parentAgreementTemplateIsMasterTemplate?: boolean | undefined;

    constructor(data?: IAgreementDetailsPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
            this.contractNumber = _data["contractNumber"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.creationMode = _data["creationMode"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.parentAgreementTemplateVersion = _data["parentAgreementTemplateVersion"];
            this.parentAgreementTemplateName = _data["parentAgreementTemplateName"];
            this.duplicationSourceAgreementId = _data["duplicationSourceAgreementId"];
            this.duplicationSourceAgreementName = _data["duplicationSourceAgreementName"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.recipientId = _data["recipientId"];
            this.nameTemplate = _data["nameTemplate"];
            this.name = _data["name"];
            this.definition = _data["definition"];
            this.legalEntityId = _data["legalEntityId"];
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            this.language = _data["language"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(AgreementDetailsPreviewSignerDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementDetailsPreviewAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsFromParent"])) {
                this.attachmentsFromParent = [] as any;
                for (let item of _data["attachmentsFromParent"])
                    this.attachmentsFromParent!.push(AgreementDetailsPreviewTemplateAttachmentDto.fromJS(item));
            }
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"] ? EmployeeDto.fromJS(_data["lastUpdatedBy"]) : <any>undefined;
            this.lastUpdateDateUtc = _data["lastUpdateDateUtc"] ? moment(_data["lastUpdateDateUtc"].toString()) : <any>undefined;
            this.outdatedMergeFieldsInUse = _data["outdatedMergeFieldsInUse"];
            this.agreementStatus = _data["agreementStatus"];
            this.agreementStatusDate = _data["agreementStatusDate"] ? moment(_data["agreementStatusDate"].toString()) : <any>undefined;
            this.agreementStatusModifier = _data["agreementStatusModifier"] ? EmployeeDto.fromJS(_data["agreementStatusModifier"]) : <any>undefined;
            this.validity = _data["validity"];
            this.isLocked = _data["isLocked"];
            this.isWorkflowRelated = _data["isWorkflowRelated"];
            this.saleManager = _data["saleManager"] ? EmployeeDto.fromJS(_data["saleManager"]) : <any>undefined;
            this.contractManager = _data["contractManager"] ? EmployeeDto.fromJS(_data["contractManager"]) : <any>undefined;
            this.consultantName = _data["consultantName"];
            this.companyName = _data["companyName"];
            this.parentAgreementTemplateIsMasterTemplate = _data["parentAgreementTemplateIsMasterTemplate"];
        }
    }

    static fromJS(data: any): AgreementDetailsPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        data["contractNumber"] = this.contractNumber;
        data["clientPeriodId"] = this.clientPeriodId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["creationMode"] = this.creationMode;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["parentAgreementTemplateVersion"] = this.parentAgreementTemplateVersion;
        data["parentAgreementTemplateName"] = this.parentAgreementTemplateName;
        data["duplicationSourceAgreementId"] = this.duplicationSourceAgreementId;
        data["duplicationSourceAgreementName"] = this.duplicationSourceAgreementName;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["recipientId"] = this.recipientId;
        data["nameTemplate"] = this.nameTemplate;
        data["name"] = this.name;
        data["definition"] = this.definition;
        data["legalEntityId"] = this.legalEntityId;
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        data["language"] = this.language;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["note"] = this.note;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        data["isSignatureRequired"] = this.isSignatureRequired;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsFromParent)) {
            data["attachmentsFromParent"] = [];
            for (let item of this.attachmentsFromParent)
                data["attachmentsFromParent"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy ? this.lastUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdateDateUtc"] = this.lastUpdateDateUtc ? this.lastUpdateDateUtc.toISOString() : <any>undefined;
        data["outdatedMergeFieldsInUse"] = this.outdatedMergeFieldsInUse;
        data["agreementStatus"] = this.agreementStatus;
        data["agreementStatusDate"] = this.agreementStatusDate ? this.agreementStatusDate.toISOString() : <any>undefined;
        data["agreementStatusModifier"] = this.agreementStatusModifier ? this.agreementStatusModifier.toJSON() : <any>undefined;
        data["validity"] = this.validity;
        data["isLocked"] = this.isLocked;
        data["isWorkflowRelated"] = this.isWorkflowRelated;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>undefined;
        data["contractManager"] = this.contractManager ? this.contractManager.toJSON() : <any>undefined;
        data["consultantName"] = this.consultantName;
        data["companyName"] = this.companyName;
        data["parentAgreementTemplateIsMasterTemplate"] = this.parentAgreementTemplateIsMasterTemplate;
        return data;
    }
}

export interface IAgreementDetailsPreviewDto {
    agreementId?: number;
    contractNumber?: string | undefined;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateVersion?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementId?: number | undefined;
    duplicationSourceAgreementName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    name?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementDetailsPreviewSignerDto[] | undefined;
    attachments?: AgreementDetailsPreviewAttachmentDto[] | undefined;
    attachmentsFromParent?: AgreementDetailsPreviewTemplateAttachmentDto[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    outdatedMergeFieldsInUse?: boolean;
    agreementStatus?: EnvelopeStatus;
    agreementStatusDate?: moment.Moment | undefined;
    agreementStatusModifier?: EmployeeDto;
    validity?: AgreementValidityState;
    isLocked?: boolean;
    isWorkflowRelated?: boolean;
    saleManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    parentAgreementTemplateIsMasterTemplate?: boolean | undefined;
}

export class AgreementDetailsPreviewSignerDto implements IAgreementDetailsPreviewSignerDto {
    agreementSignerId?: number;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;

    constructor(data?: IAgreementDetailsPreviewSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementSignerId = _data["agreementSignerId"];
            this.signerType = _data["signerType"];
            this.signerId = _data["signerId"];
            this.roleId = _data["roleId"];
            this.signOrder = _data["signOrder"];
        }
    }

    static fromJS(data: any): AgreementDetailsPreviewSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsPreviewSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementSignerId"] = this.agreementSignerId;
        data["signerType"] = this.signerType;
        data["signerId"] = this.signerId;
        data["roleId"] = this.roleId;
        data["signOrder"] = this.signOrder;
        return data;
    }
}

export interface IAgreementDetailsPreviewSignerDto {
    agreementSignerId?: number;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;
}

export class AgreementDetailsPreviewTemplateAttachmentDto implements IAgreementDetailsPreviewTemplateAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;

    constructor(data?: IAgreementDetailsPreviewTemplateAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateAttachmentId = _data["agreementTemplateAttachmentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementDetailsPreviewTemplateAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsPreviewTemplateAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateAttachmentId"] = this.agreementTemplateAttachmentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementDetailsPreviewTemplateAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
}

export class AgreementDetailsSignerDto implements IAgreementDetailsSignerDto {
    agreementSignerId?: number;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;

    constructor(data?: IAgreementDetailsSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementSignerId = _data["agreementSignerId"];
            this.signerType = _data["signerType"];
            this.signerId = _data["signerId"];
            this.roleId = _data["roleId"];
            this.signOrder = _data["signOrder"];
        }
    }

    static fromJS(data: any): AgreementDetailsSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDetailsSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementSignerId"] = this.agreementSignerId;
        data["signerType"] = this.signerType;
        data["signerId"] = this.signerId;
        data["roleId"] = this.roleId;
        data["signOrder"] = this.signOrder;
        return data;
    }
}

export interface IAgreementDetailsSignerDto {
    agreementSignerId?: number;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;
}

export class AgreementDocumentFileVersionDto implements IAgreementDocumentFileVersionDto {
    version?: number;
    isCurrent?: boolean;
    isDraft?: boolean;
    description?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    envelopeStatus?: EnvelopeStatus;

    constructor(data?: IAgreementDocumentFileVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.isCurrent = _data["isCurrent"];
            this.isDraft = _data["isDraft"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.envelopeStatus = _data["envelopeStatus"];
        }
    }

    static fromJS(data: any): AgreementDocumentFileVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementDocumentFileVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["isCurrent"] = this.isCurrent;
        data["isDraft"] = this.isDraft;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["envelopeStatus"] = this.envelopeStatus;
        return data;
    }
}

export interface IAgreementDocumentFileVersionDto {
    version?: number;
    isCurrent?: boolean;
    isDraft?: boolean;
    description?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    envelopeStatus?: EnvelopeStatus;
}

export enum AgreementLanguage {
    Danish = 1,
    Dutch = 2,
    English = 3,
    French = 4,
    German = 5,
    Hindi = 6,
    Norwegian = 7,
    Polish = 8,
    Swedish = 9,
}

export class AgreementListItemDto implements IAgreementListItemDto {
    languageId?: AgreementLanguage;
    agreementId?: number;
    agreementName?: string | undefined;
    actualRecipientName?: string | undefined;
    recipientTypeId?: number;
    agreementType?: AgreementType;
    legalEntityId?: number;
    clientName?: string | undefined;
    companyName?: string | undefined;
    consultantName?: string | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    validity?: AgreementValidityState;
    status?: EnvelopeStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    isWorkflowRelated?: boolean;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    docuSignUrl?: string | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;
    envelopeProcessingPath?: EnvelopeProcessingPath;
    receiveAgreementsFromOtherParty?: boolean;
    isLocked?: boolean;

    constructor(data?: IAgreementListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageId = _data["languageId"];
            this.agreementId = _data["agreementId"];
            this.agreementName = _data["agreementName"];
            this.actualRecipientName = _data["actualRecipientName"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.agreementType = _data["agreementType"];
            this.legalEntityId = _data["legalEntityId"];
            this.clientName = _data["clientName"];
            this.companyName = _data["companyName"];
            this.consultantName = _data["consultantName"];
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            this.validity = _data["validity"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.salesManager = _data["salesManager"] ? EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.contractManager = _data["contractManager"] ? EmployeeDto.fromJS(_data["contractManager"]) : <any>undefined;
            this.isWorkflowRelated = _data["isWorkflowRelated"];
            this.workflowId = _data["workflowId"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.docuSignUrl = _data["docuSignUrl"];
            this.hasDraftVersion = _data["hasDraftVersion"];
            this.hasCurrentVersion = _data["hasCurrentVersion"];
            this.hasSignedDocumentFile = _data["hasSignedDocumentFile"];
            this.envelopeProcessingPath = _data["envelopeProcessingPath"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            this.isLocked = _data["isLocked"];
        }
    }

    static fromJS(data: any): AgreementListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageId"] = this.languageId;
        data["agreementId"] = this.agreementId;
        data["agreementName"] = this.agreementName;
        data["actualRecipientName"] = this.actualRecipientName;
        data["recipientTypeId"] = this.recipientTypeId;
        data["agreementType"] = this.agreementType;
        data["legalEntityId"] = this.legalEntityId;
        data["clientName"] = this.clientName;
        data["companyName"] = this.companyName;
        data["consultantName"] = this.consultantName;
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        data["validity"] = this.validity;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["contractManager"] = this.contractManager ? this.contractManager.toJSON() : <any>undefined;
        data["isWorkflowRelated"] = this.isWorkflowRelated;
        data["workflowId"] = this.workflowId;
        data["clientPeriodId"] = this.clientPeriodId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["docuSignUrl"] = this.docuSignUrl;
        data["hasDraftVersion"] = this.hasDraftVersion;
        data["hasCurrentVersion"] = this.hasCurrentVersion;
        data["hasSignedDocumentFile"] = this.hasSignedDocumentFile;
        data["envelopeProcessingPath"] = this.envelopeProcessingPath;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        data["isLocked"] = this.isLocked;
        return data;
    }
}

export interface IAgreementListItemDto {
    languageId?: AgreementLanguage;
    agreementId?: number;
    agreementName?: string | undefined;
    actualRecipientName?: string | undefined;
    recipientTypeId?: number;
    agreementType?: AgreementType;
    legalEntityId?: number;
    clientName?: string | undefined;
    companyName?: string | undefined;
    consultantName?: string | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    validity?: AgreementValidityState;
    status?: EnvelopeStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesManager?: EmployeeDto;
    contractManager?: EmployeeDto;
    isWorkflowRelated?: boolean;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    docuSignUrl?: string | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;
    envelopeProcessingPath?: EnvelopeProcessingPath;
    receiveAgreementsFromOtherParty?: boolean;
    isLocked?: boolean;
}

export class AgreementListItemDtoPaginatedList implements IAgreementListItemDtoPaginatedList {
    items?: AgreementListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgreementListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AgreementListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): AgreementListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IAgreementListItemDtoPaginatedList {
    items?: AgreementListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AgreementLogQueryResultDto implements IAgreementLogQueryResultDto {
    metadataLogs?: AgreementMetadataLogListItemDto[] | undefined;
    signingStatuses?: EnvelopeEventListItemDto[] | undefined;

    constructor(data?: IAgreementLogQueryResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["metadataLogs"])) {
                this.metadataLogs = [] as any;
                for (let item of _data["metadataLogs"])
                    this.metadataLogs!.push(AgreementMetadataLogListItemDto.fromJS(item));
            }
            if (Array.isArray(_data["signingStatuses"])) {
                this.signingStatuses = [] as any;
                for (let item of _data["signingStatuses"])
                    this.signingStatuses!.push(EnvelopeEventListItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgreementLogQueryResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementLogQueryResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.metadataLogs)) {
            data["metadataLogs"] = [];
            for (let item of this.metadataLogs)
                data["metadataLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.signingStatuses)) {
            data["signingStatuses"] = [];
            for (let item of this.signingStatuses)
                data["signingStatuses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgreementLogQueryResultDto {
    metadataLogs?: AgreementMetadataLogListItemDto[] | undefined;
    signingStatuses?: EnvelopeEventListItemDto[] | undefined;
}

export class AgreementMetadataLogListItemDto implements IAgreementMetadataLogListItemDto {
    operationType?: LogOperationType;
    employee?: EmployeeDto;
    propertyName?: string | undefined;
    oldValue?: string | undefined;
    newValue?: string | undefined;
    dateTime?: moment.Moment;

    constructor(data?: IAgreementMetadataLogListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["operationType"];
            this.employee = _data["employee"] ? EmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.propertyName = _data["propertyName"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgreementMetadataLogListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementMetadataLogListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["propertyName"] = this.propertyName;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAgreementMetadataLogListItemDto {
    operationType?: LogOperationType;
    employee?: EmployeeDto;
    propertyName?: string | undefined;
    oldValue?: string | undefined;
    newValue?: string | undefined;
    dateTime?: moment.Moment;
}

export class AgreementSignerDto implements IAgreementSignerDto {
    agreementSignerId?: number | undefined;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;

    constructor(data?: IAgreementSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementSignerId = _data["agreementSignerId"];
            this.signerType = _data["signerType"];
            this.signerId = _data["signerId"];
            this.roleId = _data["roleId"];
            this.signOrder = _data["signOrder"];
        }
    }

    static fromJS(data: any): AgreementSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementSignerId"] = this.agreementSignerId;
        data["signerType"] = this.signerType;
        data["signerId"] = this.signerId;
        data["roleId"] = this.roleId;
        data["signOrder"] = this.signOrder;
        return data;
    }
}

export interface IAgreementSignerDto {
    agreementSignerId?: number | undefined;
    signerType?: SignerType;
    signerId?: number;
    roleId?: number;
    signOrder?: number;
}

export class AgreementSimpleListItemDto implements IAgreementSimpleListItemDto {
    agreementId?: number;
    agreementName?: string | undefined;
    recipientName?: string | undefined;
    recipientTypeId?: number;
    agreementType?: AgreementType;
    countryName?: string | undefined;
    validity?: AgreementValidityState;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;

    constructor(data?: IAgreementSimpleListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
            this.agreementName = _data["agreementName"];
            this.recipientName = _data["recipientName"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.agreementType = _data["agreementType"];
            this.countryName = _data["countryName"];
            this.validity = _data["validity"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.hasDraftVersion = _data["hasDraftVersion"];
            this.hasCurrentVersion = _data["hasCurrentVersion"];
            this.hasSignedDocumentFile = _data["hasSignedDocumentFile"];
        }
    }

    static fromJS(data: any): AgreementSimpleListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementSimpleListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        data["agreementName"] = this.agreementName;
        data["recipientName"] = this.recipientName;
        data["recipientTypeId"] = this.recipientTypeId;
        data["agreementType"] = this.agreementType;
        data["countryName"] = this.countryName;
        data["validity"] = this.validity;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["hasDraftVersion"] = this.hasDraftVersion;
        data["hasCurrentVersion"] = this.hasCurrentVersion;
        data["hasSignedDocumentFile"] = this.hasSignedDocumentFile;
        return data;
    }
}

export interface IAgreementSimpleListItemDto {
    agreementId?: number;
    agreementName?: string | undefined;
    recipientName?: string | undefined;
    recipientTypeId?: number;
    agreementType?: AgreementType;
    countryName?: string | undefined;
    validity?: AgreementValidityState;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;
}

export class AgreementSimpleListItemDtoPaginatedList implements IAgreementSimpleListItemDtoPaginatedList {
    items?: AgreementSimpleListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgreementSimpleListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AgreementSimpleListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): AgreementSimpleListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementSimpleListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IAgreementSimpleListItemDtoPaginatedList {
    items?: AgreementSimpleListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AgreementStatusHistoryDto implements IAgreementStatusHistoryDto {
    status?: EnvelopeStatus;
    timestampUtc?: moment.Moment;
    triggeredBy?: string | undefined;
    reason?: string | undefined;

    constructor(data?: IAgreementStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.timestampUtc = _data["timestampUtc"] ? moment(_data["timestampUtc"].toString()) : <any>undefined;
            this.triggeredBy = _data["triggeredBy"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): AgreementStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["timestampUtc"] = this.timestampUtc ? this.timestampUtc.toISOString() : <any>undefined;
        data["triggeredBy"] = this.triggeredBy;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IAgreementStatusHistoryDto {
    status?: EnvelopeStatus;
    timestampUtc?: moment.Moment;
    triggeredBy?: string | undefined;
    reason?: string | undefined;
}

export class AgreementTemplateAttachmentDto implements IAgreementTemplateAttachmentDto {
    agreementTemplateAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;
    includeInDerivedTemplates?: boolean | undefined;

    constructor(data?: IAgreementTemplateAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateAttachmentId = _data["agreementTemplateAttachmentId"];
            this.temporaryFileId = _data["temporaryFileId"];
            this.name = _data["name"];
            this.includeInDerivedTemplates = _data["includeInDerivedTemplates"];
        }
    }

    static fromJS(data: any): AgreementTemplateAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateAttachmentId"] = this.agreementTemplateAttachmentId;
        data["temporaryFileId"] = this.temporaryFileId;
        data["name"] = this.name;
        data["includeInDerivedTemplates"] = this.includeInDerivedTemplates;
        return data;
    }
}

export interface IAgreementTemplateAttachmentDto {
    agreementTemplateAttachmentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;
    includeInDerivedTemplates?: boolean | undefined;
}

export class AgreementTemplateChildAgreementDto implements IAgreementTemplateChildAgreementDto {
    agreementStatus?: EnvelopeStatus;
    mode?: AgreementValidityState;
    agreementId?: number;
    recipientTypeId?: number;
    recipientName?: string | undefined;
    agreementName?: string | undefined;

    constructor(data?: IAgreementTemplateChildAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementStatus = _data["agreementStatus"];
            this.mode = _data["mode"];
            this.agreementId = _data["agreementId"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.recipientName = _data["recipientName"];
            this.agreementName = _data["agreementName"];
        }
    }

    static fromJS(data: any): AgreementTemplateChildAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateChildAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementStatus"] = this.agreementStatus;
        data["mode"] = this.mode;
        data["agreementId"] = this.agreementId;
        data["recipientTypeId"] = this.recipientTypeId;
        data["recipientName"] = this.recipientName;
        data["agreementName"] = this.agreementName;
        return data;
    }
}

export interface IAgreementTemplateChildAgreementDto {
    agreementStatus?: EnvelopeStatus;
    mode?: AgreementValidityState;
    agreementId?: number;
    recipientTypeId?: number;
    recipientName?: string | undefined;
    agreementName?: string | undefined;
}

export class AgreementTemplateChildAgreementDtoPaginatedList implements IAgreementTemplateChildAgreementDtoPaginatedList {
    items?: AgreementTemplateChildAgreementDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgreementTemplateChildAgreementDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AgreementTemplateChildAgreementDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): AgreementTemplateChildAgreementDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateChildAgreementDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IAgreementTemplateChildAgreementDtoPaginatedList {
    items?: AgreementTemplateChildAgreementDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AgreementTemplateChildTemplateDto implements IAgreementTemplateChildTemplateDto {
    agreementTemplateId?: number;
    isEnabled?: boolean;
    clientName?: string | undefined;
    name?: string | undefined;
    lastUpdateDateUtc?: moment.Moment;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;

    constructor(data?: IAgreementTemplateChildTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
            this.isEnabled = _data["isEnabled"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.lastUpdateDateUtc = _data["lastUpdateDateUtc"] ? moment(_data["lastUpdateDateUtc"].toString()) : <any>undefined;
            this.linkState = _data["linkState"];
            this.linkStateAccepted = _data["linkStateAccepted"];
        }
    }

    static fromJS(data: any): AgreementTemplateChildTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateChildTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        data["isEnabled"] = this.isEnabled;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["lastUpdateDateUtc"] = this.lastUpdateDateUtc ? this.lastUpdateDateUtc.toISOString() : <any>undefined;
        data["linkState"] = this.linkState;
        data["linkStateAccepted"] = this.linkStateAccepted;
        return data;
    }
}

export interface IAgreementTemplateChildTemplateDto {
    agreementTemplateId?: number;
    isEnabled?: boolean;
    clientName?: string | undefined;
    name?: string | undefined;
    lastUpdateDateUtc?: moment.Moment;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
}

export class AgreementTemplateChildTemplateDtoPaginatedList implements IAgreementTemplateChildTemplateDtoPaginatedList {
    items?: AgreementTemplateChildTemplateDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgreementTemplateChildTemplateDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AgreementTemplateChildTemplateDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): AgreementTemplateChildTemplateDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateChildTemplateDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IAgreementTemplateChildTemplateDtoPaginatedList {
    items?: AgreementTemplateChildTemplateDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AgreementTemplateCommentDto implements IAgreementTemplateCommentDto {
    id?: number;
    parentId?: number | undefined;
    text?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    metadata?: string | undefined;

    constructor(data?: IAgreementTemplateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.text = _data["text"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): AgreementTemplateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["text"] = this.text;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface IAgreementTemplateCommentDto {
    id?: number;
    parentId?: number | undefined;
    text?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    metadata?: string | undefined;
}

export class AgreementTemplateDetailsAttachmentDto implements IAgreementTemplateDetailsAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
    isUsedByDescendants?: boolean | undefined;

    constructor(data?: IAgreementTemplateDetailsAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateAttachmentId = _data["agreementTemplateAttachmentId"];
            this.name = _data["name"];
            this.isUsedByDescendants = _data["isUsedByDescendants"];
        }
    }

    static fromJS(data: any): AgreementTemplateDetailsAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateDetailsAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateAttachmentId"] = this.agreementTemplateAttachmentId;
        data["name"] = this.name;
        data["isUsedByDescendants"] = this.isUsedByDescendants;
        return data;
    }
}

export interface IAgreementTemplateDetailsAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
    isUsedByDescendants?: boolean | undefined;
}

export class AgreementTemplateDetailsDto implements IAgreementTemplateDetailsDto {
    agreementTemplateId?: number;
    isEnabled?: boolean;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    clientName?: string | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateDetailsAttachmentDto[] | undefined;
    attachmentsFromParent?: ParentAgreementTemplateDetailsAttachmentDto[] | undefined;
    isDefaultTemplate?: boolean;

    constructor(data?: IAgreementTemplateDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
            this.isEnabled = _data["isEnabled"];
            this.creationMode = _data["creationMode"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.parentAgreementTemplateName = _data["parentAgreementTemplateName"];
            this.duplicationSourceAgreementTemplateId = _data["duplicationSourceAgreementTemplateId"];
            this.duplicationSourceAgreementTemplateName = _data["duplicationSourceAgreementTemplateName"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.documentFileProvidedByClient = _data["documentFileProvidedByClient"];
            this.name = _data["name"];
            this.agreementNameTemplate = _data["agreementNameTemplate"];
            this.definition = _data["definition"];
            if (Array.isArray(_data["legalEntityIds"])) {
                this.legalEntityIds = [] as any;
                for (let item of _data["legalEntityIds"])
                    this.legalEntityIds!.push(item);
            }
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            this.language = _data["language"];
            this.note = _data["note"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementTemplateDetailsAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsFromParent"])) {
                this.attachmentsFromParent = [] as any;
                for (let item of _data["attachmentsFromParent"])
                    this.attachmentsFromParent!.push(ParentAgreementTemplateDetailsAttachmentDto.fromJS(item));
            }
            this.isDefaultTemplate = _data["isDefaultTemplate"];
        }
    }

    static fromJS(data: any): AgreementTemplateDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        data["isEnabled"] = this.isEnabled;
        data["creationMode"] = this.creationMode;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["parentAgreementTemplateName"] = this.parentAgreementTemplateName;
        data["duplicationSourceAgreementTemplateId"] = this.duplicationSourceAgreementTemplateId;
        data["duplicationSourceAgreementTemplateName"] = this.duplicationSourceAgreementTemplateName;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["documentFileProvidedByClient"] = this.documentFileProvidedByClient;
        data["name"] = this.name;
        data["agreementNameTemplate"] = this.agreementNameTemplate;
        data["definition"] = this.definition;
        if (Array.isArray(this.legalEntityIds)) {
            data["legalEntityIds"] = [];
            for (let item of this.legalEntityIds)
                data["legalEntityIds"].push(item);
        }
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        data["language"] = this.language;
        data["note"] = this.note;
        data["isSignatureRequired"] = this.isSignatureRequired;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsFromParent)) {
            data["attachmentsFromParent"] = [];
            for (let item of this.attachmentsFromParent)
                data["attachmentsFromParent"].push(item.toJSON());
        }
        data["isDefaultTemplate"] = this.isDefaultTemplate;
        return data;
    }
}

export interface IAgreementTemplateDetailsDto {
    agreementTemplateId?: number;
    isEnabled?: boolean;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    clientName?: string | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateDetailsAttachmentDto[] | undefined;
    attachmentsFromParent?: ParentAgreementTemplateDetailsAttachmentDto[] | undefined;
    isDefaultTemplate?: boolean;
}

export class AgreementTemplateDetailsPreviewAttachmentDto implements IAgreementTemplateDetailsPreviewAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;

    constructor(data?: IAgreementTemplateDetailsPreviewAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateAttachmentId = _data["agreementTemplateAttachmentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AgreementTemplateDetailsPreviewAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateDetailsPreviewAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateAttachmentId"] = this.agreementTemplateAttachmentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAgreementTemplateDetailsPreviewAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
}

export class AgreementTemplateDetailsPreviewDto implements IAgreementTemplateDetailsPreviewDto {
    agreementTemplateId?: number;
    currentAgreementTemplateDocumentFileVersion?: number | undefined;
    creationMode?: AgreementCreationMode;
    isEnabled?: boolean;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    clientName?: string | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateDetailsPreviewAttachmentDto[] | undefined;
    attachmentsFromParent?: AgreementTemplateDetailsPreviewAttachmentDto[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    editReason?: AgreementTemplateEditReason;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    isDefaultTemplate?: boolean;

    constructor(data?: IAgreementTemplateDetailsPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
            this.currentAgreementTemplateDocumentFileVersion = _data["currentAgreementTemplateDocumentFileVersion"];
            this.creationMode = _data["creationMode"];
            this.isEnabled = _data["isEnabled"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.parentAgreementTemplateName = _data["parentAgreementTemplateName"];
            this.duplicationSourceAgreementTemplateId = _data["duplicationSourceAgreementTemplateId"];
            this.duplicationSourceAgreementTemplateName = _data["duplicationSourceAgreementTemplateName"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.clientId = _data["clientId"];
            this.documentFileProvidedByClient = _data["documentFileProvidedByClient"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.agreementNameTemplate = _data["agreementNameTemplate"];
            this.definition = _data["definition"];
            if (Array.isArray(_data["legalEntityIds"])) {
                this.legalEntityIds = [] as any;
                for (let item of _data["legalEntityIds"])
                    this.legalEntityIds!.push(item);
            }
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            this.language = _data["language"];
            this.note = _data["note"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementTemplateDetailsPreviewAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["attachmentsFromParent"])) {
                this.attachmentsFromParent = [] as any;
                for (let item of _data["attachmentsFromParent"])
                    this.attachmentsFromParent!.push(AgreementTemplateDetailsPreviewAttachmentDto.fromJS(item));
            }
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"] ? EmployeeDto.fromJS(_data["lastUpdatedBy"]) : <any>undefined;
            this.lastUpdateDateUtc = _data["lastUpdateDateUtc"] ? moment(_data["lastUpdateDateUtc"].toString()) : <any>undefined;
            this.editReason = _data["editReason"];
            this.linkState = _data["linkState"];
            this.linkStateAccepted = _data["linkStateAccepted"];
            this.isDefaultTemplate = _data["isDefaultTemplate"];
        }
    }

    static fromJS(data: any): AgreementTemplateDetailsPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateDetailsPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        data["currentAgreementTemplateDocumentFileVersion"] = this.currentAgreementTemplateDocumentFileVersion;
        data["creationMode"] = this.creationMode;
        data["isEnabled"] = this.isEnabled;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["parentAgreementTemplateName"] = this.parentAgreementTemplateName;
        data["duplicationSourceAgreementTemplateId"] = this.duplicationSourceAgreementTemplateId;
        data["duplicationSourceAgreementTemplateName"] = this.duplicationSourceAgreementTemplateName;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["clientId"] = this.clientId;
        data["documentFileProvidedByClient"] = this.documentFileProvidedByClient;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["agreementNameTemplate"] = this.agreementNameTemplate;
        data["definition"] = this.definition;
        if (Array.isArray(this.legalEntityIds)) {
            data["legalEntityIds"] = [];
            for (let item of this.legalEntityIds)
                data["legalEntityIds"].push(item);
        }
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        data["language"] = this.language;
        data["note"] = this.note;
        data["isSignatureRequired"] = this.isSignatureRequired;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.attachmentsFromParent)) {
            data["attachmentsFromParent"] = [];
            for (let item of this.attachmentsFromParent)
                data["attachmentsFromParent"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy ? this.lastUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdateDateUtc"] = this.lastUpdateDateUtc ? this.lastUpdateDateUtc.toISOString() : <any>undefined;
        data["editReason"] = this.editReason;
        data["linkState"] = this.linkState;
        data["linkStateAccepted"] = this.linkStateAccepted;
        data["isDefaultTemplate"] = this.isDefaultTemplate;
        return data;
    }
}

export interface IAgreementTemplateDetailsPreviewDto {
    agreementTemplateId?: number;
    currentAgreementTemplateDocumentFileVersion?: number | undefined;
    creationMode?: AgreementCreationMode;
    isEnabled?: boolean;
    parentAgreementTemplateId?: number | undefined;
    parentAgreementTemplateName?: string | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    clientName?: string | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateDetailsPreviewAttachmentDto[] | undefined;
    attachmentsFromParent?: AgreementTemplateDetailsPreviewAttachmentDto[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    editReason?: AgreementTemplateEditReason;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    isDefaultTemplate?: boolean;
}

export class AgreementTemplateDocumentFileVersionDto implements IAgreementTemplateDocumentFileVersionDto {
    version?: number;
    isCurrent?: boolean;
    isDraft?: boolean;
    description?: string | undefined;
    creationReason?: AgreementTemplateEditReason;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;

    constructor(data?: IAgreementTemplateDocumentFileVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.isCurrent = _data["isCurrent"];
            this.isDraft = _data["isDraft"];
            this.description = _data["description"];
            this.creationReason = _data["creationReason"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgreementTemplateDocumentFileVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateDocumentFileVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["isCurrent"] = this.isCurrent;
        data["isDraft"] = this.isDraft;
        data["description"] = this.description;
        data["creationReason"] = this.creationReason;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAgreementTemplateDocumentFileVersionDto {
    version?: number;
    isCurrent?: boolean;
    isDraft?: boolean;
    description?: string | undefined;
    creationReason?: AgreementTemplateEditReason;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
}

export enum AgreementTemplateEditReason {
    UserEdit = 1,
    ParentInheritance = 2,
    InitialSourceCopy = 3,
}

export class AgreementTemplateMetadataLogListItemDto implements IAgreementTemplateMetadataLogListItemDto {
    operationType?: LogOperationType;
    employee?: EmployeeDto;
    propertyName?: string | undefined;
    oldValue?: string | undefined;
    newValue?: string | undefined;
    dateTime?: moment.Moment;

    constructor(data?: IAgreementTemplateMetadataLogListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["operationType"];
            this.employee = _data["employee"] ? EmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.propertyName = _data["propertyName"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.dateTime = _data["dateTime"] ? moment(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AgreementTemplateMetadataLogListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplateMetadataLogListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["propertyName"] = this.propertyName;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAgreementTemplateMetadataLogListItemDto {
    operationType?: LogOperationType;
    employee?: EmployeeDto;
    propertyName?: string | undefined;
    oldValue?: string | undefined;
    newValue?: string | undefined;
    dateTime?: moment.Moment;
}

export enum AgreementTemplateParentChildLinkState {
    NotApplicable = 0,
    IsApplicable = 1,
    MetadataLinked = 2,
    DocumentLinked = 4,
    FullyLinked = 7,
}

export enum AgreementTemplateParentChildLinkStateFilter {
    NotApplicable = 0,
    FullyUnlinked = 1,
    DocumentUnlinked = 3,
    MetadataUnlinked = 5,
    FullyLinked = 7,
}

export class AgreementTemplatesListItemDto implements IAgreementTemplatesListItemDto {
    agreementTemplateId?: number;
    name?: string | undefined;
    clientName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    language?: AgreementLanguage;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    isEnabled?: boolean;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    linkStateAcceptedDateUtc?: moment.Moment | undefined;
    linkStateAcceptedBy?: EmployeeDto;
    hasDraftVersion?: boolean;

    constructor(data?: IAgreementTemplatesListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
            this.name = _data["name"];
            this.clientName = _data["clientName"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.language = _data["language"];
            if (Array.isArray(_data["legalEntityIds"])) {
                this.legalEntityIds = [] as any;
                for (let item of _data["legalEntityIds"])
                    this.legalEntityIds!.push(item);
            }
            if (Array.isArray(_data["contractTypeIds"])) {
                this.contractTypeIds = [] as any;
                for (let item of _data["contractTypeIds"])
                    this.contractTypeIds!.push(item);
            }
            if (Array.isArray(_data["salesTypeIds"])) {
                this.salesTypeIds = [] as any;
                for (let item of _data["salesTypeIds"])
                    this.salesTypeIds!.push(item);
            }
            if (Array.isArray(_data["deliveryTypeIds"])) {
                this.deliveryTypeIds = [] as any;
                for (let item of _data["deliveryTypeIds"])
                    this.deliveryTypeIds!.push(item);
            }
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"] ? EmployeeDto.fromJS(_data["lastUpdatedBy"]) : <any>undefined;
            this.lastUpdateDateUtc = _data["lastUpdateDateUtc"] ? moment(_data["lastUpdateDateUtc"].toString()) : <any>undefined;
            this.isEnabled = _data["isEnabled"];
            this.linkState = _data["linkState"];
            this.linkStateAccepted = _data["linkStateAccepted"];
            this.linkStateAcceptedDateUtc = _data["linkStateAcceptedDateUtc"] ? moment(_data["linkStateAcceptedDateUtc"].toString()) : <any>undefined;
            this.linkStateAcceptedBy = _data["linkStateAcceptedBy"] ? EmployeeDto.fromJS(_data["linkStateAcceptedBy"]) : <any>undefined;
            this.hasDraftVersion = _data["hasDraftVersion"];
        }
    }

    static fromJS(data: any): AgreementTemplatesListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplatesListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        data["name"] = this.name;
        data["clientName"] = this.clientName;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["language"] = this.language;
        if (Array.isArray(this.legalEntityIds)) {
            data["legalEntityIds"] = [];
            for (let item of this.legalEntityIds)
                data["legalEntityIds"].push(item);
        }
        if (Array.isArray(this.contractTypeIds)) {
            data["contractTypeIds"] = [];
            for (let item of this.contractTypeIds)
                data["contractTypeIds"].push(item);
        }
        if (Array.isArray(this.salesTypeIds)) {
            data["salesTypeIds"] = [];
            for (let item of this.salesTypeIds)
                data["salesTypeIds"].push(item);
        }
        if (Array.isArray(this.deliveryTypeIds)) {
            data["deliveryTypeIds"] = [];
            for (let item of this.deliveryTypeIds)
                data["deliveryTypeIds"].push(item);
        }
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy ? this.lastUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdateDateUtc"] = this.lastUpdateDateUtc ? this.lastUpdateDateUtc.toISOString() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        data["linkState"] = this.linkState;
        data["linkStateAccepted"] = this.linkStateAccepted;
        data["linkStateAcceptedDateUtc"] = this.linkStateAcceptedDateUtc ? this.linkStateAcceptedDateUtc.toISOString() : <any>undefined;
        data["linkStateAcceptedBy"] = this.linkStateAcceptedBy ? this.linkStateAcceptedBy.toJSON() : <any>undefined;
        data["hasDraftVersion"] = this.hasDraftVersion;
        return data;
    }
}

export interface IAgreementTemplatesListItemDto {
    agreementTemplateId?: number;
    name?: string | undefined;
    clientName?: string | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    language?: AgreementLanguage;
    legalEntityIds?: number[] | undefined;
    contractTypeIds?: number[] | undefined;
    salesTypeIds?: number[] | undefined;
    deliveryTypeIds?: number[] | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    isEnabled?: boolean;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    linkStateAcceptedDateUtc?: moment.Moment | undefined;
    linkStateAcceptedBy?: EmployeeDto;
    hasDraftVersion?: boolean;
}

export class AgreementTemplatesListItemDtoPaginatedList implements IAgreementTemplatesListItemDtoPaginatedList {
    items?: AgreementTemplatesListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgreementTemplatesListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AgreementTemplatesListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): AgreementTemplatesListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgreementTemplatesListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IAgreementTemplatesListItemDtoPaginatedList {
    items?: AgreementTemplatesListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export enum AgreementType {
    Frame = 1,
    ServiceOrder = 2,
    WorkOrder = 3,
    IntercompanyOrder = 4,
    Other = 5,
}

export enum AgreementValidityState {
    Active = 0,
    ActiveOutdatedTemplate = 1,
    Inactive = 2,
    NotStarted = 3,
}

export class AreaRoleNodeDto implements IAreaRoleNodeDto {
    id?: number;
    name?: string | undefined;
    roles?: RoleNodeDto[] | undefined;

    constructor(data?: IAreaRoleNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AreaRoleNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaRoleNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAreaRoleNodeDto {
    id?: number;
    name?: string | undefined;
    roles?: RoleNodeDto[] | undefined;
}

export class AvailableConsultantDto implements IAvailableConsultantDto {
    consultantName?: string | undefined;
    consultantId?: number;
    externalId?: string;
    lastConsultantPeriodEndDate?: moment.Moment | undefined;

    constructor(data?: IAvailableConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantName = _data["consultantName"];
            this.consultantId = _data["consultantId"];
            this.externalId = _data["externalId"];
            this.lastConsultantPeriodEndDate = _data["lastConsultantPeriodEndDate"] ? moment(_data["lastConsultantPeriodEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AvailableConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantName"] = this.consultantName;
        data["consultantId"] = this.consultantId;
        data["externalId"] = this.externalId;
        data["lastConsultantPeriodEndDate"] = this.lastConsultantPeriodEndDate ? this.lastConsultantPeriodEndDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IAvailableConsultantDto {
    consultantName?: string | undefined;
    consultantId?: number;
    externalId?: string;
    lastConsultantPeriodEndDate?: moment.Moment | undefined;
}

export class BranchRoleNodeDto implements IBranchRoleNodeDto {
    id?: number;
    name?: string | undefined;
    areas?: AreaRoleNodeDto[] | undefined;

    constructor(data?: IBranchRoleNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaRoleNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BranchRoleNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchRoleNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBranchRoleNodeDto {
    id?: number;
    name?: string | undefined;
    areas?: AreaRoleNodeDto[] | undefined;
}

export class CategoryForMigrateDto implements ICategoryForMigrateDto {
    isMigrationNeeded?: boolean;
    projectCategoryId?: number | undefined;

    constructor(data?: ICategoryForMigrateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMigrationNeeded = _data["isMigrationNeeded"];
            this.projectCategoryId = _data["projectCategoryId"];
        }
    }

    static fromJS(data: any): CategoryForMigrateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryForMigrateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isMigrationNeeded"] = this.isMigrationNeeded;
        data["projectCategoryId"] = this.projectCategoryId;
        return data;
    }
}

export interface ICategoryForMigrateDto {
    isMigrationNeeded?: boolean;
    projectCategoryId?: number | undefined;
}

export class ChangeClientPeriodDto implements IChangeClientPeriodDto {
    cutoverDate?: moment.Moment;
    clientNewLegalContractRequired?: boolean;
    consultantPeriods?: NewContractRequiredConsultantPeriodDto[] | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;

    constructor(data?: IChangeClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cutoverDate = _data["cutoverDate"] ? moment(_data["cutoverDate"].toString()) : <any>undefined;
            this.clientNewLegalContractRequired = _data["clientNewLegalContractRequired"];
            if (Array.isArray(_data["consultantPeriods"])) {
                this.consultantPeriods = [] as any;
                for (let item of _data["consultantPeriods"])
                    this.consultantPeriods!.push(NewContractRequiredConsultantPeriodDto.fromJS(item));
            }
            this.primaryCategoryArea = _data["primaryCategoryArea"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryArea"]) : <any>undefined;
            this.primaryCategoryType = _data["primaryCategoryType"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryType"]) : <any>undefined;
            this.primaryCategoryRole = _data["primaryCategoryRole"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangeClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cutoverDate"] = this.cutoverDate ? this.cutoverDate.format('YYYY-MM-DD') : <any>undefined;
        data["clientNewLegalContractRequired"] = this.clientNewLegalContractRequired;
        if (Array.isArray(this.consultantPeriods)) {
            data["consultantPeriods"] = [];
            for (let item of this.consultantPeriods)
                data["consultantPeriods"].push(item.toJSON());
        }
        data["primaryCategoryArea"] = this.primaryCategoryArea ? this.primaryCategoryArea.toJSON() : <any>undefined;
        data["primaryCategoryType"] = this.primaryCategoryType ? this.primaryCategoryType.toJSON() : <any>undefined;
        data["primaryCategoryRole"] = this.primaryCategoryRole ? this.primaryCategoryRole.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChangeClientPeriodDto {
    cutoverDate?: moment.Moment;
    clientNewLegalContractRequired?: boolean;
    consultantPeriods?: NewContractRequiredConsultantPeriodDto[] | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
}

export class ChangeClientPeriodResultDto implements IChangeClientPeriodResultDto {
    changedClientPeriodId?: string;
    specialRatesChangesWarnings?: string[] | undefined;
    specialFeesChangesWarnings?: string[] | undefined;

    constructor(data?: IChangeClientPeriodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.changedClientPeriodId = _data["changedClientPeriodId"];
            if (Array.isArray(_data["specialRatesChangesWarnings"])) {
                this.specialRatesChangesWarnings = [] as any;
                for (let item of _data["specialRatesChangesWarnings"])
                    this.specialRatesChangesWarnings!.push(item);
            }
            if (Array.isArray(_data["specialFeesChangesWarnings"])) {
                this.specialFeesChangesWarnings = [] as any;
                for (let item of _data["specialFeesChangesWarnings"])
                    this.specialFeesChangesWarnings!.push(item);
            }
        }
    }

    static fromJS(data: any): ChangeClientPeriodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeClientPeriodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["changedClientPeriodId"] = this.changedClientPeriodId;
        if (Array.isArray(this.specialRatesChangesWarnings)) {
            data["specialRatesChangesWarnings"] = [];
            for (let item of this.specialRatesChangesWarnings)
                data["specialRatesChangesWarnings"].push(item);
        }
        if (Array.isArray(this.specialFeesChangesWarnings)) {
            data["specialFeesChangesWarnings"] = [];
            for (let item of this.specialFeesChangesWarnings)
                data["specialFeesChangesWarnings"].push(item);
        }
        return data;
    }
}

export interface IChangeClientPeriodResultDto {
    changedClientPeriodId?: string;
    specialRatesChangesWarnings?: string[] | undefined;
    specialFeesChangesWarnings?: string[] | undefined;
}

export class ChangeConsultantPeriodDto implements IChangeConsultantPeriodDto {
    cutoverDate?: moment.Moment;
    newLegalContractRequired?: boolean;

    constructor(data?: IChangeConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cutoverDate = _data["cutoverDate"] ? moment(_data["cutoverDate"].toString()) : <any>undefined;
            this.newLegalContractRequired = _data["newLegalContractRequired"];
        }
    }

    static fromJS(data: any): ChangeConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cutoverDate"] = this.cutoverDate ? this.cutoverDate.format('YYYY-MM-DD') : <any>undefined;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        return data;
    }
}

export interface IChangeConsultantPeriodDto {
    cutoverDate?: moment.Moment;
    newLegalContractRequired?: boolean;
}

export class ClientAddressDto implements IClientAddressDto {
    id?: number | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    region?: string | undefined;
    countryId?: number | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    isMainAddress?: boolean;
    isWorkplaceAddress?: boolean;
    isInvoiceAddress?: boolean;
    debtorNumberForInvoiceAddress?: string | undefined;
    isHidden?: boolean;

    constructor(data?: IClientAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.region = _data["region"];
            this.countryId = _data["countryId"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.isMainAddress = _data["isMainAddress"];
            this.isWorkplaceAddress = _data["isWorkplaceAddress"];
            this.isInvoiceAddress = _data["isInvoiceAddress"];
            this.debtorNumberForInvoiceAddress = _data["debtorNumberForInvoiceAddress"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["region"] = this.region;
        data["countryId"] = this.countryId;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["isMainAddress"] = this.isMainAddress;
        data["isWorkplaceAddress"] = this.isWorkplaceAddress;
        data["isInvoiceAddress"] = this.isInvoiceAddress;
        data["debtorNumberForInvoiceAddress"] = this.debtorNumberForInvoiceAddress;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientAddressDto {
    id?: number | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    region?: string | undefined;
    countryId?: number | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    isMainAddress?: boolean;
    isWorkplaceAddress?: boolean;
    isInvoiceAddress?: boolean;
    debtorNumberForInvoiceAddress?: string | undefined;
    isHidden?: boolean;
}

export class ClientApplicationPermissionsModel implements IClientApplicationPermissionsModel {
    permissionsVersion?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IClientApplicationPermissionsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionsVersion = _data["permissionsVersion"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): ClientApplicationPermissionsModel {
        data = typeof data === 'object' ? data : {};
        let result = new ClientApplicationPermissionsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionsVersion"] = this.permissionsVersion;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IClientApplicationPermissionsModel {
    permissionsVersion?: string | undefined;
    permissions?: string[] | undefined;
}

export class ClientAttachmentInfoOutputDto implements IClientAttachmentInfoOutputDto {
    clientAttachmentGuid?: string;
    documentStorageGuid?: string;
    attachmentTypeId?: number;
    documentType?: DocumentTypeEnum;
    headline?: string | undefined;
    filename?: string | undefined;
    updatedBy?: string | undefined;
    dateUpdated?: moment.Moment;

    constructor(data?: IClientAttachmentInfoOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientAttachmentGuid = _data["clientAttachmentGuid"];
            this.documentStorageGuid = _data["documentStorageGuid"];
            this.attachmentTypeId = _data["attachmentTypeId"];
            this.documentType = _data["documentType"];
            this.headline = _data["headline"];
            this.filename = _data["filename"];
            this.updatedBy = _data["updatedBy"];
            this.dateUpdated = _data["dateUpdated"] ? moment(_data["dateUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientAttachmentInfoOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAttachmentInfoOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientAttachmentGuid"] = this.clientAttachmentGuid;
        data["documentStorageGuid"] = this.documentStorageGuid;
        data["attachmentTypeId"] = this.attachmentTypeId;
        data["documentType"] = this.documentType;
        data["headline"] = this.headline;
        data["filename"] = this.filename;
        data["updatedBy"] = this.updatedBy;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IClientAttachmentInfoOutputDto {
    clientAttachmentGuid?: string;
    documentStorageGuid?: string;
    attachmentTypeId?: number;
    documentType?: DocumentTypeEnum;
    headline?: string | undefined;
    filename?: string | undefined;
    updatedBy?: string | undefined;
    dateUpdated?: moment.Moment;
}

export enum ClientAttachmentTypeEnum {
    RateCards = 256,
    OrgDiagrams = 258,
    OtherImportantDocuments = 260,
    GeneralDocuments = 288,
    BiddingMaterials = 290,
}

export class ClientContractBaseDto implements IClientContractBaseDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    documents?: ContractDocumentInfoDto[] | undefined;

    constructor(data?: IClientContractBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.statusColorEnum = _data["statusColorEnum"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(ContractDocumentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientContractBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["statusColorEnum"] = this.statusColorEnum;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientContractBaseDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    documents?: ContractDocumentInfoDto[] | undefined;
}

export class ClientContractViewRootDto implements IClientContractViewRootDto {
    frameAgreements?: ClientContractBaseDto[] | undefined;
    workflows?: ClientWorkflowTreeItemDto[] | undefined;

    constructor(data?: IClientContractViewRootDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["frameAgreements"])) {
                this.frameAgreements = [] as any;
                for (let item of _data["frameAgreements"])
                    this.frameAgreements!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(ClientWorkflowTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientContractViewRootDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractViewRootDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.frameAgreements)) {
            data["frameAgreements"] = [];
            for (let item of this.frameAgreements)
                data["frameAgreements"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientContractViewRootDto {
    frameAgreements?: ClientContractBaseDto[] | undefined;
    workflows?: ClientWorkflowTreeItemDto[] | undefined;
}

export class ClientDetailsDto implements IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    clientAddresses?: ClientAddressDto[] | undefined;
    phone?: string | undefined;
    website?: string | undefined;
    consultantShownOnClientInvoiceAs?: ConsultantShownOnClientInvoiceAs;

    constructor(data?: IClientDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["clientAddresses"])) {
                this.clientAddresses = [] as any;
                for (let item of _data["clientAddresses"])
                    this.clientAddresses!.push(ClientAddressDto.fromJS(item));
            }
            this.phone = _data["phone"];
            this.website = _data["website"];
            this.consultantShownOnClientInvoiceAs = _data["consultantShownOnClientInvoiceAs"];
        }
    }

    static fromJS(data: any): ClientDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.clientAddresses)) {
            data["clientAddresses"] = [];
            for (let item of this.clientAddresses)
                data["clientAddresses"].push(item.toJSON());
        }
        data["phone"] = this.phone;
        data["website"] = this.website;
        data["consultantShownOnClientInvoiceAs"] = this.consultantShownOnClientInvoiceAs;
        return data;
    }
}

export interface IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    clientAddresses?: ClientAddressDto[] | undefined;
    phone?: string | undefined;
    website?: string | undefined;
    consultantShownOnClientInvoiceAs?: ConsultantShownOnClientInvoiceAs;
}

export class ClientEvaluationOutputDto implements IClientEvaluationOutputDto {
    evaluationGuid?: string;
    evaluationTenantId?: number;
    consultantTenant?: number;
    legacyConsultantId?: number;
    clientName?: string | undefined;
    clientContactName?: string | undefined;
    consultantName?: string | undefined;
    externalId?: string;
    averageScore?: number;
    evaluationDate?: moment.Moment;
    evaluationFormName?: string | undefined;
    comment?: string | undefined;

    constructor(data?: IClientEvaluationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.evaluationGuid = _data["evaluationGuid"];
            this.evaluationTenantId = _data["evaluationTenantId"];
            this.consultantTenant = _data["consultantTenant"];
            this.legacyConsultantId = _data["legacyConsultantId"];
            this.clientName = _data["clientName"];
            this.clientContactName = _data["clientContactName"];
            this.consultantName = _data["consultantName"];
            this.externalId = _data["externalId"];
            this.averageScore = _data["averageScore"];
            this.evaluationDate = _data["evaluationDate"] ? moment(_data["evaluationDate"].toString()) : <any>undefined;
            this.evaluationFormName = _data["evaluationFormName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ClientEvaluationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientEvaluationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationGuid"] = this.evaluationGuid;
        data["evaluationTenantId"] = this.evaluationTenantId;
        data["consultantTenant"] = this.consultantTenant;
        data["legacyConsultantId"] = this.legacyConsultantId;
        data["clientName"] = this.clientName;
        data["clientContactName"] = this.clientContactName;
        data["consultantName"] = this.consultantName;
        data["externalId"] = this.externalId;
        data["averageScore"] = this.averageScore;
        data["evaluationDate"] = this.evaluationDate ? this.evaluationDate.format('YYYY-MM-DD') : <any>undefined;
        data["evaluationFormName"] = this.evaluationFormName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IClientEvaluationOutputDto {
    evaluationGuid?: string;
    evaluationTenantId?: number;
    consultantTenant?: number;
    legacyConsultantId?: number;
    clientName?: string | undefined;
    clientContactName?: string | undefined;
    consultantName?: string | undefined;
    externalId?: string;
    averageScore?: number;
    evaluationDate?: moment.Moment;
    evaluationFormName?: string | undefined;
    comment?: string | undefined;
}

export class ClientEvaluationOutputDtoPaginatedList implements IClientEvaluationOutputDtoPaginatedList {
    items?: ClientEvaluationOutputDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientEvaluationOutputDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientEvaluationOutputDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientEvaluationOutputDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientEvaluationOutputDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientEvaluationOutputDtoPaginatedList {
    items?: ClientEvaluationOutputDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientGanttRow implements IClientGanttRow {
    name?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;

    constructor(data?: IClientGanttRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["ganttRowItems"])) {
                this.ganttRowItems = [] as any;
                for (let item of _data["ganttRowItems"])
                    this.ganttRowItems!.push(GanttRowItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientGanttRow {
        data = typeof data === 'object' ? data : {};
        let result = new ClientGanttRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.ganttRowItems)) {
            data["ganttRowItems"] = [];
            for (let item of this.ganttRowItems)
                data["ganttRowItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientGanttRow {
    name?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;
}

export class ClientListItemDto implements IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddresses?: ClientAddressDto[] | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;

    constructor(data?: IClientListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crmClientId = _data["crmClientId"];
            this.legacyClientId = _data["legacyClientId"];
            this.name = _data["name"];
            if (Array.isArray(_data["clientAddresses"])) {
                this.clientAddresses = [] as any;
                for (let item of _data["clientAddresses"])
                    this.clientAddresses!.push(ClientAddressDto.fromJS(item));
            }
            this.phone = _data["phone"];
            this.owner_Id = _data["owner_Id"];
            this.owner_Name = _data["owner_Name"];
            this.tenant_Id = _data["tenant_Id"];
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClientListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crmClientId"] = this.crmClientId;
        data["legacyClientId"] = this.legacyClientId;
        data["name"] = this.name;
        if (Array.isArray(this.clientAddresses)) {
            data["clientAddresses"] = [];
            for (let item of this.clientAddresses)
                data["clientAddresses"].push(item.toJSON());
        }
        data["phone"] = this.phone;
        data["owner_Id"] = this.owner_Id;
        data["owner_Name"] = this.owner_Name;
        data["tenant_Id"] = this.tenant_Id;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddresses?: ClientAddressDto[] | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;
}

export class ClientListItemDtoPaginatedList implements IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientPeriodAgreementsDto implements IClientPeriodAgreementsDto {
    clientAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    creationPendingEmployeeDtos?: EmployeeDto[] | undefined;

    constructor(data?: IClientPeriodAgreementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientAgreements"])) {
                this.clientAgreements = [] as any;
                for (let item of _data["clientAgreements"])
                    this.clientAgreements!.push(WorkflowPeriodAgreementDto.fromJS(item));
            }
            if (Array.isArray(_data["creationPendingEmployeeDtos"])) {
                this.creationPendingEmployeeDtos = [] as any;
                for (let item of _data["creationPendingEmployeeDtos"])
                    this.creationPendingEmployeeDtos!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodAgreementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodAgreementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientAgreements)) {
            data["clientAgreements"] = [];
            for (let item of this.clientAgreements)
                data["clientAgreements"].push(item.toJSON());
        }
        if (Array.isArray(this.creationPendingEmployeeDtos)) {
            data["creationPendingEmployeeDtos"] = [];
            for (let item of this.creationPendingEmployeeDtos)
                data["creationPendingEmployeeDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodAgreementsDto {
    clientAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    creationPendingEmployeeDtos?: EmployeeDto[] | undefined;
}

export class ClientPeriodContractsDataCommandDto implements IClientPeriodContractsDataCommandDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;

    constructor(data?: IClientPeriodContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.bypassLegalValidation = _data["bypassLegalValidation"];
            this.skipOptionalLegalContractsValidation = _data["skipOptionalLegalContractsValidation"];
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataCommandDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocumentsCommandDto"])) {
                this.workflowDocumentsCommandDto = [] as any;
                for (let item of _data["workflowDocumentsCommandDto"])
                    this.workflowDocumentsCommandDto!.push(WorkflowDocumentCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["bypassLegalValidation"] = this.bypassLegalValidation;
        data["skipOptionalLegalContractsValidation"] = this.skipOptionalLegalContractsValidation;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocumentsCommandDto)) {
            data["workflowDocumentsCommandDto"] = [];
            for (let item of this.workflowDocumentsCommandDto)
                data["workflowDocumentsCommandDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodContractsDataCommandDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;
}

export class ClientPeriodContractsDataQueryDto implements IClientPeriodContractsDataQueryDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    clientLegalContractDoneStatusId?: number;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;

    constructor(data?: IClientPeriodContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.bypassLegalValidation = _data["bypassLegalValidation"];
            this.skipOptionalLegalContractsValidation = _data["skipOptionalLegalContractsValidation"];
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
            this.clientLegalContractDoneStatusId = _data["clientLegalContractDoneStatusId"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataQueryDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocuments"])) {
                this.workflowDocuments = [] as any;
                for (let item of _data["workflowDocuments"])
                    this.workflowDocuments!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["bypassLegalValidation"] = this.bypassLegalValidation;
        data["skipOptionalLegalContractsValidation"] = this.skipOptionalLegalContractsValidation;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        data["clientLegalContractDoneStatusId"] = this.clientLegalContractDoneStatusId;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocuments)) {
            data["workflowDocuments"] = [];
            for (let item of this.workflowDocuments)
                data["workflowDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodContractsDataQueryDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    clientLegalContractDoneStatusId?: number;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;
}

export class ClientPeriodDto implements IClientPeriodDto {
    id?: string;
    fullDisplayId?: string | undefined;
    name?: string | undefined;
    typeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
    consultantIds?: number[] | undefined;

    constructor(data?: IClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullDisplayId = _data["fullDisplayId"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["workflowProcesses"])) {
                this.workflowProcesses = [] as any;
                for (let item of _data["workflowProcesses"])
                    this.workflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantIds"])) {
                this.consultantIds = [] as any;
                for (let item of _data["consultantIds"])
                    this.consultantIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullDisplayId"] = this.fullDisplayId;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.workflowProcesses)) {
            data["workflowProcesses"] = [];
            for (let item of this.workflowProcesses)
                data["workflowProcesses"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantIds)) {
            data["consultantIds"] = [];
            for (let item of this.consultantIds)
                data["consultantIds"].push(item);
        }
        return data;
    }
}

export interface IClientPeriodDto {
    id?: string;
    fullDisplayId?: string | undefined;
    name?: string | undefined;
    typeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
    consultantIds?: number[] | undefined;
}

export class ClientPeriodFinanceDataCommandDto implements IClientPeriodFinanceDataCommandDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;

    constructor(data?: IClientPeriodFinanceDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtorCreatedInNavision = _data["debtorCreatedInNavision"];
            this.differentDebtorNumberForInvoicing = _data["differentDebtorNumberForInvoicing"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantFinanceData"])) {
                this.consultantFinanceData = [] as any;
                for (let item of _data["consultantFinanceData"])
                    this.consultantFinanceData!.push(ConsultantPeriodFinanceDataDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocumentsCommandDto"])) {
                this.workflowDocumentsCommandDto = [] as any;
                for (let item of _data["workflowDocumentsCommandDto"])
                    this.workflowDocumentsCommandDto!.push(WorkflowDocumentCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodFinanceDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodFinanceDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtorCreatedInNavision"] = this.debtorCreatedInNavision;
        data["differentDebtorNumberForInvoicing"] = this.differentDebtorNumberForInvoicing;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantFinanceData)) {
            data["consultantFinanceData"] = [];
            for (let item of this.consultantFinanceData)
                data["consultantFinanceData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocumentsCommandDto)) {
            data["workflowDocumentsCommandDto"] = [];
            for (let item of this.workflowDocumentsCommandDto)
                data["workflowDocumentsCommandDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodFinanceDataCommandDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;
}

export class ClientPeriodFinanceDataQueryDto implements IClientPeriodFinanceDataQueryDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;

    constructor(data?: IClientPeriodFinanceDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtorCreatedInNavision = _data["debtorCreatedInNavision"];
            this.differentDebtorNumberForInvoicing = _data["differentDebtorNumberForInvoicing"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantFinanceData"])) {
                this.consultantFinanceData = [] as any;
                for (let item of _data["consultantFinanceData"])
                    this.consultantFinanceData!.push(ConsultantPeriodFinanceDataDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocuments"])) {
                this.workflowDocuments = [] as any;
                for (let item of _data["workflowDocuments"])
                    this.workflowDocuments!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodFinanceDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodFinanceDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtorCreatedInNavision"] = this.debtorCreatedInNavision;
        data["differentDebtorNumberForInvoicing"] = this.differentDebtorNumberForInvoicing;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantFinanceData)) {
            data["consultantFinanceData"] = [];
            for (let item of this.consultantFinanceData)
                data["consultantFinanceData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocuments)) {
            data["workflowDocuments"] = [];
            for (let item of this.workflowDocuments)
                data["workflowDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodFinanceDataQueryDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;
}

export class ClientPeriodMainDataDto implements IClientPeriodMainDataDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
    salesTypeDto?: EnumEntityTypeDto;
    deliveryTypeDto?: EnumEntityTypeDto;
    projectTypeDto?: EnumEntityTypeDto;
    projectCategoryDto?: EnumEntityTypeDto;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    marginTypeDto?: EnumEntityTypeDto;
    commissionAccountManager?: Pm3EmployeeDto;
    salesAccountManager?: Pm3EmployeeDto;
    primarySourcer?: Pm3EmployeeDto;
    otherCommissionedEmployees?: Pm3EmployeeDto[] | undefined;
    discount?: EnumEntityTypeDto;
    employmentType?: EnumEntityTypeDto;
    deliveryAccountManagerDto?: Pm3EmployeeDto;
    workplaceDto?: WorkplaceDto;
    periodCommissionDtos?: CommissionDetailsDto[] | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    invoicingReferenceContactDto?: ContactResultDto;
    evaluationReferenceContactDto?: ContactResultDto;
    consultantInsuranceOption?: ConsultantInsuranceOption;
    purchaseOrder?: PurchaseOrderSyncDto;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientClientId?: number | undefined;
    clientInvoicingRecipientLegacyId?: number | undefined;
    clientInvoicingRecipientTenantId?: number | undefined;
    clientInvoiceRecipientAddress?: ClientAddressDto;
    expectedWorkloadValue?: number | undefined;
    expectedWorkloadUnit?: number | undefined;
    timeReportingCap?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    directClientId?: number | undefined;
    directClientAddress?: ClientAddressDto;
    endClientId?: number | undefined;
    consultantId?: number | undefined;

    constructor(data?: IClientPeriodMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.projectLineId = _data["projectLineId"];
            this.salesTypeDto = _data["salesTypeDto"] ? EnumEntityTypeDto.fromJS(_data["salesTypeDto"]) : <any>undefined;
            this.deliveryTypeDto = _data["deliveryTypeDto"] ? EnumEntityTypeDto.fromJS(_data["deliveryTypeDto"]) : <any>undefined;
            this.projectTypeDto = _data["projectTypeDto"] ? EnumEntityTypeDto.fromJS(_data["projectTypeDto"]) : <any>undefined;
            this.projectCategoryDto = _data["projectCategoryDto"] ? EnumEntityTypeDto.fromJS(_data["projectCategoryDto"]) : <any>undefined;
            this.primaryCategoryArea = _data["primaryCategoryArea"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryArea"]) : <any>undefined;
            this.primaryCategoryType = _data["primaryCategoryType"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryType"]) : <any>undefined;
            this.primaryCategoryRole = _data["primaryCategoryRole"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryRole"]) : <any>undefined;
            this.marginTypeDto = _data["marginTypeDto"] ? EnumEntityTypeDto.fromJS(_data["marginTypeDto"]) : <any>undefined;
            this.commissionAccountManager = _data["commissionAccountManager"] ? Pm3EmployeeDto.fromJS(_data["commissionAccountManager"]) : <any>undefined;
            this.salesAccountManager = _data["salesAccountManager"] ? Pm3EmployeeDto.fromJS(_data["salesAccountManager"]) : <any>undefined;
            this.primarySourcer = _data["primarySourcer"] ? Pm3EmployeeDto.fromJS(_data["primarySourcer"]) : <any>undefined;
            if (Array.isArray(_data["otherCommissionedEmployees"])) {
                this.otherCommissionedEmployees = [] as any;
                for (let item of _data["otherCommissionedEmployees"])
                    this.otherCommissionedEmployees!.push(Pm3EmployeeDto.fromJS(item));
            }
            this.discount = _data["discount"] ? EnumEntityTypeDto.fromJS(_data["discount"]) : <any>undefined;
            this.employmentType = _data["employmentType"] ? EnumEntityTypeDto.fromJS(_data["employmentType"]) : <any>undefined;
            this.deliveryAccountManagerDto = _data["deliveryAccountManagerDto"] ? Pm3EmployeeDto.fromJS(_data["deliveryAccountManagerDto"]) : <any>undefined;
            this.workplaceDto = _data["workplaceDto"] ? WorkplaceDto.fromJS(_data["workplaceDto"]) : <any>undefined;
            if (Array.isArray(_data["periodCommissionDtos"])) {
                this.periodCommissionDtos = [] as any;
                for (let item of _data["periodCommissionDtos"])
                    this.periodCommissionDtos!.push(CommissionDetailsDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.invoicingReferenceContactDto = _data["invoicingReferenceContactDto"] ? ContactResultDto.fromJS(_data["invoicingReferenceContactDto"]) : <any>undefined;
            this.evaluationReferenceContactDto = _data["evaluationReferenceContactDto"] ? ContactResultDto.fromJS(_data["evaluationReferenceContactDto"]) : <any>undefined;
            this.consultantInsuranceOption = _data["consultantInsuranceOption"];
            this.purchaseOrder = _data["purchaseOrder"] ? PurchaseOrderSyncDto.fromJS(_data["purchaseOrder"]) : <any>undefined;
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipientClientId = _data["clientInvoicingRecipientClientId"];
            this.clientInvoicingRecipientLegacyId = _data["clientInvoicingRecipientLegacyId"];
            this.clientInvoicingRecipientTenantId = _data["clientInvoicingRecipientTenantId"];
            this.clientInvoiceRecipientAddress = _data["clientInvoiceRecipientAddress"] ? ClientAddressDto.fromJS(_data["clientInvoiceRecipientAddress"]) : <any>undefined;
            this.expectedWorkloadValue = _data["expectedWorkloadValue"];
            this.expectedWorkloadUnit = _data["expectedWorkloadUnit"];
            this.timeReportingCap = _data["timeReportingCap"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.directClientId = _data["directClientId"];
            this.directClientAddress = _data["directClientAddress"] ? ClientAddressDto.fromJS(_data["directClientAddress"]) : <any>undefined;
            this.endClientId = _data["endClientId"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ClientPeriodMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["projectLineId"] = this.projectLineId;
        data["salesTypeDto"] = this.salesTypeDto ? this.salesTypeDto.toJSON() : <any>undefined;
        data["deliveryTypeDto"] = this.deliveryTypeDto ? this.deliveryTypeDto.toJSON() : <any>undefined;
        data["projectTypeDto"] = this.projectTypeDto ? this.projectTypeDto.toJSON() : <any>undefined;
        data["projectCategoryDto"] = this.projectCategoryDto ? this.projectCategoryDto.toJSON() : <any>undefined;
        data["primaryCategoryArea"] = this.primaryCategoryArea ? this.primaryCategoryArea.toJSON() : <any>undefined;
        data["primaryCategoryType"] = this.primaryCategoryType ? this.primaryCategoryType.toJSON() : <any>undefined;
        data["primaryCategoryRole"] = this.primaryCategoryRole ? this.primaryCategoryRole.toJSON() : <any>undefined;
        data["marginTypeDto"] = this.marginTypeDto ? this.marginTypeDto.toJSON() : <any>undefined;
        data["commissionAccountManager"] = this.commissionAccountManager ? this.commissionAccountManager.toJSON() : <any>undefined;
        data["salesAccountManager"] = this.salesAccountManager ? this.salesAccountManager.toJSON() : <any>undefined;
        data["primarySourcer"] = this.primarySourcer ? this.primarySourcer.toJSON() : <any>undefined;
        if (Array.isArray(this.otherCommissionedEmployees)) {
            data["otherCommissionedEmployees"] = [];
            for (let item of this.otherCommissionedEmployees)
                data["otherCommissionedEmployees"].push(item.toJSON());
        }
        data["discount"] = this.discount ? this.discount.toJSON() : <any>undefined;
        data["employmentType"] = this.employmentType ? this.employmentType.toJSON() : <any>undefined;
        data["deliveryAccountManagerDto"] = this.deliveryAccountManagerDto ? this.deliveryAccountManagerDto.toJSON() : <any>undefined;
        data["workplaceDto"] = this.workplaceDto ? this.workplaceDto.toJSON() : <any>undefined;
        if (Array.isArray(this.periodCommissionDtos)) {
            data["periodCommissionDtos"] = [];
            for (let item of this.periodCommissionDtos)
                data["periodCommissionDtos"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["invoicingReferenceContactDto"] = this.invoicingReferenceContactDto ? this.invoicingReferenceContactDto.toJSON() : <any>undefined;
        data["evaluationReferenceContactDto"] = this.evaluationReferenceContactDto ? this.evaluationReferenceContactDto.toJSON() : <any>undefined;
        data["consultantInsuranceOption"] = this.consultantInsuranceOption;
        data["purchaseOrder"] = this.purchaseOrder ? this.purchaseOrder.toJSON() : <any>undefined;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipientClientId"] = this.clientInvoicingRecipientClientId;
        data["clientInvoicingRecipientLegacyId"] = this.clientInvoicingRecipientLegacyId;
        data["clientInvoicingRecipientTenantId"] = this.clientInvoicingRecipientTenantId;
        data["clientInvoiceRecipientAddress"] = this.clientInvoiceRecipientAddress ? this.clientInvoiceRecipientAddress.toJSON() : <any>undefined;
        data["expectedWorkloadValue"] = this.expectedWorkloadValue;
        data["expectedWorkloadUnit"] = this.expectedWorkloadUnit;
        data["timeReportingCap"] = this.timeReportingCap;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["directClientId"] = this.directClientId;
        data["directClientAddress"] = this.directClientAddress ? this.directClientAddress.toJSON() : <any>undefined;
        data["endClientId"] = this.endClientId;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IClientPeriodMainDataDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
    salesTypeDto?: EnumEntityTypeDto;
    deliveryTypeDto?: EnumEntityTypeDto;
    projectTypeDto?: EnumEntityTypeDto;
    projectCategoryDto?: EnumEntityTypeDto;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    marginTypeDto?: EnumEntityTypeDto;
    commissionAccountManager?: Pm3EmployeeDto;
    salesAccountManager?: Pm3EmployeeDto;
    primarySourcer?: Pm3EmployeeDto;
    otherCommissionedEmployees?: Pm3EmployeeDto[] | undefined;
    discount?: EnumEntityTypeDto;
    employmentType?: EnumEntityTypeDto;
    deliveryAccountManagerDto?: Pm3EmployeeDto;
    workplaceDto?: WorkplaceDto;
    periodCommissionDtos?: CommissionDetailsDto[] | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    invoicingReferenceContactDto?: ContactResultDto;
    evaluationReferenceContactDto?: ContactResultDto;
    consultantInsuranceOption?: ConsultantInsuranceOption;
    purchaseOrder?: PurchaseOrderSyncDto;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientClientId?: number | undefined;
    clientInvoicingRecipientLegacyId?: number | undefined;
    clientInvoicingRecipientTenantId?: number | undefined;
    clientInvoiceRecipientAddress?: ClientAddressDto;
    expectedWorkloadValue?: number | undefined;
    expectedWorkloadUnit?: number | undefined;
    timeReportingCap?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    directClientId?: number | undefined;
    directClientAddress?: ClientAddressDto;
    endClientId?: number | undefined;
    consultantId?: number | undefined;
}

export class ClientPeriodSalesDataCommandDto implements IClientPeriodSalesDataCommandDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    readonly setClientForNextPeriodsToo?: boolean;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;

    constructor(data?: IClientPeriodSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesMainData = _data["salesMainData"] ? SalesMainDataDto.fromJS(_data["salesMainData"]) : <any>undefined;
            this.salesClientData = _data["salesClientData"] ? SalesClientDataDto.fromJS(_data["salesClientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantSalesData"])) {
                this.consultantSalesData = [] as any;
                for (let item of _data["consultantSalesData"])
                    this.consultantSalesData!.push(ConsultantSalesDataDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            (<any>this).setClientForNextPeriodsToo = _data["setClientForNextPeriodsToo"];
            if (Array.isArray(_data["workflowDocumentsCommandDto"])) {
                this.workflowDocumentsCommandDto = [] as any;
                for (let item of _data["workflowDocumentsCommandDto"])
                    this.workflowDocumentsCommandDto!.push(WorkflowDocumentCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesMainData"] = this.salesMainData ? this.salesMainData.toJSON() : <any>undefined;
        data["salesClientData"] = this.salesClientData ? this.salesClientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantSalesData)) {
            data["consultantSalesData"] = [];
            for (let item of this.consultantSalesData)
                data["consultantSalesData"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["setClientForNextPeriodsToo"] = this.setClientForNextPeriodsToo;
        if (Array.isArray(this.workflowDocumentsCommandDto)) {
            data["workflowDocumentsCommandDto"] = [];
            for (let item of this.workflowDocumentsCommandDto)
                data["workflowDocumentsCommandDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodSalesDataCommandDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    setClientForNextPeriodsToo?: boolean;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;
}

export class ClientPeriodSalesDataQueryDto implements IClientPeriodSalesDataQueryDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;

    constructor(data?: IClientPeriodSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesMainData = _data["salesMainData"] ? SalesMainDataDto.fromJS(_data["salesMainData"]) : <any>undefined;
            this.salesClientData = _data["salesClientData"] ? SalesClientDataDto.fromJS(_data["salesClientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantSalesData"])) {
                this.consultantSalesData = [] as any;
                for (let item of _data["consultantSalesData"])
                    this.consultantSalesData!.push(ConsultantSalesDataDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["workflowDocuments"])) {
                this.workflowDocuments = [] as any;
                for (let item of _data["workflowDocuments"])
                    this.workflowDocuments!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesMainData"] = this.salesMainData ? this.salesMainData.toJSON() : <any>undefined;
        data["salesClientData"] = this.salesClientData ? this.salesClientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantSalesData)) {
            data["consultantSalesData"] = [];
            for (let item of this.consultantSalesData)
                data["consultantSalesData"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.workflowDocuments)) {
            data["workflowDocuments"] = [];
            for (let item of this.workflowDocuments)
                data["workflowDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodSalesDataQueryDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;
}

export class ClientPeriodSyncResultDto implements IClientPeriodSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    clientPeriodContractsData?: ClientPeriodContractsDataQueryDto;

    constructor(data?: IClientPeriodSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractSyncResult = _data["contractSyncResult"] ? ContractSyncResultDto.fromJS(_data["contractSyncResult"]) : <any>undefined;
            this.clientPeriodContractsData = _data["clientPeriodContractsData"] ? ClientPeriodContractsDataQueryDto.fromJS(_data["clientPeriodContractsData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientPeriodSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractSyncResult"] = this.contractSyncResult ? this.contractSyncResult.toJSON() : <any>undefined;
        data["clientPeriodContractsData"] = this.clientPeriodContractsData ? this.clientPeriodContractsData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientPeriodSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    clientPeriodContractsData?: ClientPeriodContractsDataQueryDto;
}

export class ClientRateDto implements IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IClientRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.invoiceCurrencyId = _data["invoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ClientRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["invoiceCurrencyId"] = this.invoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ClientRequestTrackItemDto implements IClientRequestTrackItemDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;

    constructor(data?: IClientRequestTrackItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.headline = _data["headline"];
            this.status = _data["status"] ? RequestStatusValueValueNameDto.fromJS(_data["status"]) : <any>undefined;
            this.clientDeadline = _data["clientDeadline"] ? moment(_data["clientDeadline"].toString()) : <any>undefined;
            this.dateAdded = _data["dateAdded"] ? moment(_data["dateAdded"].toString()) : <any>undefined;
            this.projectType = _data["projectType"] ? RequestProjectTypeValueValueNameDto.fromJS(_data["projectType"]) : <any>undefined;
            this.priority = _data["priority"];
            this.numberOfConsultants = _data["numberOfConsultants"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(SimpleRequestLocationDto.fromJS(item));
            }
            if (Array.isArray(_data["requestSourcers"])) {
                this.requestSourcers = [] as any;
                for (let item of _data["requestSourcers"])
                    this.requestSourcers!.push(EmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["accountManagers"])) {
                this.accountManagers = [] as any;
                for (let item of _data["accountManagers"])
                    this.accountManagers!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRequestTrackItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["headline"] = this.headline;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["clientDeadline"] = this.clientDeadline ? this.clientDeadline.toISOString() : <any>undefined;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["priority"] = this.priority;
        data["numberOfConsultants"] = this.numberOfConsultants;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.requestSourcers)) {
            data["requestSourcers"] = [];
            for (let item of this.requestSourcers)
                data["requestSourcers"].push(item.toJSON());
        }
        if (Array.isArray(this.accountManagers)) {
            data["accountManagers"] = [];
            for (let item of this.accountManagers)
                data["accountManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientRequestTrackItemDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;
}

export class ClientRequestTrackItemDtoPaginatedList implements IClientRequestTrackItemDtoPaginatedList {
    items?: ClientRequestTrackItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientRequestTrackItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientRequestTrackItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientRequestTrackItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientRequestTrackItemDtoPaginatedList {
    items?: ClientRequestTrackItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientResultDto implements IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    clientAddresses?: ClientAddressDto[] | undefined;
    vatNumber?: string | undefined;
    tenantCountryCode?: string | undefined;
    readonly crmClientId?: number | undefined;

    constructor(data?: IClientResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            if (Array.isArray(_data["clientAddresses"])) {
                this.clientAddresses = [] as any;
                for (let item of _data["clientAddresses"])
                    this.clientAddresses!.push(ClientAddressDto.fromJS(item));
            }
            this.vatNumber = _data["vatNumber"];
            this.tenantCountryCode = _data["tenantCountryCode"];
            (<any>this).crmClientId = _data["crmClientId"];
        }
    }

    static fromJS(data: any): ClientResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        if (Array.isArray(this.clientAddresses)) {
            data["clientAddresses"] = [];
            for (let item of this.clientAddresses)
                data["clientAddresses"].push(item.toJSON());
        }
        data["vatNumber"] = this.vatNumber;
        data["tenantCountryCode"] = this.tenantCountryCode;
        data["crmClientId"] = this.crmClientId;
        return data;
    }
}

export interface IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    clientAddresses?: ClientAddressDto[] | undefined;
    vatNumber?: string | undefined;
    tenantCountryCode?: string | undefined;
    crmClientId?: number | undefined;
}

export class ClientSpecialFeeDto implements IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequency = _data["clientSpecialFeeFrequency"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeFrequency"]) : <any>undefined;
            this.clientSpecialFeeSpecifiedAs = _data["clientSpecialFeeSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrency = _data["prodataToProdataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["prodataToProdataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequency"] = this.clientSpecialFeeFrequency ? this.clientSpecialFeeFrequency.toJSON() : <any>undefined;
        data["clientSpecialFeeSpecifiedAs"] = this.clientSpecialFeeSpecifiedAs ? this.clientSpecialFeeSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrency"] = this.prodataToProdataRateCurrency ? this.prodataToProdataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientSpecialRateDto implements IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnit = _data["specialRateReportingUnit"] ? SpecialRateReportingUnit.fromJS(_data["specialRateReportingUnit"]) : <any>undefined;
            this.specialRateSpecifiedAs = _data["specialRateSpecifiedAs"] ? SpecialRateSpecifiedAs.fromJS(_data["specialRateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.proDataToProDataRate = _data["proDataToProDataRate"];
            this.proDataToProDataRateCurrency = _data["proDataToProDataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["proDataToProDataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnit"] = this.specialRateReportingUnit ? this.specialRateReportingUnit.toJSON() : <any>undefined;
        data["specialRateSpecifiedAs"] = this.specialRateSpecifiedAs ? this.specialRateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["proDataToProDataRate"] = this.proDataToProDataRate;
        data["proDataToProDataRateCurrency"] = this.proDataToProDataRateCurrency ? this.proDataToProDataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientWFResponsibleDto implements IClientWFResponsibleDto {
    clientId?: number;
    contractStepResponsibleEmployee?: EmployeeDto;
    financeStepResponsibleEmployee?: EmployeeDto;

    constructor(data?: IClientWFResponsibleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.contractStepResponsibleEmployee = _data["contractStepResponsibleEmployee"] ? EmployeeDto.fromJS(_data["contractStepResponsibleEmployee"]) : <any>undefined;
            this.financeStepResponsibleEmployee = _data["financeStepResponsibleEmployee"] ? EmployeeDto.fromJS(_data["financeStepResponsibleEmployee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientWFResponsibleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWFResponsibleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["contractStepResponsibleEmployee"] = this.contractStepResponsibleEmployee ? this.contractStepResponsibleEmployee.toJSON() : <any>undefined;
        data["financeStepResponsibleEmployee"] = this.financeStepResponsibleEmployee ? this.financeStepResponsibleEmployee.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientWFResponsibleDto {
    clientId?: number;
    contractStepResponsibleEmployee?: EmployeeDto;
    financeStepResponsibleEmployee?: EmployeeDto;
}

export class ClientWorkflowTrackItemDto implements IClientWorkflowTrackItemDto {
    workflowId?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    invoicingReferencePerson?: ContactDto;

    constructor(data?: IClientWorkflowTrackItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.workflowStatusWithEmployee = _data["workflowStatusWithEmployee"] ? WorkflowStatusWithEmployeeDto.fromJS(_data["workflowStatusWithEmployee"]) : <any>undefined;
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(ConsultantResultDto.fromJS(item));
            }
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientWorkflowTrackItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTrackItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["workflowStatusWithEmployee"] = this.workflowStatusWithEmployee ? this.workflowStatusWithEmployee.toJSON() : <any>undefined;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClientWorkflowTrackItemDto {
    workflowId?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatusWithEmployee?: WorkflowStatusWithEmployeeDto;
    consultants?: ConsultantResultDto[] | undefined;
    invoicingReferencePerson?: ContactDto;
}

export class ClientWorkflowTrackItemDtoPaginatedList implements IClientWorkflowTrackItemDtoPaginatedList {
    items?: ClientWorkflowTrackItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientWorkflowTrackItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientWorkflowTrackItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientWorkflowTrackItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTrackItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientWorkflowTrackItemDtoPaginatedList {
    items?: ClientWorkflowTrackItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientWorkflowTreeItemDto implements IClientWorkflowTreeItemDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    clientContracts?: ClientContractBaseDto[] | undefined;
    consultantContracts?: ClientContractBaseDto[] | undefined;
    internalContracts?: ClientContractBaseDto[] | undefined;

    constructor(data?: IClientWorkflowTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.statusColorEnum = _data["statusColorEnum"];
            if (Array.isArray(_data["clientContracts"])) {
                this.clientContracts = [] as any;
                for (let item of _data["clientContracts"])
                    this.clientContracts!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantContracts"])) {
                this.consultantContracts = [] as any;
                for (let item of _data["consultantContracts"])
                    this.consultantContracts!.push(ClientContractBaseDto.fromJS(item));
            }
            if (Array.isArray(_data["internalContracts"])) {
                this.internalContracts = [] as any;
                for (let item of _data["internalContracts"])
                    this.internalContracts!.push(ClientContractBaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientWorkflowTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWorkflowTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["statusColorEnum"] = this.statusColorEnum;
        if (Array.isArray(this.clientContracts)) {
            data["clientContracts"] = [];
            for (let item of this.clientContracts)
                data["clientContracts"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantContracts)) {
            data["consultantContracts"] = [];
            for (let item of this.consultantContracts)
                data["consultantContracts"].push(item.toJSON());
        }
        if (Array.isArray(this.internalContracts)) {
            data["internalContracts"] = [];
            for (let item of this.internalContracts)
                data["internalContracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientWorkflowTreeItemDto {
    id?: string;
    name?: string | undefined;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
    statusColorEnum?: ContractPaperStatusColorEnum;
    clientContracts?: ClientContractBaseDto[] | undefined;
    consultantContracts?: ClientContractBaseDto[] | undefined;
    internalContracts?: ClientContractBaseDto[] | undefined;
}

export class CommentInputDto implements ICommentInputDto {
    text?: string | undefined;
    metadata?: string | undefined;

    constructor(data?: ICommentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): CommentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface ICommentInputDto {
    text?: string | undefined;
    metadata?: string | undefined;
}

export class CommissionDetailsDto implements ICommissionDetailsDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    legalEntityId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
    emagineOfficeCountryName?: string | undefined;
    currencyName?: string | undefined;

    constructor(data?: ICommissionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierResultDto.fromJS(_data["supplier"]) : <any>undefined;
            this.legalEntityId = _data["legalEntityId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientResultDto.fromJS(_data["client"]) : <any>undefined;
            this.emagineOfficeCountryName = _data["emagineOfficeCountryName"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): CommissionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["legalEntityId"] = this.legalEntityId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["emagineOfficeCountryName"] = this.emagineOfficeCountryName;
        data["currencyName"] = this.currencyName;
        return data;
    }
}

export interface ICommissionDetailsDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    legalEntityId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
    emagineOfficeCountryName?: string | undefined;
    currencyName?: string | undefined;
}

export class CommissionDto implements ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    legalEntityId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;

    constructor(data?: ICommissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierResultDto.fromJS(_data["supplier"]) : <any>undefined;
            this.legalEntityId = _data["legalEntityId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientResultDto.fromJS(_data["client"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["legalEntityId"] = this.legalEntityId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    legalEntityId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
}

export class CompleteAgreementDocumentFileDraftDto implements ICompleteAgreementDocumentFileDraftDto {
    versionDescription?: string | undefined;

    constructor(data?: ICompleteAgreementDocumentFileDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionDescription = _data["versionDescription"];
        }
    }

    static fromJS(data: any): CompleteAgreementDocumentFileDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteAgreementDocumentFileDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionDescription"] = this.versionDescription;
        return data;
    }
}

export interface ICompleteAgreementDocumentFileDraftDto {
    versionDescription?: string | undefined;
}

export class CompleteTemplateDocumentFileDraftDto implements ICompleteTemplateDocumentFileDraftDto {
    versionDescription?: string | undefined;
    propagateChangesToDerivedTemplates?: boolean | undefined;
    markActiveAgreementsAsOutdated?: boolean;

    constructor(data?: ICompleteTemplateDocumentFileDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionDescription = _data["versionDescription"];
            this.propagateChangesToDerivedTemplates = _data["propagateChangesToDerivedTemplates"];
            this.markActiveAgreementsAsOutdated = _data["markActiveAgreementsAsOutdated"];
        }
    }

    static fromJS(data: any): CompleteTemplateDocumentFileDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTemplateDocumentFileDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionDescription"] = this.versionDescription;
        data["propagateChangesToDerivedTemplates"] = this.propagateChangesToDerivedTemplates;
        data["markActiveAgreementsAsOutdated"] = this.markActiveAgreementsAsOutdated;
        return data;
    }
}

export interface ICompleteTemplateDocumentFileDraftDto {
    versionDescription?: string | undefined;
    propagateChangesToDerivedTemplates?: boolean | undefined;
    markActiveAgreementsAsOutdated?: boolean;
}

export class ConsultantContractsDataCommandDto implements IConsultantContractsDataCommandDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;

    constructor(data?: IConsultantContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialPaymentTerms = _data["noSpecialPaymentTerms"];
            this.specialPaymentTerms = _data["specialPaymentTerms"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantFrameAgreementId = _data["consultantFrameAgreementId"];
            this.emagineToEmagineFrameAgreementId = _data["emagineToEmagineFrameAgreementId"];
        }
    }

    static fromJS(data: any): ConsultantContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialPaymentTerms"] = this.noSpecialPaymentTerms;
        data["specialPaymentTerms"] = this.specialPaymentTerms;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantFrameAgreementId"] = this.consultantFrameAgreementId;
        data["emagineToEmagineFrameAgreementId"] = this.emagineToEmagineFrameAgreementId;
        return data;
    }
}

export interface IConsultantContractsDataCommandDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;
}

export class ConsultantContractsDataQueryDto implements IConsultantContractsDataQueryDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;
    internalLegalContractDoneStatusId?: number;
    consultantLegalContractDoneStatusId?: number;

    constructor(data?: IConsultantContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialPaymentTerms = _data["noSpecialPaymentTerms"];
            this.specialPaymentTerms = _data["specialPaymentTerms"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantFrameAgreementId = _data["consultantFrameAgreementId"];
            this.emagineToEmagineFrameAgreementId = _data["emagineToEmagineFrameAgreementId"];
            this.internalLegalContractDoneStatusId = _data["internalLegalContractDoneStatusId"];
            this.consultantLegalContractDoneStatusId = _data["consultantLegalContractDoneStatusId"];
        }
    }

    static fromJS(data: any): ConsultantContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialPaymentTerms"] = this.noSpecialPaymentTerms;
        data["specialPaymentTerms"] = this.specialPaymentTerms;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantFrameAgreementId"] = this.consultantFrameAgreementId;
        data["emagineToEmagineFrameAgreementId"] = this.emagineToEmagineFrameAgreementId;
        data["internalLegalContractDoneStatusId"] = this.internalLegalContractDoneStatusId;
        data["consultantLegalContractDoneStatusId"] = this.consultantLegalContractDoneStatusId;
        return data;
    }
}

export interface IConsultantContractsDataQueryDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;
    internalLegalContractDoneStatusId?: number;
    consultantLegalContractDoneStatusId?: number;
}

export class ConsultantGanttRow implements IConsultantGanttRow {
    name?: string | undefined;
    consultantId?: number | undefined;
    consultantExternalId?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;

    constructor(data?: IConsultantGanttRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.consultantId = _data["consultantId"];
            this.consultantExternalId = _data["consultantExternalId"];
            if (Array.isArray(_data["ganttRowItems"])) {
                this.ganttRowItems = [] as any;
                for (let item of _data["ganttRowItems"])
                    this.ganttRowItems!.push(GanttRowItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsultantGanttRow {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantGanttRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["consultantId"] = this.consultantId;
        data["consultantExternalId"] = this.consultantExternalId;
        if (Array.isArray(this.ganttRowItems)) {
            data["ganttRowItems"] = [];
            for (let item of this.ganttRowItems)
                data["ganttRowItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConsultantGanttRow {
    name?: string | undefined;
    consultantId?: number | undefined;
    consultantExternalId?: string | undefined;
    ganttRowItems?: GanttRowItem[] | undefined;
}

export enum ConsultantInsuranceOption {
    None = 0,
    DkInsurance = 1,
    PlMedicare = 4,
}

export class ConsultantNameWithRequestUrl implements IConsultantNameWithRequestUrl {
    consultantId?: number;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    requestId?: number | undefined;
    requestUrl?: string | undefined;

    constructor(data?: IConsultantNameWithRequestUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultantName = _data["consultantName"];
            this.companyName = _data["companyName"];
            this.requestId = _data["requestId"];
            this.requestUrl = _data["requestUrl"];
        }
    }

    static fromJS(data: any): ConsultantNameWithRequestUrl {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantNameWithRequestUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultantName"] = this.consultantName;
        data["companyName"] = this.companyName;
        data["requestId"] = this.requestId;
        data["requestUrl"] = this.requestUrl;
        return data;
    }
}

export interface IConsultantNameWithRequestUrl {
    consultantId?: number;
    consultantName?: string | undefined;
    companyName?: string | undefined;
    requestId?: number | undefined;
    requestUrl?: string | undefined;
}

export class ConsultantPeriodAddDto implements IConsultantPeriodAddDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IConsultantPeriodAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodAddDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class ConsultantPeriodAgreementsDto implements IConsultantPeriodAgreementsDto {
    consultantAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    emagineToEmagineAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    creationPendingEmployeeDtos?: EmployeeDto[] | undefined;

    constructor(data?: IConsultantPeriodAgreementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantAgreements"])) {
                this.consultantAgreements = [] as any;
                for (let item of _data["consultantAgreements"])
                    this.consultantAgreements!.push(WorkflowPeriodAgreementDto.fromJS(item));
            }
            if (Array.isArray(_data["emagineToEmagineAgreements"])) {
                this.emagineToEmagineAgreements = [] as any;
                for (let item of _data["emagineToEmagineAgreements"])
                    this.emagineToEmagineAgreements!.push(WorkflowPeriodAgreementDto.fromJS(item));
            }
            if (Array.isArray(_data["creationPendingEmployeeDtos"])) {
                this.creationPendingEmployeeDtos = [] as any;
                for (let item of _data["creationPendingEmployeeDtos"])
                    this.creationPendingEmployeeDtos!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsultantPeriodAgreementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodAgreementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantAgreements)) {
            data["consultantAgreements"] = [];
            for (let item of this.consultantAgreements)
                data["consultantAgreements"].push(item.toJSON());
        }
        if (Array.isArray(this.emagineToEmagineAgreements)) {
            data["emagineToEmagineAgreements"] = [];
            for (let item of this.emagineToEmagineAgreements)
                data["emagineToEmagineAgreements"].push(item.toJSON());
        }
        if (Array.isArray(this.creationPendingEmployeeDtos)) {
            data["creationPendingEmployeeDtos"] = [];
            for (let item of this.creationPendingEmployeeDtos)
                data["creationPendingEmployeeDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConsultantPeriodAgreementsDto {
    consultantAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    emagineToEmagineAgreements?: WorkflowPeriodAgreementDto[] | undefined;
    creationPendingEmployeeDtos?: EmployeeDto[] | undefined;
}

export class ConsultantPeriodContractsDataCommandDto implements IConsultantPeriodContractsDataCommandDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;

    constructor(data?: IConsultantPeriodContractsDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.newLegalContractRequired = _data["newLegalContractRequired"];
            this.consultantData = _data["consultantData"] ? ConsultantContractsDataCommandDto.fromJS(_data["consultantData"]) : <any>undefined;
            this.bypassLegalValidation = _data["bypassLegalValidation"];
            this.skipOptionalLegalContractsValidation = _data["skipOptionalLegalContractsValidation"];
        }
    }

    static fromJS(data: any): ConsultantPeriodContractsDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodContractsDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        data["consultantData"] = this.consultantData ? this.consultantData.toJSON() : <any>undefined;
        data["bypassLegalValidation"] = this.bypassLegalValidation;
        data["skipOptionalLegalContractsValidation"] = this.skipOptionalLegalContractsValidation;
        return data;
    }
}

export interface IConsultantPeriodContractsDataCommandDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    consultantData?: ConsultantContractsDataCommandDto;
    bypassLegalValidation?: boolean | undefined;
    skipOptionalLegalContractsValidation?: boolean | undefined;
}

export class ConsultantPeriodContractsDataQueryDto implements IConsultantPeriodContractsDataQueryDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    clientData?: ContractsClientDataDto;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto;

    constructor(data?: IConsultantPeriodContractsDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.newLegalContractRequired = _data["newLegalContractRequired"];
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            this.consultantData = _data["consultantData"] ? ConsultantContractsDataQueryDto.fromJS(_data["consultantData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodContractsDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodContractsDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["newLegalContractRequired"] = this.newLegalContractRequired;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        data["customDebtorNumber"] = this.customDebtorNumber;
        data["consultantData"] = this.consultantData ? this.consultantData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodContractsDataQueryDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    mainData?: ContractsMainDataDto;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
    newLegalContractRequired?: boolean | undefined;
    clientData?: ContractsClientDataDto;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    enableLegalContractsButtons?: boolean;
    customDebtorNumber?: string | undefined;
    consultantData?: ConsultantContractsDataQueryDto;
}

export class ConsultantPeriodFinanceDataDto implements IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;

    constructor(data?: IConsultantPeriodFinanceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.checkInvoicingSettingsOnConsultant = _data["checkInvoicingSettingsOnConsultant"];
            this.creditorCreatedInNavision = _data["creditorCreatedInNavision"];
        }
    }

    static fromJS(data: any): ConsultantPeriodFinanceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodFinanceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["checkInvoicingSettingsOnConsultant"] = this.checkInvoicingSettingsOnConsultant;
        data["creditorCreatedInNavision"] = this.creditorCreatedInNavision;
        return data;
    }
}

export interface IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;
}

export class ConsultantPeriodMainDataBasicDto implements IConsultantPeriodMainDataBasicDto {
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    directLegacyClientId?: number | undefined;
    directLegacyClientTenantId?: number | undefined;
    endClientLegacyClientId?: number | undefined;
    endClientLegacyClientTenantId?: number | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    consultantName?: string | undefined;
    projectLineIds?: number[] | undefined;
    clientLegalContractDoneStatus?: number | undefined;

    constructor(data?: IConsultantPeriodMainDataBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legacyConsultantId = _data["legacyConsultantId"];
            this.consultantTenantId = _data["consultantTenantId"];
            this.workflowId = _data["workflowId"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.directLegacyClientId = _data["directLegacyClientId"];
            this.directLegacyClientTenantId = _data["directLegacyClientTenantId"];
            this.endClientLegacyClientId = _data["endClientLegacyClientId"];
            this.endClientLegacyClientTenantId = _data["endClientLegacyClientTenantId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.consultantName = _data["consultantName"];
            if (Array.isArray(_data["projectLineIds"])) {
                this.projectLineIds = [] as any;
                for (let item of _data["projectLineIds"])
                    this.projectLineIds!.push(item);
            }
            this.clientLegalContractDoneStatus = _data["clientLegalContractDoneStatus"];
        }
    }

    static fromJS(data: any): ConsultantPeriodMainDataBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodMainDataBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legacyConsultantId"] = this.legacyConsultantId;
        data["consultantTenantId"] = this.consultantTenantId;
        data["workflowId"] = this.workflowId;
        data["clientPeriodId"] = this.clientPeriodId;
        data["directLegacyClientId"] = this.directLegacyClientId;
        data["directLegacyClientTenantId"] = this.directLegacyClientTenantId;
        data["endClientLegacyClientId"] = this.endClientLegacyClientId;
        data["endClientLegacyClientTenantId"] = this.endClientLegacyClientTenantId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["consultantName"] = this.consultantName;
        if (Array.isArray(this.projectLineIds)) {
            data["projectLineIds"] = [];
            for (let item of this.projectLineIds)
                data["projectLineIds"].push(item);
        }
        data["clientLegalContractDoneStatus"] = this.clientLegalContractDoneStatus;
        return data;
    }
}

export interface IConsultantPeriodMainDataBasicDto {
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    directLegacyClientId?: number | undefined;
    directLegacyClientTenantId?: number | undefined;
    endClientLegacyClientId?: number | undefined;
    endClientLegacyClientTenantId?: number | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    consultantName?: string | undefined;
    projectLineIds?: number[] | undefined;
    clientLegalContractDoneStatus?: number | undefined;
}

export class ConsultantPeriodSalesDataDto implements IConsultantPeriodSalesDataDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    consultantSalesData?: ConsultantSalesDataDto;
    directClientIdValue?: number | undefined;
    clientRate?: ClientRateDto;
    clientPeriodPdcInvoicingEntityId?: number | undefined;

    constructor(data?: IConsultantPeriodSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.consultantSalesData = _data["consultantSalesData"] ? ConsultantSalesDataDto.fromJS(_data["consultantSalesData"]) : <any>undefined;
            this.directClientIdValue = _data["directClientIdValue"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.clientPeriodPdcInvoicingEntityId = _data["clientPeriodPdcInvoicingEntityId"];
        }
    }

    static fromJS(data: any): ConsultantPeriodSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["consultantSalesData"] = this.consultantSalesData ? this.consultantSalesData.toJSON() : <any>undefined;
        data["directClientIdValue"] = this.directClientIdValue;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["clientPeriodPdcInvoicingEntityId"] = this.clientPeriodPdcInvoicingEntityId;
        return data;
    }
}

export interface IConsultantPeriodSalesDataDto {
    remarks?: string | undefined;
    noRemarks?: boolean;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    consultantSalesData?: ConsultantSalesDataDto;
    directClientIdValue?: number | undefined;
    clientRate?: ClientRateDto;
    clientPeriodPdcInvoicingEntityId?: number | undefined;
}

export class ConsultantPeriodSyncResultDto implements IConsultantPeriodSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    consultantPeriodContractsData?: ConsultantPeriodContractsDataQueryDto;

    constructor(data?: IConsultantPeriodSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractSyncResult = _data["contractSyncResult"] ? ContractSyncResultDto.fromJS(_data["contractSyncResult"]) : <any>undefined;
            this.consultantPeriodContractsData = _data["consultantPeriodContractsData"] ? ConsultantPeriodContractsDataQueryDto.fromJS(_data["consultantPeriodContractsData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantPeriodSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractSyncResult"] = this.contractSyncResult ? this.contractSyncResult.toJSON() : <any>undefined;
        data["consultantPeriodContractsData"] = this.consultantPeriodContractsData ? this.consultantPeriodContractsData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantPeriodSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    consultantPeriodContractsData?: ConsultantPeriodContractsDataQueryDto;
}

export class ConsultantRateDto implements IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    internalRateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IConsultantRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataCurrencyId = _data["prodataToProdataCurrencyId"];
            this.prodataToProdataInvoiceCurrencyId = _data["prodataToProdataInvoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.internalRateUnitTypeId = _data["internalRateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ConsultantRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataCurrencyId"] = this.prodataToProdataCurrencyId;
        data["prodataToProdataInvoiceCurrencyId"] = this.prodataToProdataInvoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["internalRateUnitTypeId"] = this.internalRateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    internalRateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ConsultantResultDto implements IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    tenantId?: number;
    externalId?: string;
    email?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    address?: string | undefined;
    companyName?: string | undefined;
    vatNumber?: string | undefined;
    addressCountryCode?: string | undefined;
    countryId?: number | undefined;
    tenantCountryCode?: string | undefined;
    supplierId?: number | undefined;

    constructor(data?: IConsultantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.legacyId = _data["legacyId"];
            this.tenantId = _data["tenantId"];
            this.externalId = _data["externalId"];
            this.email = _data["email"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.address = _data["address"];
            this.companyName = _data["companyName"];
            this.vatNumber = _data["vatNumber"];
            this.addressCountryCode = _data["addressCountryCode"];
            this.countryId = _data["countryId"];
            this.tenantCountryCode = _data["tenantCountryCode"];
            this.supplierId = _data["supplierId"];
        }
    }

    static fromJS(data: any): ConsultantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["legacyId"] = this.legacyId;
        data["tenantId"] = this.tenantId;
        data["externalId"] = this.externalId;
        data["email"] = this.email;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["address"] = this.address;
        data["companyName"] = this.companyName;
        data["vatNumber"] = this.vatNumber;
        data["addressCountryCode"] = this.addressCountryCode;
        data["countryId"] = this.countryId;
        data["tenantCountryCode"] = this.tenantCountryCode;
        data["supplierId"] = this.supplierId;
        return data;
    }
}

export interface IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    tenantId?: number;
    externalId?: string;
    email?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    address?: string | undefined;
    companyName?: string | undefined;
    vatNumber?: string | undefined;
    addressCountryCode?: string | undefined;
    countryId?: number | undefined;
    tenantCountryCode?: string | undefined;
    supplierId?: number | undefined;
}

export class ConsultantSalesDataDto implements IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantPeriodId?: string | undefined;
    soldRequestConsultantId?: number | undefined;
    requestId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    durationSameAsClientPeriod?: boolean;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean | undefined;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientSameAsDirectClient?: boolean;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    onsiteClientAddressId?: number | undefined;
    onsiteClientAddress?: ClientAddressDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSupplierSigners?: ContractSupplierSignerDto[] | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;

    constructor(data?: IConsultantSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
            this.requestId = _data["requestId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.durationSameAsClientPeriod = _data["durationSameAsClientPeriod"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isOnsiteWorkplace = _data["isOnsiteWorkplace"];
            this.onsiteClientSameAsDirectClient = _data["onsiteClientSameAsDirectClient"];
            this.onsiteClientId = _data["onsiteClientId"];
            this.onsiteClient = _data["onsiteClient"] ? ClientResultDto.fromJS(_data["onsiteClient"]) : <any>undefined;
            this.onsiteClientAddressId = _data["onsiteClientAddressId"];
            this.onsiteClientAddress = _data["onsiteClientAddress"] ? ClientAddressDto.fromJS(_data["onsiteClientAddress"]) : <any>undefined;
            this.isEmagineOfficeWorkplace = _data["isEmagineOfficeWorkplace"];
            this.emagineOfficeId = _data["emagineOfficeId"];
            this.isRemoteWorkplace = _data["isRemoteWorkplace"];
            this.remoteAddressCountryId = _data["remoteAddressCountryId"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.noExpectedWorkload = _data["noExpectedWorkload"];
            this.expectedWorkloadHours = _data["expectedWorkloadHours"];
            this.expectedWorkloadUnitId = _data["expectedWorkloadUnitId"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            if (Array.isArray(_data["contractSupplierSigners"])) {
                this.contractSupplierSigners = [] as any;
                for (let item of _data["contractSupplierSigners"])
                    this.contractSupplierSigners!.push(ContractSupplierSignerDto.fromJS(item));
            }
            this.noSpecialPaymentTerms = _data["noSpecialPaymentTerms"];
            this.specialPaymentTerms = _data["specialPaymentTerms"];
            this.deliveryManagerSameAsAccountManager = _data["deliveryManagerSameAsAccountManager"];
            this.deliveryAccountManagerIdValue = _data["deliveryAccountManagerIdValue"];
            this.deliveryAccountManager = _data["deliveryAccountManager"] ? EmployeeDto.fromJS(_data["deliveryAccountManager"]) : <any>undefined;
            this.consultantFrameAgreementId = _data["consultantFrameAgreementId"];
            this.emagineToEmagineFrameAgreementId = _data["emagineToEmagineFrameAgreementId"];
        }
    }

    static fromJS(data: any): ConsultantSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        data["requestId"] = this.requestId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["durationSameAsClientPeriod"] = this.durationSameAsClientPeriod;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isOnsiteWorkplace"] = this.isOnsiteWorkplace;
        data["onsiteClientSameAsDirectClient"] = this.onsiteClientSameAsDirectClient;
        data["onsiteClientId"] = this.onsiteClientId;
        data["onsiteClient"] = this.onsiteClient ? this.onsiteClient.toJSON() : <any>undefined;
        data["onsiteClientAddressId"] = this.onsiteClientAddressId;
        data["onsiteClientAddress"] = this.onsiteClientAddress ? this.onsiteClientAddress.toJSON() : <any>undefined;
        data["isEmagineOfficeWorkplace"] = this.isEmagineOfficeWorkplace;
        data["emagineOfficeId"] = this.emagineOfficeId;
        data["isRemoteWorkplace"] = this.isRemoteWorkplace;
        data["remoteAddressCountryId"] = this.remoteAddressCountryId;
        data["percentageOnSite"] = this.percentageOnSite;
        data["noExpectedWorkload"] = this.noExpectedWorkload;
        data["expectedWorkloadHours"] = this.expectedWorkloadHours;
        data["expectedWorkloadUnitId"] = this.expectedWorkloadUnitId;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        if (Array.isArray(this.contractSupplierSigners)) {
            data["contractSupplierSigners"] = [];
            for (let item of this.contractSupplierSigners)
                data["contractSupplierSigners"].push(item.toJSON());
        }
        data["noSpecialPaymentTerms"] = this.noSpecialPaymentTerms;
        data["specialPaymentTerms"] = this.specialPaymentTerms;
        data["deliveryManagerSameAsAccountManager"] = this.deliveryManagerSameAsAccountManager;
        data["deliveryAccountManagerIdValue"] = this.deliveryAccountManagerIdValue;
        data["deliveryAccountManager"] = this.deliveryAccountManager ? this.deliveryAccountManager.toJSON() : <any>undefined;
        data["consultantFrameAgreementId"] = this.consultantFrameAgreementId;
        data["emagineToEmagineFrameAgreementId"] = this.emagineToEmagineFrameAgreementId;
        return data;
    }
}

export interface IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantPeriodId?: string | undefined;
    soldRequestConsultantId?: number | undefined;
    requestId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    durationSameAsClientPeriod?: boolean;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean | undefined;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientSameAsDirectClient?: boolean;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    onsiteClientAddressId?: number | undefined;
    onsiteClientAddress?: ClientAddressDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSupplierSigners?: ContractSupplierSignerDto[] | undefined;
    noSpecialPaymentTerms?: boolean;
    specialPaymentTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;
    consultantFrameAgreementId?: number | undefined;
    emagineToEmagineFrameAgreementId?: number | undefined;
}

export enum ConsultantShownOnClientInvoiceAs {
    ConsultantName = 1,
    ConsultantId = 2,
}

export class ConsultantTerminationContractDataCommandDto implements IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationContractDataQueryDto implements IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    consultant?: ConsultantResultDto;
}

export class ConsultantTerminationSalesDataCommandDto implements IConsultantTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;

    constructor(data?: IConsultantTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        return data;
    }
}

export interface IConsultantTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
}

export class ConsultantTerminationSalesDataQueryDto implements IConsultantTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    directClientId?: number;
    endClientId?: number | undefined;
    finalEvaluationReferencePerson?: ContactDto;

    constructor(data?: IConsultantTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.directClientId = _data["directClientId"];
            this.endClientId = _data["endClientId"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["directClientId"] = this.directClientId;
        data["endClientId"] = this.endClientId;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    directClientId?: number;
    endClientId?: number | undefined;
    finalEvaluationReferencePerson?: ContactDto;
}

export class ConsultantTerminationSourcingDataCommandDto implements IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationSourcingDataQueryDto implements IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;
}

export class ConsultantTerminationSyncResultDto implements IConsultantTerminationSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto;

    constructor(data?: IConsultantTerminationSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractSyncResult = _data["contractSyncResult"] ? ContractSyncResultDto.fromJS(_data["contractSyncResult"]) : <any>undefined;
            this.consultantTerminationContractData = _data["consultantTerminationContractData"] ? ConsultantTerminationContractDataQueryDto.fromJS(_data["consultantTerminationContractData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractSyncResult"] = this.contractSyncResult ? this.contractSyncResult.toJSON() : <any>undefined;
        data["consultantTerminationContractData"] = this.consultantTerminationContractData ? this.consultantTerminationContractData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto;
}

export class ConsultantWithSourcingRequestResultDto implements IConsultantWithSourcingRequestResultDto {
    consultant?: ConsultantResultDto;
    sourcingRequestConsultantId?: number | undefined;
    sourcingRequestId?: number | undefined;
    sourcingRequestConsultantHeadline?: string | undefined;

    constructor(data?: IConsultantWithSourcingRequestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.sourcingRequestConsultantId = _data["sourcingRequestConsultantId"];
            this.sourcingRequestId = _data["sourcingRequestId"];
            this.sourcingRequestConsultantHeadline = _data["sourcingRequestConsultantHeadline"];
        }
    }

    static fromJS(data: any): ConsultantWithSourcingRequestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantWithSourcingRequestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["sourcingRequestConsultantId"] = this.sourcingRequestConsultantId;
        data["sourcingRequestId"] = this.sourcingRequestId;
        data["sourcingRequestConsultantHeadline"] = this.sourcingRequestConsultantHeadline;
        return data;
    }
}

export interface IConsultantWithSourcingRequestResultDto {
    consultant?: ConsultantResultDto;
    sourcingRequestConsultantId?: number | undefined;
    sourcingRequestId?: number | undefined;
    sourcingRequestConsultantHeadline?: string | undefined;
}

export class ContactDto implements IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    clientAddress?: ClientAddressDto;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.owner = _data["owner"] ? EmployeeDto.fromJS(_data["owner"]) : <any>undefined;
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.clientAddress = _data["clientAddress"] ? ClientAddressDto.fromJS(_data["clientAddress"]) : <any>undefined;
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : <any>undefined;
            this.legacyContactId = _data["legacyContactId"] ? LegacyContactId.fromJS(_data["legacyContactId"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.lastCamLogin = _data["lastCamLogin"] ? moment(_data["lastCamLogin"].toString()) : <any>undefined;
            this.hasCamLogin = _data["hasCamLogin"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["clientAddress"] = this.clientAddress ? this.clientAddress.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["legacyContactId"] = this.legacyContactId ? this.legacyContactId.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["lastCamLogin"] = this.lastCamLogin ? this.lastCamLogin.toISOString() : <any>undefined;
        data["hasCamLogin"] = this.hasCamLogin;
        return data;
    }
}

export interface IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    clientAddress?: ClientAddressDto;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;
}

export class ContactResultDto implements IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    clientAddress?: ClientAddressDto;

    constructor(data?: IContactResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.clientAddress = _data["clientAddress"] ? ClientAddressDto.fromJS(_data["clientAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["clientAddress"] = this.clientAddress ? this.clientAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    clientAddress?: ClientAddressDto;
}

export class ContactSignerResultDto implements IContactSignerResultDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    clientId?: number | undefined;
    clientName?: string | undefined;
    clientVatNumber?: string | undefined;

    constructor(data?: IContactSignerResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.clientVatNumber = _data["clientVatNumber"];
        }
    }

    static fromJS(data: any): ContactSignerResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSignerResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["clientVatNumber"] = this.clientVatNumber;
        return data;
    }
}

export interface IContactSignerResultDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    clientId?: number | undefined;
    clientName?: string | undefined;
    clientVatNumber?: string | undefined;
}

export class ContractDocumentInfoDto implements IContractDocumentInfoDto {
    documentStorageGuid?: string;
    name?: string | undefined;
    type?: DocumentTypeEnum;

    constructor(data?: IContractDocumentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentStorageGuid = _data["documentStorageGuid"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ContractDocumentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDocumentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentStorageGuid"] = this.documentStorageGuid;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IContractDocumentInfoDto {
    documentStorageGuid?: string;
    name?: string | undefined;
    type?: DocumentTypeEnum;
}

export enum ContractExpirationNotificationInterval {
    OneWeekBefore = 1,
    TwoWeeksBefore = 2,
    ThreeWeeksBefore = 3,
    FourWeeksBefore = 4,
    FiveWeeksBefore = 5,
    SixWeeksBefore = 6,
    OneMonthBefore = 7,
    TwoMonthsBefore = 8,
}

export enum ContractPaperStatusColorEnum {
    Grey = 0,
    Green = 1,
    Yellow = 2,
    Red = 3,
    Black = 10,
}

export class ContractSignerDto implements IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;

    constructor(data?: IContractSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signOrder = _data["signOrder"];
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? ContactResultDto.fromJS(_data["contact"]) : <any>undefined;
            this.signerRoleId = _data["signerRoleId"];
        }
    }

    static fromJS(data: any): ContractSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signOrder"] = this.signOrder;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["signerRoleId"] = this.signerRoleId;
        return data;
    }
}

export interface IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;
}

export class ContractSupplierSignerDto implements IContractSupplierSignerDto {
    supplierMemberId?: number;
    supplierMember?: SupplierMemberResultDto;
    signerRoleId?: number;
    signOrder?: number;

    constructor(data?: IContractSupplierSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierMemberId = _data["supplierMemberId"];
            this.supplierMember = _data["supplierMember"] ? SupplierMemberResultDto.fromJS(_data["supplierMember"]) : <any>undefined;
            this.signerRoleId = _data["signerRoleId"];
            this.signOrder = _data["signOrder"];
        }
    }

    static fromJS(data: any): ContractSupplierSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSupplierSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierMemberId"] = this.supplierMemberId;
        data["supplierMember"] = this.supplierMember ? this.supplierMember.toJSON() : <any>undefined;
        data["signerRoleId"] = this.signerRoleId;
        data["signOrder"] = this.signOrder;
        return data;
    }
}

export interface IContractSupplierSignerDto {
    supplierMemberId?: number;
    supplierMember?: SupplierMemberResultDto;
    signerRoleId?: number;
    signOrder?: number;
}

export class ContractSyncResultDto implements IContractSyncResultDto {
    success?: boolean;
    showManualOption?: boolean;
    message?: string | undefined;
    enableLegalContractsButtons?: boolean;

    constructor(data?: IContractSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.showManualOption = _data["showManualOption"];
            this.message = _data["message"];
            this.enableLegalContractsButtons = _data["enableLegalContractsButtons"];
        }
    }

    static fromJS(data: any): ContractSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["showManualOption"] = this.showManualOption;
        data["message"] = this.message;
        data["enableLegalContractsButtons"] = this.enableLegalContractsButtons;
        return data;
    }
}

export interface IContractSyncResultDto {
    success?: boolean;
    showManualOption?: boolean;
    message?: string | undefined;
    enableLegalContractsButtons?: boolean;
}

export class ContractsClientDataDto implements IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    frameAgreementId?: number | undefined;
    clientTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    clientRate?: ClientRateDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    directClientId?: number | undefined;
    endClientId?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipient?: ClientResultDto;
    clientInvoicingRecipientAddress?: ClientAddressDto;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferencePersonDontShowOnInvoice?: boolean;
    purchaseOrdersIds?: number[] | undefined;

    constructor(data?: IContractsClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.frameAgreementId = _data["frameAgreementId"];
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.directClientId = _data["directClientId"];
            this.endClientId = _data["endClientId"];
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? ClientResultDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.clientInvoicingRecipientAddress = _data["clientInvoicingRecipientAddress"] ? ClientAddressDto.fromJS(_data["clientInvoicingRecipientAddress"]) : <any>undefined;
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.invoicingReferencePersonDontShowOnInvoice = _data["invoicingReferencePersonDontShowOnInvoice"];
            if (Array.isArray(_data["purchaseOrdersIds"])) {
                this.purchaseOrdersIds = [] as any;
                for (let item of _data["purchaseOrdersIds"])
                    this.purchaseOrdersIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ContractsClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["frameAgreementId"] = this.frameAgreementId;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["directClientId"] = this.directClientId;
        data["endClientId"] = this.endClientId;
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["clientInvoicingRecipientAddress"] = this.clientInvoicingRecipientAddress ? this.clientInvoicingRecipientAddress.toJSON() : <any>undefined;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["invoicingReferencePersonDontShowOnInvoice"] = this.invoicingReferencePersonDontShowOnInvoice;
        if (Array.isArray(this.purchaseOrdersIds)) {
            data["purchaseOrdersIds"] = [];
            for (let item of this.purchaseOrdersIds)
                data["purchaseOrdersIds"].push(item);
        }
        return data;
    }
}

export interface IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    frameAgreementId?: number | undefined;
    clientTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    clientRate?: ClientRateDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    directClientId?: number | undefined;
    endClientId?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipient?: ClientResultDto;
    clientInvoicingRecipientAddress?: ClientAddressDto;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferencePersonDontShowOnInvoice?: boolean;
    purchaseOrdersIds?: number[] | undefined;
}

export class ContractsMainDataDto implements IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;

    constructor(data?: IContractsMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectCategoryId = _data["projectCategoryId"];
            this.primaryCategoryArea = _data["primaryCategoryArea"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryArea"]) : <any>undefined;
            this.primaryCategoryType = _data["primaryCategoryType"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryType"]) : <any>undefined;
            this.primaryCategoryRole = _data["primaryCategoryRole"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryRole"]) : <any>undefined;
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): ContractsMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectCategoryId"] = this.projectCategoryId;
        data["primaryCategoryArea"] = this.primaryCategoryArea ? this.primaryCategoryArea.toJSON() : <any>undefined;
        data["primaryCategoryType"] = this.primaryCategoryType ? this.primaryCategoryType.toJSON() : <any>undefined;
        data["primaryCategoryRole"] = this.primaryCategoryRole ? this.primaryCategoryRole.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;
}

export class Country implements ICountry {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;
    readonly code?: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).code = _data["code"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICountry {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    hasTenant?: boolean;
    isUnknownCountry?: boolean;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.hasTenant = _data["hasTenant"];
            this.isUnknownCountry = _data["isUnknownCountry"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["hasTenant"] = this.hasTenant;
        data["isUnknownCountry"] = this.isUnknownCountry;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    hasTenant?: boolean;
    isUnknownCountry?: boolean;
}

export class CrmClientId implements ICrmClientId {
    readonly value?: number;

    constructor(data?: ICrmClientId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CrmClientId {
        data = typeof data === 'object' ? data : {};
        let result = new CrmClientId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ICrmClientId {
    value?: number;
}

export class CrmContactId implements ICrmContactId {
    readonly value?: number;

    constructor(data?: ICrmContactId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CrmContactId {
        data = typeof data === 'object' ? data : {};
        let result = new CrmContactId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ICrmContactId {
    value?: number;
}

export class CurrentEmployeeDto implements ICurrentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    permissions?: Permission[] | undefined;
    tenantId?: number;

    constructor(data?: ICurrentEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CurrentEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICurrentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    permissions?: Permission[] | undefined;
    tenantId?: number;
}

export class DocuSignEnvelopeSummary implements IDocuSignEnvelopeSummary {
    voidedReason?: string | undefined;

    constructor(data?: IDocuSignEnvelopeSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.voidedReason = _data["voidedReason"];
        }
    }

    static fromJS(data: any): DocuSignEnvelopeSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DocuSignEnvelopeSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["voidedReason"] = this.voidedReason;
        return data;
    }
}

export interface IDocuSignEnvelopeSummary {
    voidedReason?: string | undefined;
}

export enum DocuSignEvent {
    EnvelopeCompleted = 0,
    EnvelopeCorrected = 1,
    EnvelopeDeclined = 2,
    EnvelopeDeleted = 3,
    EnvelopeDelivered = 4,
    EnvelopeDiscard = 5,
    EnvelopePurge = 6,
    EnvelopeResent = 7,
    EnvelopeSent = 8,
    EnvelopeVoided = 9,
    RecipientAuthenticationFailed = 10,
    RecipientAutoResponded = 11,
    RecipientCompleted = 12,
    RecipientDeclined = 13,
    RecipientDelegate = 14,
    RecipientDelivered = 15,
    RecipientFinishLater = 16,
    RecipientReassign = 17,
    RecipientResent = 18,
    RecipientSent = 19,
}

export enum DocumentTypeEnum {
    Misc = 0,
    Pdf = 1,
    Word = 2,
    Image = 3,
    Excel = 4,
}

export class DomainEventBase implements IDomainEventBase {
    readonly id?: string;
    readonly dateOccurredUtc?: moment.Moment;

    constructor(data?: IDomainEventBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).dateOccurredUtc = _data["dateOccurredUtc"] ? moment(_data["dateOccurredUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainEventBase {
        data = typeof data === 'object' ? data : {};
        let result = new DomainEventBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateOccurredUtc"] = this.dateOccurredUtc ? this.dateOccurredUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDomainEventBase {
    id?: string;
    dateOccurredUtc?: moment.Moment;
}

export class EmagineOfficeDto implements IEmagineOfficeDto {
    id?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IEmagineOfficeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.address = _data["address"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): EmagineOfficeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmagineOfficeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["address"] = this.address;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IEmagineOfficeDto {
    id?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryName?: string | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class EmployeeNotificationDto implements IEmployeeNotificationDto {
    tenantId?: number | undefined;
    notifications?: EmployeeTenantNotificationItem[] | undefined;

    constructor(data?: IEmployeeNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(EmployeeTenantNotificationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmployeeNotificationDto {
    tenantId?: number | undefined;
    notifications?: EmployeeTenantNotificationItem[] | undefined;
}

export class EmployeeSearchEmployeeDto implements IEmployeeSearchEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    email?: string | undefined;

    constructor(data?: IEmployeeSearchEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): EmployeeSearchEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSearchEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IEmployeeSearchEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    email?: string | undefined;
}

export class EmployeeTenantNotificationItem implements IEmployeeTenantNotificationItem {
    notificationId?: number;
    notificationName?: string | undefined;
    enabled?: boolean;

    constructor(data?: IEmployeeTenantNotificationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.notificationName = _data["notificationName"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): EmployeeTenantNotificationItem {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTenantNotificationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["notificationName"] = this.notificationName;
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IEmployeeTenantNotificationItem {
    notificationId?: number;
    notificationName?: string | undefined;
    enabled?: boolean;
}

export class EmploymentType implements IEmploymentType {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;
    readonly isRecruitmentOrFeeOnly?: boolean;

    constructor(data?: IEmploymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).isRecruitmentOrFeeOnly = _data["isRecruitmentOrFeeOnly"];
        }
    }

    static fromJS(data: any): EmploymentType {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isRecruitmentOrFeeOnly"] = this.isRecruitmentOrFeeOnly;
        return data;
    }
}

export interface IEmploymentType {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
    isRecruitmentOrFeeOnly?: boolean;
}

export class EnumEntityTypeDto implements IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IEnumEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;
}

export class EnvelopeEventListItemDto implements IEnvelopeEventListItemDto {
    envelopeId?: number;
    envelopeDocuSignEnvelopeId?: string | undefined;
    docuSignEvent?: DocuSignEvent;
    newEnvelopeStatus?: EnvelopeStatus;
    receivedDateUtc?: moment.Moment;
    envelopeRecipientName?: string | undefined;
    envelopeRecipientEmail?: string | undefined;
    employeeName?: string | undefined;
    documentFileVersion?: number | undefined;
    documentFileDescription?: string | undefined;
    voidReason?: string | undefined;
    envelopeProcessingPath?: EnvelopeProcessingPath;

    constructor(data?: IEnvelopeEventListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.envelopeId = _data["envelopeId"];
            this.envelopeDocuSignEnvelopeId = _data["envelopeDocuSignEnvelopeId"];
            this.docuSignEvent = _data["docuSignEvent"];
            this.newEnvelopeStatus = _data["newEnvelopeStatus"];
            this.receivedDateUtc = _data["receivedDateUtc"] ? moment(_data["receivedDateUtc"].toString()) : <any>undefined;
            this.envelopeRecipientName = _data["envelopeRecipientName"];
            this.envelopeRecipientEmail = _data["envelopeRecipientEmail"];
            this.employeeName = _data["employeeName"];
            this.documentFileVersion = _data["documentFileVersion"];
            this.documentFileDescription = _data["documentFileDescription"];
            this.voidReason = _data["voidReason"];
            this.envelopeProcessingPath = _data["envelopeProcessingPath"];
        }
    }

    static fromJS(data: any): EnvelopeEventListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvelopeEventListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["envelopeId"] = this.envelopeId;
        data["envelopeDocuSignEnvelopeId"] = this.envelopeDocuSignEnvelopeId;
        data["docuSignEvent"] = this.docuSignEvent;
        data["newEnvelopeStatus"] = this.newEnvelopeStatus;
        data["receivedDateUtc"] = this.receivedDateUtc ? this.receivedDateUtc.toISOString() : <any>undefined;
        data["envelopeRecipientName"] = this.envelopeRecipientName;
        data["envelopeRecipientEmail"] = this.envelopeRecipientEmail;
        data["employeeName"] = this.employeeName;
        data["documentFileVersion"] = this.documentFileVersion;
        data["documentFileDescription"] = this.documentFileDescription;
        data["voidReason"] = this.voidReason;
        data["envelopeProcessingPath"] = this.envelopeProcessingPath;
        return data;
    }
}

export interface IEnvelopeEventListItemDto {
    envelopeId?: number;
    envelopeDocuSignEnvelopeId?: string | undefined;
    docuSignEvent?: DocuSignEvent;
    newEnvelopeStatus?: EnvelopeStatus;
    receivedDateUtc?: moment.Moment;
    envelopeRecipientName?: string | undefined;
    envelopeRecipientEmail?: string | undefined;
    employeeName?: string | undefined;
    documentFileVersion?: number | undefined;
    documentFileDescription?: string | undefined;
    voidReason?: string | undefined;
    envelopeProcessingPath?: EnvelopeProcessingPath;
}

export class EnvelopePreviewDto implements IEnvelopePreviewDto {
    envelopeName?: string | undefined;
    recipients?: RecipientPreviewDto[] | undefined;

    constructor(data?: IEnvelopePreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.envelopeName = _data["envelopeName"];
            if (Array.isArray(_data["recipients"])) {
                this.recipients = [] as any;
                for (let item of _data["recipients"])
                    this.recipients!.push(RecipientPreviewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvelopePreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvelopePreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["envelopeName"] = this.envelopeName;
        if (Array.isArray(this.recipients)) {
            data["recipients"] = [];
            for (let item of this.recipients)
                data["recipients"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEnvelopePreviewDto {
    envelopeName?: string | undefined;
    recipients?: RecipientPreviewDto[] | undefined;
}

export enum EnvelopeProcessingPath {
    Email = 1,
    DocuSign = 2,
    ReceiveFromOtherParty = 3,
}

export class EnvelopeRelatedAgreementDto implements IEnvelopeRelatedAgreementDto {
    agreementId?: number;
    agreementName?: string | undefined;

    constructor(data?: IEnvelopeRelatedAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
            this.agreementName = _data["agreementName"];
        }
    }

    static fromJS(data: any): EnvelopeRelatedAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvelopeRelatedAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        data["agreementName"] = this.agreementName;
        return data;
    }
}

export interface IEnvelopeRelatedAgreementDto {
    agreementId?: number;
    agreementName?: string | undefined;
}

export enum EnvelopeStatus {
    Created = 1,
    CreatedInDocuSign = 2,
    Sent = 3,
    DeliveryFailure = 5,
    Voided = 6,
    Declined = 8,
    WaitingForOthers = 9,
    Completed = 10,
    AboutToExpire = 11,
    Expired = 12,
    ReminderSent = 13,
    PartiallySigned = 14,
}

export class ExpectedWorkload implements IExpectedWorkload {
    hours?: number;
    expectedWorkloadUnit?: ExpectedWorkloadUnit;

    constructor(data?: IExpectedWorkload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hours = _data["hours"];
            this.expectedWorkloadUnit = _data["expectedWorkloadUnit"] ? ExpectedWorkloadUnit.fromJS(_data["expectedWorkloadUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpectedWorkload {
        data = typeof data === 'object' ? data : {};
        let result = new ExpectedWorkload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hours"] = this.hours;
        data["expectedWorkloadUnit"] = this.expectedWorkloadUnit ? this.expectedWorkloadUnit.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExpectedWorkload {
    hours?: number;
    expectedWorkloadUnit?: ExpectedWorkloadUnit;
}

export class ExpectedWorkloadUnit implements IExpectedWorkloadUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: IExpectedWorkloadUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): ExpectedWorkloadUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ExpectedWorkloadUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IExpectedWorkloadUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class ExtendClientPeriodDto implements IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantIds?: number[] | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;

    constructor(data?: IExtendClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["extendConsultantIds"])) {
                this.extendConsultantIds = [] as any;
                for (let item of _data["extendConsultantIds"])
                    this.extendConsultantIds!.push(item);
            }
            this.primaryCategoryArea = _data["primaryCategoryArea"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryArea"]) : <any>undefined;
            this.primaryCategoryType = _data["primaryCategoryType"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryType"]) : <any>undefined;
            this.primaryCategoryRole = _data["primaryCategoryRole"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtendClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.extendConsultantIds)) {
            data["extendConsultantIds"] = [];
            for (let item of this.extendConsultantIds)
                data["extendConsultantIds"].push(item);
        }
        data["primaryCategoryArea"] = this.primaryCategoryArea ? this.primaryCategoryArea.toJSON() : <any>undefined;
        data["primaryCategoryType"] = this.primaryCategoryType ? this.primaryCategoryType.toJSON() : <any>undefined;
        data["primaryCategoryRole"] = this.primaryCategoryRole ? this.primaryCategoryRole.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantIds?: number[] | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
}

export class ExtendClientPeriodResultDto implements IExtendClientPeriodResultDto {
    extendedClientPeriodId?: string;
    specialRatesChangesWarnings?: string[] | undefined;
    specialFeesChangesWarnings?: string[] | undefined;

    constructor(data?: IExtendClientPeriodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.extendedClientPeriodId = _data["extendedClientPeriodId"];
            if (Array.isArray(_data["specialRatesChangesWarnings"])) {
                this.specialRatesChangesWarnings = [] as any;
                for (let item of _data["specialRatesChangesWarnings"])
                    this.specialRatesChangesWarnings!.push(item);
            }
            if (Array.isArray(_data["specialFeesChangesWarnings"])) {
                this.specialFeesChangesWarnings = [] as any;
                for (let item of _data["specialFeesChangesWarnings"])
                    this.specialFeesChangesWarnings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendClientPeriodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendClientPeriodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extendedClientPeriodId"] = this.extendedClientPeriodId;
        if (Array.isArray(this.specialRatesChangesWarnings)) {
            data["specialRatesChangesWarnings"] = [];
            for (let item of this.specialRatesChangesWarnings)
                data["specialRatesChangesWarnings"].push(item);
        }
        if (Array.isArray(this.specialFeesChangesWarnings)) {
            data["specialFeesChangesWarnings"] = [];
            for (let item of this.specialFeesChangesWarnings)
                data["specialFeesChangesWarnings"].push(item);
        }
        return data;
    }
}

export interface IExtendClientPeriodResultDto {
    extendedClientPeriodId?: string;
    specialRatesChangesWarnings?: string[] | undefined;
    specialFeesChangesWarnings?: string[] | undefined;
}

export class ExtendConsultantPeriodDto implements IExtendConsultantPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IExtendConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtendConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IExtendConsultantPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class FileDef implements IFileDef {
    content?: string | undefined;
    fileName?: string | undefined;

    constructor(data?: IFileDef) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): FileDef {
        data = typeof data === 'object' ? data : {};
        let result = new FileDef();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IFileDef {
    content?: string | undefined;
    fileName?: string | undefined;
}

export class GanttRowItem implements IGanttRowItem {
    id?: string;
    processTypeId?: WorkflowProcessType;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;

    constructor(data?: IGanttRowItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processTypeId = _data["processTypeId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GanttRowItem {
        data = typeof data === 'object' ? data : {};
        let result = new GanttRowItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processTypeId"] = this.processTypeId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IGanttRowItem {
    id?: string;
    processTypeId?: WorkflowProcessType;
    startDate?: moment.Moment | undefined;
    endDate?: moment.Moment | undefined;
}

export class HistoryFilterNamesDto implements IHistoryFilterNamesDto {
    entityName?: string | undefined;
    propertyName?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IHistoryFilterNamesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityName = _data["entityName"];
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HistoryFilterNamesDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryFilterNamesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityName"] = this.entityName;
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHistoryFilterNamesDto {
    entityName?: string | undefined;
    propertyName?: string | undefined;
    displayName?: string | undefined;
}

export class HistoryPropertiesDto implements IHistoryPropertiesDto {
    actionName?: string | undefined;
    entityName?: string | undefined;
    entityKey?: { [key: string]: string; } | undefined;
    propertyName?: string | undefined;
    oldValueId?: string | undefined;
    oldValueDisplay?: string | undefined;
    newValueId?: string | undefined;
    newValueDisplay?: string | undefined;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    clientPeriodDisplayId?: string | undefined;
    clientPeriodTooltip?: string | undefined;
    workflowProcessType?: WorkflowProcessType;
    consultantPeriodId?: string | undefined;
    consultantId?: number | undefined;
    consultantName?: string | undefined;
    consultantExternalId?: string | undefined;
    clientId?: number | undefined;
    occurredAtUtc?: moment.Moment;
    employeeId?: number | undefined;
    employeeName?: string | undefined;
    employeeExternalId?: string | undefined;

    constructor(data?: IHistoryPropertiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionName = _data["actionName"];
            this.entityName = _data["entityName"];
            if (_data["entityKey"]) {
                this.entityKey = {} as any;
                for (let key in _data["entityKey"]) {
                    if (_data["entityKey"].hasOwnProperty(key))
                        (<any>this.entityKey)![key] = _data["entityKey"][key];
                }
            }
            this.propertyName = _data["propertyName"];
            this.oldValueId = _data["oldValueId"];
            this.oldValueDisplay = _data["oldValueDisplay"];
            this.newValueId = _data["newValueId"];
            this.newValueDisplay = _data["newValueDisplay"];
            this.workflowId = _data["workflowId"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.clientPeriodDisplayId = _data["clientPeriodDisplayId"];
            this.clientPeriodTooltip = _data["clientPeriodTooltip"];
            this.workflowProcessType = _data["workflowProcessType"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.consultantId = _data["consultantId"];
            this.consultantName = _data["consultantName"];
            this.consultantExternalId = _data["consultantExternalId"];
            this.clientId = _data["clientId"];
            this.occurredAtUtc = _data["occurredAtUtc"] ? moment(_data["occurredAtUtc"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.employeeExternalId = _data["employeeExternalId"];
        }
    }

    static fromJS(data: any): HistoryPropertiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryPropertiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionName"] = this.actionName;
        data["entityName"] = this.entityName;
        if (this.entityKey) {
            data["entityKey"] = {};
            for (let key in this.entityKey) {
                if (this.entityKey.hasOwnProperty(key))
                    (<any>data["entityKey"])[key] = this.entityKey[key];
            }
        }
        data["propertyName"] = this.propertyName;
        data["oldValueId"] = this.oldValueId;
        data["oldValueDisplay"] = this.oldValueDisplay;
        data["newValueId"] = this.newValueId;
        data["newValueDisplay"] = this.newValueDisplay;
        data["workflowId"] = this.workflowId;
        data["clientPeriodId"] = this.clientPeriodId;
        data["clientPeriodDisplayId"] = this.clientPeriodDisplayId;
        data["clientPeriodTooltip"] = this.clientPeriodTooltip;
        data["workflowProcessType"] = this.workflowProcessType;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["consultantId"] = this.consultantId;
        data["consultantName"] = this.consultantName;
        data["consultantExternalId"] = this.consultantExternalId;
        data["clientId"] = this.clientId;
        data["occurredAtUtc"] = this.occurredAtUtc ? this.occurredAtUtc.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["employeeExternalId"] = this.employeeExternalId;
        return data;
    }
}

export interface IHistoryPropertiesDto {
    actionName?: string | undefined;
    entityName?: string | undefined;
    entityKey?: { [key: string]: string; } | undefined;
    propertyName?: string | undefined;
    oldValueId?: string | undefined;
    oldValueDisplay?: string | undefined;
    newValueId?: string | undefined;
    newValueDisplay?: string | undefined;
    workflowId?: string | undefined;
    clientPeriodId?: string | undefined;
    clientPeriodDisplayId?: string | undefined;
    clientPeriodTooltip?: string | undefined;
    workflowProcessType?: WorkflowProcessType;
    consultantPeriodId?: string | undefined;
    consultantId?: number | undefined;
    consultantName?: string | undefined;
    consultantExternalId?: string | undefined;
    clientId?: number | undefined;
    occurredAtUtc?: moment.Moment;
    employeeId?: number | undefined;
    employeeName?: string | undefined;
    employeeExternalId?: string | undefined;
}

export class HistoryPropertiesDtoPaginatedList implements IHistoryPropertiesDtoPaginatedList {
    items?: HistoryPropertiesDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IHistoryPropertiesDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HistoryPropertiesDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): HistoryPropertiesDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryPropertiesDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IHistoryPropertiesDtoPaginatedList {
    items?: HistoryPropertiesDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class HubSpotClientDto implements IHubSpotClientDto {
    id?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    webDomain?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    tenantForCreation?: string | undefined;
    legacyClientId?: string | undefined;
    pmTenantId?: string | undefined;
    importedId?: string | undefined;
    isArchived?: boolean;
    crmOwnerId?: string | undefined;
    petName?: string | undefined;
    industry?: string | undefined;
    numberOfEmployees?: string | undefined;
    pmNotes?: string | undefined;
    oldPmType?: string | undefined;
    clientType?: string | undefined;
    targetAccount?: boolean | undefined;
    accountManager2CrmId?: string | undefined;
    accountManager3CrmId?: string | undefined;
    description?: string | undefined;
    contactAssociationIds?: CrmContactId[] | undefined;
    childrenCrmClientIds?: CrmClientId[] | undefined;
    parentCrmClientId?: CrmClientId;

    constructor(data?: IHubSpotClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.webDomain = _data["webDomain"];
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.tenantForCreation = _data["tenantForCreation"];
            this.legacyClientId = _data["legacyClientId"];
            this.pmTenantId = _data["pmTenantId"];
            this.importedId = _data["importedId"];
            this.isArchived = _data["isArchived"];
            this.crmOwnerId = _data["crmOwnerId"];
            this.petName = _data["petName"];
            this.industry = _data["industry"];
            this.numberOfEmployees = _data["numberOfEmployees"];
            this.pmNotes = _data["pmNotes"];
            this.oldPmType = _data["oldPmType"];
            this.clientType = _data["clientType"];
            this.targetAccount = _data["targetAccount"];
            this.accountManager2CrmId = _data["accountManager2CrmId"];
            this.accountManager3CrmId = _data["accountManager3CrmId"];
            this.description = _data["description"];
            if (Array.isArray(_data["contactAssociationIds"])) {
                this.contactAssociationIds = [] as any;
                for (let item of _data["contactAssociationIds"])
                    this.contactAssociationIds!.push(CrmContactId.fromJS(item));
            }
            if (Array.isArray(_data["childrenCrmClientIds"])) {
                this.childrenCrmClientIds = [] as any;
                for (let item of _data["childrenCrmClientIds"])
                    this.childrenCrmClientIds!.push(CrmClientId.fromJS(item));
            }
            this.parentCrmClientId = _data["parentCrmClientId"] ? CrmClientId.fromJS(_data["parentCrmClientId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HubSpotClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubSpotClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["webDomain"] = this.webDomain;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["tenantForCreation"] = this.tenantForCreation;
        data["legacyClientId"] = this.legacyClientId;
        data["pmTenantId"] = this.pmTenantId;
        data["importedId"] = this.importedId;
        data["isArchived"] = this.isArchived;
        data["crmOwnerId"] = this.crmOwnerId;
        data["petName"] = this.petName;
        data["industry"] = this.industry;
        data["numberOfEmployees"] = this.numberOfEmployees;
        data["pmNotes"] = this.pmNotes;
        data["oldPmType"] = this.oldPmType;
        data["clientType"] = this.clientType;
        data["targetAccount"] = this.targetAccount;
        data["accountManager2CrmId"] = this.accountManager2CrmId;
        data["accountManager3CrmId"] = this.accountManager3CrmId;
        data["description"] = this.description;
        if (Array.isArray(this.contactAssociationIds)) {
            data["contactAssociationIds"] = [];
            for (let item of this.contactAssociationIds)
                data["contactAssociationIds"].push(item.toJSON());
        }
        if (Array.isArray(this.childrenCrmClientIds)) {
            data["childrenCrmClientIds"] = [];
            for (let item of this.childrenCrmClientIds)
                data["childrenCrmClientIds"].push(item.toJSON());
        }
        data["parentCrmClientId"] = this.parentCrmClientId ? this.parentCrmClientId.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHubSpotClientDto {
    id?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    webDomain?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    tenantForCreation?: string | undefined;
    legacyClientId?: string | undefined;
    pmTenantId?: string | undefined;
    importedId?: string | undefined;
    isArchived?: boolean;
    crmOwnerId?: string | undefined;
    petName?: string | undefined;
    industry?: string | undefined;
    numberOfEmployees?: string | undefined;
    pmNotes?: string | undefined;
    oldPmType?: string | undefined;
    clientType?: string | undefined;
    targetAccount?: boolean | undefined;
    accountManager2CrmId?: string | undefined;
    accountManager3CrmId?: string | undefined;
    description?: string | undefined;
    contactAssociationIds?: CrmContactId[] | undefined;
    childrenCrmClientIds?: CrmClientId[] | undefined;
    parentCrmClientId?: CrmClientId;
}

export class IdNameDto implements IIdNameDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdNameDto {
    id?: number;
    name?: string | undefined;
}

export class InputWorkflowPeriodInfoForIncomeReportDto implements IInputWorkflowPeriodInfoForIncomeReportDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;

    constructor(data?: IInputWorkflowPeriodInfoForIncomeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.projectLineId = _data["projectLineId"];
        }
    }

    static fromJS(data: any): InputWorkflowPeriodInfoForIncomeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InputWorkflowPeriodInfoForIncomeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["projectLineId"] = this.projectLineId;
        return data;
    }
}

export interface IInputWorkflowPeriodInfoForIncomeReportDto {
    workflowId?: string | undefined;
    projectLineId?: number | undefined;
}

export class InternalCommissionDetailsDto implements IInternalCommissionDetailsDto {
    commissionDetailDtos?: CommissionDetailsDto[] | undefined;
    fromEmagineOfficeCountryName?: string | undefined;
    fromSiteId?: number | undefined;
    workflowGuid?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;

    constructor(data?: IInternalCommissionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["commissionDetailDtos"])) {
                this.commissionDetailDtos = [] as any;
                for (let item of _data["commissionDetailDtos"])
                    this.commissionDetailDtos!.push(CommissionDetailsDto.fromJS(item));
            }
            this.fromEmagineOfficeCountryName = _data["fromEmagineOfficeCountryName"];
            this.fromSiteId = _data["fromSiteId"];
            this.workflowGuid = _data["workflowGuid"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InternalCommissionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InternalCommissionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.commissionDetailDtos)) {
            data["commissionDetailDtos"] = [];
            for (let item of this.commissionDetailDtos)
                data["commissionDetailDtos"].push(item.toJSON());
        }
        data["fromEmagineOfficeCountryName"] = this.fromEmagineOfficeCountryName;
        data["fromSiteId"] = this.fromSiteId;
        data["workflowGuid"] = this.workflowGuid;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IInternalCommissionDetailsDto {
    commissionDetailDtos?: CommissionDetailsDto[] | undefined;
    fromEmagineOfficeCountryName?: string | undefined;
    fromSiteId?: number | undefined;
    workflowGuid?: string;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
}

export class LegacyClientDto implements ILegacyClientDto {
    legacyClientId?: number | undefined;
    clientTenantId?: number | undefined;
    name?: string | undefined;
    ownerInitials?: string | undefined;
    clientAddress?: ClientAddressDto;

    constructor(data?: ILegacyClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legacyClientId = _data["legacyClientId"];
            this.clientTenantId = _data["clientTenantId"];
            this.name = _data["name"];
            this.ownerInitials = _data["ownerInitials"];
            this.clientAddress = _data["clientAddress"] ? ClientAddressDto.fromJS(_data["clientAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LegacyClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegacyClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legacyClientId"] = this.legacyClientId;
        data["clientTenantId"] = this.clientTenantId;
        data["name"] = this.name;
        data["ownerInitials"] = this.ownerInitials;
        data["clientAddress"] = this.clientAddress ? this.clientAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILegacyClientDto {
    legacyClientId?: number | undefined;
    clientTenantId?: number | undefined;
    name?: string | undefined;
    ownerInitials?: string | undefined;
    clientAddress?: ClientAddressDto;
}

export class LegacyContactId implements ILegacyContactId {
    readonly value?: number;

    constructor(data?: ILegacyContactId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): LegacyContactId {
        data = typeof data === 'object' ? data : {};
        let result = new LegacyContactId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ILegacyContactId {
    value?: number;
}

export enum LegalContractStatus {
    NotAccessible = 0,
    NotYetCreated = 1,
    SavedNotGenerated = 2,
    Done = 10,
}

export class LegalEntityDto implements ILegalEntityDto {
    id?: number;
    name?: string | undefined;
    tenantName?: string | undefined;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryCode?: string | undefined;
    vatNumber?: string | undefined;

    constructor(data?: ILegalEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantName = _data["tenantName"];
            this.address = _data["address"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryCode = _data["countryCode"];
            this.vatNumber = _data["vatNumber"];
        }
    }

    static fromJS(data: any): LegalEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantName"] = this.tenantName;
        data["address"] = this.address;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["vatNumber"] = this.vatNumber;
        return data;
    }
}

export interface ILegalEntityDto {
    id?: number;
    name?: string | undefined;
    tenantName?: string | undefined;
    address?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryCode?: string | undefined;
    vatNumber?: string | undefined;
}

export enum LogOperationType {
    Create = 1,
    Update = 2,
    Delete = 3,
}

export class MainOverviewConsultantDto implements IMainOverviewConsultantDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IMainOverviewConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MainOverviewConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IMainOverviewConsultantDto {
    id?: number;
    name?: string | undefined;
}

export class MainOverviewItemForConsultantDto implements IMainOverviewItemForConsultantDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    actualEndDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    consultant?: MainOverviewConsultantDto;
    consultantPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowConsultantForSales?: MainOverviewStatus;
    syncStateStatus?: SyncStateStatus;

    constructor(data?: IMainOverviewItemForConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowSequenceIdCode = _data["workflowSequenceIdCode"];
            this.clientDisplayName = _data["clientDisplayName"];
            this.salesManager = _data["salesManager"] ? EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.actualEndDate = _data["actualEndDate"] ? moment(_data["actualEndDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.consultant = _data["consultant"] ? MainOverviewConsultantDto.fromJS(_data["consultant"]) : <any>undefined;
            if (Array.isArray(_data["consultantPeriods"])) {
                this.consultantPeriods = [] as any;
                for (let item of _data["consultantPeriods"])
                    this.consultantPeriods!.push(MainOverviewItemPeriodDto.fromJS(item));
            }
            this.mainOverviewStatusOfWorkflowConsultantForSales = _data["mainOverviewStatusOfWorkflowConsultantForSales"];
            this.syncStateStatus = _data["syncStateStatus"];
        }
    }

    static fromJS(data: any): MainOverviewItemForConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowSequenceIdCode"] = this.workflowSequenceIdCode;
        data["clientDisplayName"] = this.clientDisplayName;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantPeriods)) {
            data["consultantPeriods"] = [];
            for (let item of this.consultantPeriods)
                data["consultantPeriods"].push(item.toJSON());
        }
        data["mainOverviewStatusOfWorkflowConsultantForSales"] = this.mainOverviewStatusOfWorkflowConsultantForSales;
        data["syncStateStatus"] = this.syncStateStatus;
        return data;
    }
}

export interface IMainOverviewItemForConsultantDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    actualEndDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    consultant?: MainOverviewConsultantDto;
    consultantPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowConsultantForSales?: MainOverviewStatus;
    syncStateStatus?: SyncStateStatus;
}

export class MainOverviewItemForConsultantDtoPaginatedList implements IMainOverviewItemForConsultantDtoPaginatedList {
    items?: MainOverviewItemForConsultantDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMainOverviewItemForConsultantDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MainOverviewItemForConsultantDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): MainOverviewItemForConsultantDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForConsultantDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IMainOverviewItemForConsultantDtoPaginatedList {
    items?: MainOverviewItemForConsultantDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MainOverviewItemForWorkflowDto implements IMainOverviewItemForWorkflowDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    actualEndDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    consultants?: MainOverviewConsultantDto[] | undefined;
    clientPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowForSales?: MainOverviewStatus;
    syncStateStatus?: SyncStateStatus;

    constructor(data?: IMainOverviewItemForWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowSequenceIdCode = _data["workflowSequenceIdCode"];
            this.clientDisplayName = _data["clientDisplayName"];
            this.salesManager = _data["salesManager"] ? EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.actualEndDate = _data["actualEndDate"] ? moment(_data["actualEndDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(MainOverviewConsultantDto.fromJS(item));
            }
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(MainOverviewItemPeriodDto.fromJS(item));
            }
            this.mainOverviewStatusOfWorkflowForSales = _data["mainOverviewStatusOfWorkflowForSales"];
            this.syncStateStatus = _data["syncStateStatus"];
        }
    }

    static fromJS(data: any): MainOverviewItemForWorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowSequenceIdCode"] = this.workflowSequenceIdCode;
        data["clientDisplayName"] = this.clientDisplayName;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        data["mainOverviewStatusOfWorkflowForSales"] = this.mainOverviewStatusOfWorkflowForSales;
        data["syncStateStatus"] = this.syncStateStatus;
        return data;
    }
}

export interface IMainOverviewItemForWorkflowDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientDisplayName?: string | undefined;
    salesManager?: EmployeeDto;
    actualEndDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    consultants?: MainOverviewConsultantDto[] | undefined;
    clientPeriods?: MainOverviewItemPeriodDto[] | undefined;
    mainOverviewStatusOfWorkflowForSales?: MainOverviewStatus;
    syncStateStatus?: SyncStateStatus;
}

export class MainOverviewItemForWorkflowDtoPaginatedList implements IMainOverviewItemForWorkflowDtoPaginatedList {
    items?: MainOverviewItemForWorkflowDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMainOverviewItemForWorkflowDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MainOverviewItemForWorkflowDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): MainOverviewItemForWorkflowDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemForWorkflowDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IMainOverviewItemForWorkflowDtoPaginatedList {
    items?: MainOverviewItemForWorkflowDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MainOverviewItemPeriodDto implements IMainOverviewItemPeriodDto {
    id?: string;
    periodType?: string | undefined;
    salesStepStatus?: WorkflowStepStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;

    constructor(data?: IMainOverviewItemPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.periodType = _data["periodType"];
            this.salesStepStatus = _data["salesStepStatus"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MainOverviewItemPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewItemPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["periodType"] = this.periodType;
        data["salesStepStatus"] = this.salesStepStatus;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IMainOverviewItemPeriodDto {
    id?: string;
    periodType?: string | undefined;
    salesStepStatus?: WorkflowStepStatus;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
}

export enum MainOverviewStatus {
    ExpectedExtension = 1,
    InNegotiation = 2,
    ExpectedToTerminate = 3,
    NoAction = 10,
    Terminated = 12,
    AttentionRequired = 20,
}

export class MainOverviewStatusDto implements IMainOverviewStatusDto {
    id?: number;
    name?: string | undefined;
    canBeSetByUser?: boolean;
    canBeSetAutomatically?: boolean;

    constructor(data?: IMainOverviewStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.canBeSetByUser = _data["canBeSetByUser"];
            this.canBeSetAutomatically = _data["canBeSetAutomatically"];
        }
    }

    static fromJS(data: any): MainOverviewStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainOverviewStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["canBeSetByUser"] = this.canBeSetByUser;
        data["canBeSetAutomatically"] = this.canBeSetAutomatically;
        return data;
    }
}

export interface IMainOverviewStatusDto {
    id?: number;
    name?: string | undefined;
    canBeSetByUser?: boolean;
    canBeSetAutomatically?: boolean;
}

export class NewContractRequiredConsultantPeriodDto implements INewContractRequiredConsultantPeriodDto {
    consultantId?: number;
    consultantNewLegalContractRequired?: boolean;

    constructor(data?: INewContractRequiredConsultantPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultantNewLegalContractRequired = _data["consultantNewLegalContractRequired"];
        }
    }

    static fromJS(data: any): NewContractRequiredConsultantPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewContractRequiredConsultantPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultantNewLegalContractRequired"] = this.consultantNewLegalContractRequired;
        return data;
    }
}

export interface INewContractRequiredConsultantPeriodDto {
    consultantId?: number;
    consultantNewLegalContractRequired?: boolean;
}

export class NewWorkflowCreatedDto implements INewWorkflowCreatedDto {
    workflowId?: string;
    clientPeriodId?: string | undefined;

    constructor(data?: INewWorkflowCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.clientPeriodId = _data["clientPeriodId"];
        }
    }

    static fromJS(data: any): NewWorkflowCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewWorkflowCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["clientPeriodId"] = this.clientPeriodId;
        return data;
    }
}

export interface INewWorkflowCreatedDto {
    workflowId?: string;
    clientPeriodId?: string | undefined;
}

export class None implements INone {

    constructor(data?: INone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): None {
        data = typeof data === 'object' ? data : {};
        let result = new None();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface INone {
}

export class OutputWorkflowPeriodInfoForIncomeReportDto implements IOutputWorkflowPeriodInfoForIncomeReportDto {
    periodMainDataDtos?: ClientPeriodMainDataDto[] | undefined;
    emagineCommissionsFromOtherTenantsDtos?: InternalCommissionDetailsDto[] | undefined;

    constructor(data?: IOutputWorkflowPeriodInfoForIncomeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["periodMainDataDtos"])) {
                this.periodMainDataDtos = [] as any;
                for (let item of _data["periodMainDataDtos"])
                    this.periodMainDataDtos!.push(ClientPeriodMainDataDto.fromJS(item));
            }
            if (Array.isArray(_data["emagineCommissionsFromOtherTenantsDtos"])) {
                this.emagineCommissionsFromOtherTenantsDtos = [] as any;
                for (let item of _data["emagineCommissionsFromOtherTenantsDtos"])
                    this.emagineCommissionsFromOtherTenantsDtos!.push(InternalCommissionDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputWorkflowPeriodInfoForIncomeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutputWorkflowPeriodInfoForIncomeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.periodMainDataDtos)) {
            data["periodMainDataDtos"] = [];
            for (let item of this.periodMainDataDtos)
                data["periodMainDataDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.emagineCommissionsFromOtherTenantsDtos)) {
            data["emagineCommissionsFromOtherTenantsDtos"] = [];
            for (let item of this.emagineCommissionsFromOtherTenantsDtos)
                data["emagineCommissionsFromOtherTenantsDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOutputWorkflowPeriodInfoForIncomeReportDto {
    periodMainDataDtos?: ClientPeriodMainDataDto[] | undefined;
    emagineCommissionsFromOtherTenantsDtos?: InternalCommissionDetailsDto[] | undefined;
}

export class ParentAgreementTemplateDetailsAttachmentDto implements IParentAgreementTemplateDetailsAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
    isUsedByDescendants?: boolean | undefined;
    isSelected?: boolean;

    constructor(data?: IParentAgreementTemplateDetailsAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateAttachmentId = _data["agreementTemplateAttachmentId"];
            this.name = _data["name"];
            this.isUsedByDescendants = _data["isUsedByDescendants"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ParentAgreementTemplateDetailsAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParentAgreementTemplateDetailsAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateAttachmentId"] = this.agreementTemplateAttachmentId;
        data["name"] = this.name;
        data["isUsedByDescendants"] = this.isUsedByDescendants;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IParentAgreementTemplateDetailsAttachmentDto {
    agreementTemplateAttachmentId?: number;
    name?: string | undefined;
    isUsedByDescendants?: boolean | undefined;
    isSelected?: boolean;
}

export class PeriodClientSpecialFeeDto implements IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodClientSpecialRateDto implements IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    rateSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.rateSpecifiedAs = _data["rateSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["rateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["rateSpecifiedAs"] = this.rateSpecifiedAs ? this.rateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    rateSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialFeeDto implements IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialRateDto implements IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    rateSpecifiedAs?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.rateSpecifiedAs = _data["rateSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["rateSpecifiedAs"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["rateSpecifiedAs"] = this.rateSpecifiedAs ? this.rateSpecifiedAs.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    rateSpecifiedAs?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export enum Permission {
    Common = 0,
    AccountManager = 1,
    ContractManager = 2,
    Admin = 3,
    Finance = 4,
}

export class Pm3EmployeeDto implements IPm3EmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    primaryPhoneNumber?: string | undefined;
    emailAddress?: string | undefined;
    lowerCaseInitials?: string | undefined;

    constructor(data?: IPm3EmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.primaryPhoneNumber = _data["primaryPhoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.lowerCaseInitials = _data["lowerCaseInitials"];
        }
    }

    static fromJS(data: any): Pm3EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new Pm3EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["primaryPhoneNumber"] = this.primaryPhoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["lowerCaseInitials"] = this.lowerCaseInitials;
        return data;
    }
}

export interface IPm3EmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    primaryPhoneNumber?: string | undefined;
    emailAddress?: string | undefined;
    lowerCaseInitials?: string | undefined;
}

export class ProfessionalRoleDto implements IProfessionalRoleDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IProfessionalRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProfessionalRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProfessionalRoleDto {
    id?: number;
    name?: string | undefined;
}

export class ProjectLineDto implements IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferenceString?: string | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    invoiceRecipient?: ClientResultDto;
    invoiceRecipientAddressId?: number | undefined;
    invoiceRecipientAddress?: ClientAddressDto;
    modifiedById?: number | undefined;
    modifiedBy?: EmployeeDto;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;
    isLineForFees?: boolean | undefined;
    purchaseOrderId?: number | undefined;
    markedForLegacyDeletion?: boolean | undefined;
    wasSynced?: boolean | undefined;

    constructor(data?: IProjectLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.differentInvoicingReferenceNumber = _data["differentInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.differentInvoicingReferencePerson = _data["differentInvoicingReferencePerson"];
            this.invoicingReferencePersonId = _data["invoicingReferencePersonId"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.invoicingReferenceString = _data["invoicingReferenceString"];
            this.optionalInvoicingInfo = _data["optionalInvoicingInfo"];
            this.differentDebtorNumber = _data["differentDebtorNumber"];
            this.debtorNumber = _data["debtorNumber"];
            this.differentInvoiceRecipient = _data["differentInvoiceRecipient"];
            this.invoiceRecipientId = _data["invoiceRecipientId"];
            this.invoiceRecipient = _data["invoiceRecipient"] ? ClientResultDto.fromJS(_data["invoiceRecipient"]) : <any>undefined;
            this.invoiceRecipientAddressId = _data["invoiceRecipientAddressId"];
            this.invoiceRecipientAddress = _data["invoiceRecipientAddress"] ? ClientAddressDto.fromJS(_data["invoiceRecipientAddress"]) : <any>undefined;
            this.modifiedById = _data["modifiedById"];
            this.modifiedBy = _data["modifiedBy"] ? EmployeeDto.fromJS(_data["modifiedBy"]) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? moment(_data["modificationDate"].toString()) : <any>undefined;
            this.consultantInsuranceOptionId = _data["consultantInsuranceOptionId"];
            this.isLineForFees = _data["isLineForFees"];
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.markedForLegacyDeletion = _data["markedForLegacyDeletion"];
            this.wasSynced = _data["wasSynced"];
        }
    }

    static fromJS(data: any): ProjectLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["differentInvoicingReferenceNumber"] = this.differentInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["differentInvoicingReferencePerson"] = this.differentInvoicingReferencePerson;
        data["invoicingReferencePersonId"] = this.invoicingReferencePersonId;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["invoicingReferenceString"] = this.invoicingReferenceString;
        data["optionalInvoicingInfo"] = this.optionalInvoicingInfo;
        data["differentDebtorNumber"] = this.differentDebtorNumber;
        data["debtorNumber"] = this.debtorNumber;
        data["differentInvoiceRecipient"] = this.differentInvoiceRecipient;
        data["invoiceRecipientId"] = this.invoiceRecipientId;
        data["invoiceRecipient"] = this.invoiceRecipient ? this.invoiceRecipient.toJSON() : <any>undefined;
        data["invoiceRecipientAddressId"] = this.invoiceRecipientAddressId;
        data["invoiceRecipientAddress"] = this.invoiceRecipientAddress ? this.invoiceRecipientAddress.toJSON() : <any>undefined;
        data["modifiedById"] = this.modifiedById;
        data["modifiedBy"] = this.modifiedBy ? this.modifiedBy.toJSON() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["consultantInsuranceOptionId"] = this.consultantInsuranceOptionId;
        data["isLineForFees"] = this.isLineForFees;
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["markedForLegacyDeletion"] = this.markedForLegacyDeletion;
        data["wasSynced"] = this.wasSynced;
        return data;
    }
}

export interface IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferenceString?: string | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    invoiceRecipient?: ClientResultDto;
    invoiceRecipientAddressId?: number | undefined;
    invoiceRecipientAddress?: ClientAddressDto;
    modifiedById?: number | undefined;
    modifiedBy?: EmployeeDto;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;
    isLineForFees?: boolean | undefined;
    purchaseOrderId?: number | undefined;
    markedForLegacyDeletion?: boolean | undefined;
    wasSynced?: boolean | undefined;
}

export class ProjectTypeConfigurationDto implements IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;

    constructor(data?: IProjectTypeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
        }
    }

    static fromJS(data: any): ProjectTypeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        return data;
    }
}

export interface IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProjectTypeDto {
    id?: number;
    name?: string | undefined;
}

export class PurchaseOrderCapDto implements IPurchaseOrderCapDto {
    type?: PurchaseOrderCapType;
    valueUnitTypeId?: number | undefined;
    maxAmount?: number | undefined;
    currencyId?: number | undefined;
    amountUsed?: number | undefined;

    constructor(data?: IPurchaseOrderCapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.valueUnitTypeId = _data["valueUnitTypeId"];
            this.maxAmount = _data["maxAmount"];
            this.currencyId = _data["currencyId"];
            this.amountUsed = _data["amountUsed"];
        }
    }

    static fromJS(data: any): PurchaseOrderCapDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderCapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["valueUnitTypeId"] = this.valueUnitTypeId;
        data["maxAmount"] = this.maxAmount;
        data["currencyId"] = this.currencyId;
        data["amountUsed"] = this.amountUsed;
        return data;
    }
}

export interface IPurchaseOrderCapDto {
    type?: PurchaseOrderCapType;
    valueUnitTypeId?: number | undefined;
    maxAmount?: number | undefined;
    currencyId?: number | undefined;
    amountUsed?: number | undefined;
}

export enum PurchaseOrderCapType {
    CapOnUnits = 1,
    CapOnValue = 2,
    NoCap = 3,
}

export class PurchaseOrderCurrentContextDto implements IPurchaseOrderCurrentContextDto {
    isUserAllowedToEdit?: boolean;
    existsInThisWorkflow?: boolean;
    existsInAnotherWorkflow?: boolean;

    constructor(data?: IPurchaseOrderCurrentContextDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserAllowedToEdit = _data["isUserAllowedToEdit"];
            this.existsInThisWorkflow = _data["existsInThisWorkflow"];
            this.existsInAnotherWorkflow = _data["existsInAnotherWorkflow"];
        }
    }

    static fromJS(data: any): PurchaseOrderCurrentContextDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderCurrentContextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserAllowedToEdit"] = this.isUserAllowedToEdit;
        data["existsInThisWorkflow"] = this.existsInThisWorkflow;
        data["existsInAnotherWorkflow"] = this.existsInAnotherWorkflow;
        return data;
    }
}

export interface IPurchaseOrderCurrentContextDto {
    isUserAllowedToEdit?: boolean;
    existsInThisWorkflow?: boolean;
    existsInAnotherWorkflow?: boolean;
}

export class PurchaseOrderDto implements IPurchaseOrderDto {
    id?: number | undefined;
    number?: string | undefined;
    numberMissingButRequired?: boolean | undefined;
    receiveDate?: moment.Moment | undefined;
    capForInvoicing?: PurchaseOrderCapDto;
    createdBy?: EmployeeDto;
    createdOnUtc?: moment.Moment | undefined;
    modifiedBy?: EmployeeDto;
    modifiedOnUtc?: moment.Moment | undefined;
    workflowsIdsReferencingThisPo?: string[] | undefined;
    purchaseOrderCurrentContextData?: PurchaseOrderCurrentContextDto;

    constructor(data?: IPurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.numberMissingButRequired = _data["numberMissingButRequired"];
            this.receiveDate = _data["receiveDate"] ? moment(_data["receiveDate"].toString()) : <any>undefined;
            this.capForInvoicing = _data["capForInvoicing"] ? PurchaseOrderCapDto.fromJS(_data["capForInvoicing"]) : <any>undefined;
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdOnUtc = _data["createdOnUtc"] ? moment(_data["createdOnUtc"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"] ? EmployeeDto.fromJS(_data["modifiedBy"]) : <any>undefined;
            this.modifiedOnUtc = _data["modifiedOnUtc"] ? moment(_data["modifiedOnUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["workflowsIdsReferencingThisPo"])) {
                this.workflowsIdsReferencingThisPo = [] as any;
                for (let item of _data["workflowsIdsReferencingThisPo"])
                    this.workflowsIdsReferencingThisPo!.push(item);
            }
            this.purchaseOrderCurrentContextData = _data["purchaseOrderCurrentContextData"] ? PurchaseOrderCurrentContextDto.fromJS(_data["purchaseOrderCurrentContextData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["numberMissingButRequired"] = this.numberMissingButRequired;
        data["receiveDate"] = this.receiveDate ? this.receiveDate.format('YYYY-MM-DD') : <any>undefined;
        data["capForInvoicing"] = this.capForInvoicing ? this.capForInvoicing.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdOnUtc"] = this.createdOnUtc ? this.createdOnUtc.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy ? this.modifiedBy.toJSON() : <any>undefined;
        data["modifiedOnUtc"] = this.modifiedOnUtc ? this.modifiedOnUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.workflowsIdsReferencingThisPo)) {
            data["workflowsIdsReferencingThisPo"] = [];
            for (let item of this.workflowsIdsReferencingThisPo)
                data["workflowsIdsReferencingThisPo"].push(item);
        }
        data["purchaseOrderCurrentContextData"] = this.purchaseOrderCurrentContextData ? this.purchaseOrderCurrentContextData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPurchaseOrderDto {
    id?: number | undefined;
    number?: string | undefined;
    numberMissingButRequired?: boolean | undefined;
    receiveDate?: moment.Moment | undefined;
    capForInvoicing?: PurchaseOrderCapDto;
    createdBy?: EmployeeDto;
    createdOnUtc?: moment.Moment | undefined;
    modifiedBy?: EmployeeDto;
    modifiedOnUtc?: moment.Moment | undefined;
    workflowsIdsReferencingThisPo?: string[] | undefined;
    purchaseOrderCurrentContextData?: PurchaseOrderCurrentContextDto;
}

export class PurchaseOrderSyncDto implements IPurchaseOrderSyncDto {
    id?: number;
    number?: string | undefined;
    missingButRequired?: boolean;
    isSharedWithAnotherWorkflow?: boolean;
    workflowsIdsReferencingThisPo?: string[] | undefined;
    receiveDate?: moment.Moment | undefined;
    capType?: number;
    capUnit?: number | undefined;
    maxAmount?: number | undefined;
    capCurrency?: string | undefined;

    constructor(data?: IPurchaseOrderSyncDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.missingButRequired = _data["missingButRequired"];
            this.isSharedWithAnotherWorkflow = _data["isSharedWithAnotherWorkflow"];
            if (Array.isArray(_data["workflowsIdsReferencingThisPo"])) {
                this.workflowsIdsReferencingThisPo = [] as any;
                for (let item of _data["workflowsIdsReferencingThisPo"])
                    this.workflowsIdsReferencingThisPo!.push(item);
            }
            this.receiveDate = _data["receiveDate"] ? moment(_data["receiveDate"].toString()) : <any>undefined;
            this.capType = _data["capType"];
            this.capUnit = _data["capUnit"];
            this.maxAmount = _data["maxAmount"];
            this.capCurrency = _data["capCurrency"];
        }
    }

    static fromJS(data: any): PurchaseOrderSyncDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderSyncDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["missingButRequired"] = this.missingButRequired;
        data["isSharedWithAnotherWorkflow"] = this.isSharedWithAnotherWorkflow;
        if (Array.isArray(this.workflowsIdsReferencingThisPo)) {
            data["workflowsIdsReferencingThisPo"] = [];
            for (let item of this.workflowsIdsReferencingThisPo)
                data["workflowsIdsReferencingThisPo"].push(item);
        }
        data["receiveDate"] = this.receiveDate ? this.receiveDate.format('YYYY-MM-DD') : <any>undefined;
        data["capType"] = this.capType;
        data["capUnit"] = this.capUnit;
        data["maxAmount"] = this.maxAmount;
        data["capCurrency"] = this.capCurrency;
        return data;
    }
}

export interface IPurchaseOrderSyncDto {
    id?: number;
    number?: string | undefined;
    missingButRequired?: boolean;
    isSharedWithAnotherWorkflow?: boolean;
    workflowsIdsReferencingThisPo?: string[] | undefined;
    receiveDate?: moment.Moment | undefined;
    capType?: number;
    capUnit?: number | undefined;
    maxAmount?: number | undefined;
    capCurrency?: string | undefined;
}

export class RecipientPreviewDto implements IRecipientPreviewDto {
    agreementSignerId?: number;
    name?: string | undefined;
    email?: string | undefined;
    signerType?: SignerType;
    roleId?: number;
    signOrder?: number;
    externalId?: string | undefined;

    constructor(data?: IRecipientPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementSignerId = _data["agreementSignerId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.signerType = _data["signerType"];
            this.roleId = _data["roleId"];
            this.signOrder = _data["signOrder"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): RecipientPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipientPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementSignerId"] = this.agreementSignerId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["signerType"] = this.signerType;
        data["roleId"] = this.roleId;
        data["signOrder"] = this.signOrder;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface IRecipientPreviewDto {
    agreementSignerId?: number;
    name?: string | undefined;
    email?: string | undefined;
    signerType?: SignerType;
    roleId?: number;
    signOrder?: number;
    externalId?: string | undefined;
}

export class RecipientTypeDto implements IRecipientTypeDto {
    id?: number;
    name?: string | undefined;
    agreementTypes?: { [key: string]: string; } | undefined;

    constructor(data?: IRecipientTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (_data["agreementTypes"]) {
                this.agreementTypes = {} as any;
                for (let key in _data["agreementTypes"]) {
                    if (_data["agreementTypes"].hasOwnProperty(key))
                        (<any>this.agreementTypes)![key] = _data["agreementTypes"][key];
                }
            }
        }
    }

    static fromJS(data: any): RecipientTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipientTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.agreementTypes) {
            data["agreementTypes"] = {};
            for (let key in this.agreementTypes) {
                if (this.agreementTypes.hasOwnProperty(key))
                    (<any>data["agreementTypes"])[key] = this.agreementTypes[key];
            }
        }
        return data;
    }
}

export interface IRecipientTypeDto {
    id?: number;
    name?: string | undefined;
    agreementTypes?: { [key: string]: string; } | undefined;
}

export enum RequestProjectTypeValue {
    NormalHighMargin = 1,
    NormalLowMargin = 2,
    NearShoreHighMargin = 3,
    NearShoreLowMargin = 4,
    VMSReferredHighMargin = 5,
    VMSReferredLowMargin = 6,
    NearShoreVMSReferredHighMargin = 7,
    NearShoreVMSReferredLowMargin = 8,
    OtherHighMargin = 9,
    OtherLowMargin = 10,
}

export class RequestProjectTypeValueValueNameDto implements IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;

    constructor(data?: IRequestProjectTypeValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestProjectTypeValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestProjectTypeValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;
}

export enum RequestStatusValue {
    Open = 1,
    Sold = 2,
    Stop = 3,
    Closed = 4,
    Potential = 7,
    AdRunning = 8,
    TenderSent = 9,
    Cancelled = 10,
}

export class RequestStatusValueValueNameDto implements IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;

    constructor(data?: IRequestStatusValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestStatusValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;
}

export class RoleNodeDto implements IRoleNodeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IRoleNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleNodeDto {
    id?: number;
    name?: string | undefined;
}

export class RoleTreeDto implements IRoleTreeDto {
    branches?: BranchRoleNodeDto[] | undefined;

    constructor(data?: IRoleTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(BranchRoleNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleTreeDto {
    branches?: BranchRoleNodeDto[] | undefined;
}

export class SalesClientDataDto implements ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    directClientAddressId?: number | undefined;
    directClientAddress?: ClientAddressDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    endClientAddressId?: number | undefined;
    endClientAddress?: ClientAddressDto;
    clientContactProjectManager?: ContactResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    clientInvoicingRecipientAddressId?: number | undefined;
    clientInvoicingRecipientAddress?: ClientAddressDto;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferencePersonDontShowOnInvoice?: boolean;
    purchaseOrdersIds?: number[] | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    frameAgreementId?: number | undefined;
    contractSigners?: ContractSignerDto[] | undefined;

    constructor(data?: ISalesClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.differentEndClient = _data["differentEndClient"];
            this.directClientIdValue = _data["directClientIdValue"];
            this.directClient = _data["directClient"] ? ClientResultDto.fromJS(_data["directClient"]) : <any>undefined;
            this.directClientAddressId = _data["directClientAddressId"];
            this.directClientAddress = _data["directClientAddress"] ? ClientAddressDto.fromJS(_data["directClientAddress"]) : <any>undefined;
            this.endClientIdValue = _data["endClientIdValue"];
            this.endClient = _data["endClient"] ? ClientResultDto.fromJS(_data["endClient"]) : <any>undefined;
            this.endClientAddressId = _data["endClientAddressId"];
            this.endClientAddress = _data["endClientAddress"] ? ClientAddressDto.fromJS(_data["endClientAddress"]) : <any>undefined;
            this.clientContactProjectManager = _data["clientContactProjectManager"] ? ContactResultDto.fromJS(_data["clientContactProjectManager"]) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionDurationId = _data["clientExtensionDurationId"];
            this.clientExtensionDeadlineId = _data["clientExtensionDeadlineId"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            if (Array.isArray(_data["timeReportingCaps"])) {
                this.timeReportingCaps = [] as any;
                for (let item of _data["timeReportingCaps"])
                    this.timeReportingCaps!.push(TimeReportingCapDto.fromJS(item));
            }
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noInvoicingReferenceNumber = _data["noInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipientIdValue = _data["clientInvoicingRecipientIdValue"];
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? ClientResultDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.clientInvoicingRecipientAddressId = _data["clientInvoicingRecipientAddressId"];
            this.clientInvoicingRecipientAddress = _data["clientInvoicingRecipientAddress"] ? ClientAddressDto.fromJS(_data["clientInvoicingRecipientAddress"]) : <any>undefined;
            this.invoicingReferencePersonIdValue = _data["invoicingReferencePersonIdValue"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.invoicingReferencePersonDontShowOnInvoice = _data["invoicingReferencePersonDontShowOnInvoice"];
            if (Array.isArray(_data["purchaseOrdersIds"])) {
                this.purchaseOrdersIds = [] as any;
                for (let item of _data["purchaseOrdersIds"])
                    this.purchaseOrdersIds!.push(item);
            }
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.evaluationsReferencePersonIdValue = _data["evaluationsReferencePersonIdValue"];
            this.evaluationsReferencePerson = _data["evaluationsReferencePerson"] ? ContactResultDto.fromJS(_data["evaluationsReferencePerson"]) : <any>undefined;
            this.evaluationsDisabled = _data["evaluationsDisabled"];
            this.evaluationsDisabledReason = _data["evaluationsDisabledReason"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.frameAgreementId = _data["frameAgreementId"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["differentEndClient"] = this.differentEndClient;
        data["directClientIdValue"] = this.directClientIdValue;
        data["directClient"] = this.directClient ? this.directClient.toJSON() : <any>undefined;
        data["directClientAddressId"] = this.directClientAddressId;
        data["directClientAddress"] = this.directClientAddress ? this.directClientAddress.toJSON() : <any>undefined;
        data["endClientIdValue"] = this.endClientIdValue;
        data["endClient"] = this.endClient ? this.endClient.toJSON() : <any>undefined;
        data["endClientAddressId"] = this.endClientAddressId;
        data["endClientAddress"] = this.endClientAddress ? this.endClientAddress.toJSON() : <any>undefined;
        data["clientContactProjectManager"] = this.clientContactProjectManager ? this.clientContactProjectManager.toJSON() : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionDurationId"] = this.clientExtensionDurationId;
        data["clientExtensionDeadlineId"] = this.clientExtensionDeadlineId;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        if (Array.isArray(this.timeReportingCaps)) {
            data["timeReportingCaps"] = [];
            for (let item of this.timeReportingCaps)
                data["timeReportingCaps"].push(item.toJSON());
        }
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noInvoicingReferenceNumber"] = this.noInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipientIdValue"] = this.clientInvoicingRecipientIdValue;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["clientInvoicingRecipientAddressId"] = this.clientInvoicingRecipientAddressId;
        data["clientInvoicingRecipientAddress"] = this.clientInvoicingRecipientAddress ? this.clientInvoicingRecipientAddress.toJSON() : <any>undefined;
        data["invoicingReferencePersonIdValue"] = this.invoicingReferencePersonIdValue;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["invoicingReferencePersonDontShowOnInvoice"] = this.invoicingReferencePersonDontShowOnInvoice;
        if (Array.isArray(this.purchaseOrdersIds)) {
            data["purchaseOrdersIds"] = [];
            for (let item of this.purchaseOrdersIds)
                data["purchaseOrdersIds"].push(item);
        }
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["evaluationsReferencePersonIdValue"] = this.evaluationsReferencePersonIdValue;
        data["evaluationsReferencePerson"] = this.evaluationsReferencePerson ? this.evaluationsReferencePerson.toJSON() : <any>undefined;
        data["evaluationsDisabled"] = this.evaluationsDisabled;
        data["evaluationsDisabledReason"] = this.evaluationsDisabledReason;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["frameAgreementId"] = this.frameAgreementId;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    directClientAddressId?: number | undefined;
    directClientAddress?: ClientAddressDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    endClientAddressId?: number | undefined;
    endClientAddress?: ClientAddressDto;
    clientContactProjectManager?: ContactResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    timeReportingCaps?: TimeReportingCapDto[] | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    clientInvoicingRecipientAddressId?: number | undefined;
    clientInvoicingRecipientAddress?: ClientAddressDto;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    invoicingReferencePersonDontShowOnInvoice?: boolean;
    purchaseOrdersIds?: number[] | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    frameAgreementId?: number | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
}

export class SalesMainDataDto implements ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    commissionedEmployeesIdValues?: number[] | undefined;
    commissionedEmployeesData?: EmployeeDto[] | undefined;
    primarySourcerId?: number | undefined;
    primarySourcer?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: ContractExpirationNotificationInterval[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;

    constructor(data?: ISalesMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectCategoryId = _data["projectCategoryId"];
            this.primaryCategoryArea = _data["primaryCategoryArea"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryArea"]) : <any>undefined;
            this.primaryCategoryType = _data["primaryCategoryType"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryType"]) : <any>undefined;
            this.primaryCategoryRole = _data["primaryCategoryRole"] ? ProfessionalRoleDto.fromJS(_data["primaryCategoryRole"]) : <any>undefined;
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            if (Array.isArray(_data["commissions"])) {
                this.commissions = [] as any;
                for (let item of _data["commissions"])
                    this.commissions!.push(CommissionDto.fromJS(item));
            }
            this.salesAccountManagerIdValue = _data["salesAccountManagerIdValue"];
            this.salesAccountManagerData = _data["salesAccountManagerData"] ? EmployeeDto.fromJS(_data["salesAccountManagerData"]) : <any>undefined;
            this.commissionAccountManagerIdValue = _data["commissionAccountManagerIdValue"];
            this.commissionAccountManagerData = _data["commissionAccountManagerData"] ? EmployeeDto.fromJS(_data["commissionAccountManagerData"]) : <any>undefined;
            if (Array.isArray(_data["commissionedEmployeesIdValues"])) {
                this.commissionedEmployeesIdValues = [] as any;
                for (let item of _data["commissionedEmployeesIdValues"])
                    this.commissionedEmployeesIdValues!.push(item);
            }
            if (Array.isArray(_data["commissionedEmployeesData"])) {
                this.commissionedEmployeesData = [] as any;
                for (let item of _data["commissionedEmployeesData"])
                    this.commissionedEmployeesData!.push(EmployeeDto.fromJS(item));
            }
            this.primarySourcerId = _data["primarySourcerId"];
            this.primarySourcer = _data["primarySourcer"] ? EmployeeDto.fromJS(_data["primarySourcer"]) : <any>undefined;
            if (Array.isArray(_data["contractExpirationNotificationIntervalIds"])) {
                this.contractExpirationNotificationIntervalIds = [] as any;
                for (let item of _data["contractExpirationNotificationIntervalIds"])
                    this.contractExpirationNotificationIntervalIds!.push(item);
            }
            this.customContractExpirationNotificationDate = _data["customContractExpirationNotificationDate"] ? moment(_data["customContractExpirationNotificationDate"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): SalesMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectCategoryId"] = this.projectCategoryId;
        data["primaryCategoryArea"] = this.primaryCategoryArea ? this.primaryCategoryArea.toJSON() : <any>undefined;
        data["primaryCategoryType"] = this.primaryCategoryType ? this.primaryCategoryType.toJSON() : <any>undefined;
        data["primaryCategoryRole"] = this.primaryCategoryRole ? this.primaryCategoryRole.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        if (Array.isArray(this.commissions)) {
            data["commissions"] = [];
            for (let item of this.commissions)
                data["commissions"].push(item.toJSON());
        }
        data["salesAccountManagerIdValue"] = this.salesAccountManagerIdValue;
        data["salesAccountManagerData"] = this.salesAccountManagerData ? this.salesAccountManagerData.toJSON() : <any>undefined;
        data["commissionAccountManagerIdValue"] = this.commissionAccountManagerIdValue;
        data["commissionAccountManagerData"] = this.commissionAccountManagerData ? this.commissionAccountManagerData.toJSON() : <any>undefined;
        if (Array.isArray(this.commissionedEmployeesIdValues)) {
            data["commissionedEmployeesIdValues"] = [];
            for (let item of this.commissionedEmployeesIdValues)
                data["commissionedEmployeesIdValues"].push(item);
        }
        if (Array.isArray(this.commissionedEmployeesData)) {
            data["commissionedEmployeesData"] = [];
            for (let item of this.commissionedEmployeesData)
                data["commissionedEmployeesData"].push(item.toJSON());
        }
        data["primarySourcerId"] = this.primarySourcerId;
        data["primarySourcer"] = this.primarySourcer ? this.primarySourcer.toJSON() : <any>undefined;
        if (Array.isArray(this.contractExpirationNotificationIntervalIds)) {
            data["contractExpirationNotificationIntervalIds"] = [];
            for (let item of this.contractExpirationNotificationIntervalIds)
                data["contractExpirationNotificationIntervalIds"].push(item);
        }
        data["customContractExpirationNotificationDate"] = this.customContractExpirationNotificationDate ? this.customContractExpirationNotificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    primaryCategoryArea?: ProfessionalRoleDto;
    primaryCategoryType?: ProfessionalRoleDto;
    primaryCategoryRole?: ProfessionalRoleDto;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    commissionedEmployeesIdValues?: number[] | undefined;
    commissionedEmployeesData?: EmployeeDto[] | undefined;
    primarySourcerId?: number | undefined;
    primarySourcer?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: ContractExpirationNotificationInterval[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;
}

export class SaveAgreementAuxiliaryDto implements ISaveAgreementAuxiliaryDto {
    auxiliaryAttachments?: AgreementAuxiliaryAttachmentDto[] | undefined;

    constructor(data?: ISaveAgreementAuxiliaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["auxiliaryAttachments"])) {
                this.auxiliaryAttachments = [] as any;
                for (let item of _data["auxiliaryAttachments"])
                    this.auxiliaryAttachments!.push(AgreementAuxiliaryAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveAgreementAuxiliaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAgreementAuxiliaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auxiliaryAttachments)) {
            data["auxiliaryAttachments"] = [];
            for (let item of this.auxiliaryAttachments)
                data["auxiliaryAttachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaveAgreementAuxiliaryDto {
    auxiliaryAttachments?: AgreementAuxiliaryAttachmentDto[] | undefined;
}

export class SaveAgreementCommandResult implements ISaveAgreementCommandResult {
    agreementId?: number;

    constructor(data?: ISaveAgreementCommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
        }
    }

    static fromJS(data: any): SaveAgreementCommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAgreementCommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        return data;
    }
}

export interface ISaveAgreementCommandResult {
    agreementId?: number;
}

export class SaveAgreementDto implements ISaveAgreementDto {
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementId?: number | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypes?: number[] | undefined;
    salesTypes?: number[] | undefined;
    deliveryTypes?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementSignerDto[] | undefined;
    attachments?: AgreementAttachmentDto[] | undefined;
    parentSelectedAttachmentIds?: number[] | undefined;

    constructor(data?: ISaveAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientPeriodId = _data["clientPeriodId"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.creationMode = _data["creationMode"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.duplicationSourceAgreementId = _data["duplicationSourceAgreementId"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.recipientId = _data["recipientId"];
            this.nameTemplate = _data["nameTemplate"];
            this.definition = _data["definition"];
            this.legalEntityId = _data["legalEntityId"];
            if (Array.isArray(_data["contractTypes"])) {
                this.contractTypes = [] as any;
                for (let item of _data["contractTypes"])
                    this.contractTypes!.push(item);
            }
            if (Array.isArray(_data["salesTypes"])) {
                this.salesTypes = [] as any;
                for (let item of _data["salesTypes"])
                    this.salesTypes!.push(item);
            }
            if (Array.isArray(_data["deliveryTypes"])) {
                this.deliveryTypes = [] as any;
                for (let item of _data["deliveryTypes"])
                    this.deliveryTypes!.push(item);
            }
            this.language = _data["language"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(AgreementSignerDto.fromJS(item));
            }
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["parentSelectedAttachmentIds"])) {
                this.parentSelectedAttachmentIds = [] as any;
                for (let item of _data["parentSelectedAttachmentIds"])
                    this.parentSelectedAttachmentIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SaveAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientPeriodId"] = this.clientPeriodId;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["creationMode"] = this.creationMode;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["duplicationSourceAgreementId"] = this.duplicationSourceAgreementId;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["recipientId"] = this.recipientId;
        data["nameTemplate"] = this.nameTemplate;
        data["definition"] = this.definition;
        data["legalEntityId"] = this.legalEntityId;
        if (Array.isArray(this.contractTypes)) {
            data["contractTypes"] = [];
            for (let item of this.contractTypes)
                data["contractTypes"].push(item);
        }
        if (Array.isArray(this.salesTypes)) {
            data["salesTypes"] = [];
            for (let item of this.salesTypes)
                data["salesTypes"].push(item);
        }
        if (Array.isArray(this.deliveryTypes)) {
            data["deliveryTypes"] = [];
            for (let item of this.deliveryTypes)
                data["deliveryTypes"].push(item);
        }
        data["language"] = this.language;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["note"] = this.note;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        data["isSignatureRequired"] = this.isSignatureRequired;
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.parentSelectedAttachmentIds)) {
            data["parentSelectedAttachmentIds"] = [];
            for (let item of this.parentSelectedAttachmentIds)
                data["parentSelectedAttachmentIds"].push(item);
        }
        return data;
    }
}

export interface ISaveAgreementDto {
    clientPeriodId?: string | undefined;
    consultantPeriodId?: string | undefined;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementId?: number | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    recipientId?: number;
    nameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntityId?: number;
    contractTypes?: number[] | undefined;
    salesTypes?: number[] | undefined;
    deliveryTypes?: number[] | undefined;
    language?: AgreementLanguage;
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    note?: string | undefined;
    receiveAgreementsFromOtherParty?: boolean;
    isSignatureRequired?: boolean;
    signers?: AgreementSignerDto[] | undefined;
    attachments?: AgreementAttachmentDto[] | undefined;
    parentSelectedAttachmentIds?: number[] | undefined;
}

export class SaveAgreementTemplateCommandResult implements ISaveAgreementTemplateCommandResult {
    agreementTemplateId?: number;

    constructor(data?: ISaveAgreementTemplateCommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
        }
    }

    static fromJS(data: any): SaveAgreementTemplateCommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAgreementTemplateCommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        return data;
    }
}

export interface ISaveAgreementTemplateCommandResult {
    agreementTemplateId?: number;
}

export class SaveAgreementTemplateDto implements ISaveAgreementTemplateDto {
    isEnabled?: boolean;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntities?: number[] | undefined;
    contractTypes?: number[] | undefined;
    salesTypes?: number[] | undefined;
    deliveryTypes?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateAttachmentDto[] | undefined;
    parentSelectedAttachmentIds?: number[] | undefined;
    isDefaultTemplate?: boolean;

    constructor(data?: ISaveAgreementTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.creationMode = _data["creationMode"];
            this.parentAgreementTemplateId = _data["parentAgreementTemplateId"];
            this.duplicationSourceAgreementTemplateId = _data["duplicationSourceAgreementTemplateId"];
            this.agreementType = _data["agreementType"];
            this.recipientTypeId = _data["recipientTypeId"];
            this.clientId = _data["clientId"];
            this.documentFileProvidedByClient = _data["documentFileProvidedByClient"];
            this.name = _data["name"];
            this.agreementNameTemplate = _data["agreementNameTemplate"];
            this.definition = _data["definition"];
            if (Array.isArray(_data["legalEntities"])) {
                this.legalEntities = [] as any;
                for (let item of _data["legalEntities"])
                    this.legalEntities!.push(item);
            }
            if (Array.isArray(_data["contractTypes"])) {
                this.contractTypes = [] as any;
                for (let item of _data["contractTypes"])
                    this.contractTypes!.push(item);
            }
            if (Array.isArray(_data["salesTypes"])) {
                this.salesTypes = [] as any;
                for (let item of _data["salesTypes"])
                    this.salesTypes!.push(item);
            }
            if (Array.isArray(_data["deliveryTypes"])) {
                this.deliveryTypes = [] as any;
                for (let item of _data["deliveryTypes"])
                    this.deliveryTypes!.push(item);
            }
            this.language = _data["language"];
            this.note = _data["note"];
            this.isSignatureRequired = _data["isSignatureRequired"];
            this.receiveAgreementsFromOtherParty = _data["receiveAgreementsFromOtherParty"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AgreementTemplateAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["parentSelectedAttachmentIds"])) {
                this.parentSelectedAttachmentIds = [] as any;
                for (let item of _data["parentSelectedAttachmentIds"])
                    this.parentSelectedAttachmentIds!.push(item);
            }
            this.isDefaultTemplate = _data["isDefaultTemplate"];
        }
    }

    static fromJS(data: any): SaveAgreementTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAgreementTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["creationMode"] = this.creationMode;
        data["parentAgreementTemplateId"] = this.parentAgreementTemplateId;
        data["duplicationSourceAgreementTemplateId"] = this.duplicationSourceAgreementTemplateId;
        data["agreementType"] = this.agreementType;
        data["recipientTypeId"] = this.recipientTypeId;
        data["clientId"] = this.clientId;
        data["documentFileProvidedByClient"] = this.documentFileProvidedByClient;
        data["name"] = this.name;
        data["agreementNameTemplate"] = this.agreementNameTemplate;
        data["definition"] = this.definition;
        if (Array.isArray(this.legalEntities)) {
            data["legalEntities"] = [];
            for (let item of this.legalEntities)
                data["legalEntities"].push(item);
        }
        if (Array.isArray(this.contractTypes)) {
            data["contractTypes"] = [];
            for (let item of this.contractTypes)
                data["contractTypes"].push(item);
        }
        if (Array.isArray(this.salesTypes)) {
            data["salesTypes"] = [];
            for (let item of this.salesTypes)
                data["salesTypes"].push(item);
        }
        if (Array.isArray(this.deliveryTypes)) {
            data["deliveryTypes"] = [];
            for (let item of this.deliveryTypes)
                data["deliveryTypes"].push(item);
        }
        data["language"] = this.language;
        data["note"] = this.note;
        data["isSignatureRequired"] = this.isSignatureRequired;
        data["receiveAgreementsFromOtherParty"] = this.receiveAgreementsFromOtherParty;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.parentSelectedAttachmentIds)) {
            data["parentSelectedAttachmentIds"] = [];
            for (let item of this.parentSelectedAttachmentIds)
                data["parentSelectedAttachmentIds"].push(item);
        }
        data["isDefaultTemplate"] = this.isDefaultTemplate;
        return data;
    }
}

export interface ISaveAgreementTemplateDto {
    isEnabled?: boolean;
    creationMode?: AgreementCreationMode;
    parentAgreementTemplateId?: number | undefined;
    duplicationSourceAgreementTemplateId?: number | undefined;
    agreementType?: AgreementType;
    recipientTypeId?: number;
    clientId?: number | undefined;
    documentFileProvidedByClient?: boolean | undefined;
    name?: string | undefined;
    agreementNameTemplate?: string | undefined;
    definition?: string | undefined;
    legalEntities?: number[] | undefined;
    contractTypes?: number[] | undefined;
    salesTypes?: number[] | undefined;
    deliveryTypes?: number[] | undefined;
    language?: AgreementLanguage;
    note?: string | undefined;
    isSignatureRequired?: boolean;
    receiveAgreementsFromOtherParty?: boolean;
    attachments?: AgreementTemplateAttachmentDto[] | undefined;
    parentSelectedAttachmentIds?: number[] | undefined;
    isDefaultTemplate?: boolean;
}

export class SendDocuSignEnvelopeCommand implements ISendDocuSignEnvelopeCommand {
    agreementIds?: number[] | undefined;
    singleEnvelope?: boolean;
    createDraftOnly?: boolean;
    emailSubject?: string | undefined;
    emailBody?: string | undefined;
    skipMergeFieldsValidation?: boolean;
    skipAgreementStatusValidation?: boolean;

    constructor(data?: ISendDocuSignEnvelopeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["agreementIds"])) {
                this.agreementIds = [] as any;
                for (let item of _data["agreementIds"])
                    this.agreementIds!.push(item);
            }
            this.singleEnvelope = _data["singleEnvelope"];
            this.createDraftOnly = _data["createDraftOnly"];
            this.emailSubject = _data["emailSubject"];
            this.emailBody = _data["emailBody"];
            this.skipMergeFieldsValidation = _data["skipMergeFieldsValidation"];
            this.skipAgreementStatusValidation = _data["skipAgreementStatusValidation"];
        }
    }

    static fromJS(data: any): SendDocuSignEnvelopeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendDocuSignEnvelopeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.agreementIds)) {
            data["agreementIds"] = [];
            for (let item of this.agreementIds)
                data["agreementIds"].push(item);
        }
        data["singleEnvelope"] = this.singleEnvelope;
        data["createDraftOnly"] = this.createDraftOnly;
        data["emailSubject"] = this.emailSubject;
        data["emailBody"] = this.emailBody;
        data["skipMergeFieldsValidation"] = this.skipMergeFieldsValidation;
        data["skipAgreementStatusValidation"] = this.skipAgreementStatusValidation;
        return data;
    }
}

export interface ISendDocuSignEnvelopeCommand {
    agreementIds?: number[] | undefined;
    singleEnvelope?: boolean;
    createDraftOnly?: boolean;
    emailSubject?: string | undefined;
    emailBody?: string | undefined;
    skipMergeFieldsValidation?: boolean;
    skipAgreementStatusValidation?: boolean;
}

export class SendEmailEnvelopeCommand implements ISendEmailEnvelopeCommand {
    agreementIds?: number[] | undefined;
    singleEmail?: boolean;
    convertDocumentFileToPdf?: boolean;
    skipMergeFieldsValidation?: boolean;
    skipAgreementStatusValidation?: boolean;

    constructor(data?: ISendEmailEnvelopeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["agreementIds"])) {
                this.agreementIds = [] as any;
                for (let item of _data["agreementIds"])
                    this.agreementIds!.push(item);
            }
            this.singleEmail = _data["singleEmail"];
            this.convertDocumentFileToPdf = _data["convertDocumentFileToPdf"];
            this.skipMergeFieldsValidation = _data["skipMergeFieldsValidation"];
            this.skipAgreementStatusValidation = _data["skipAgreementStatusValidation"];
        }
    }

    static fromJS(data: any): SendEmailEnvelopeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailEnvelopeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.agreementIds)) {
            data["agreementIds"] = [];
            for (let item of this.agreementIds)
                data["agreementIds"].push(item);
        }
        data["singleEmail"] = this.singleEmail;
        data["convertDocumentFileToPdf"] = this.convertDocumentFileToPdf;
        data["skipMergeFieldsValidation"] = this.skipMergeFieldsValidation;
        data["skipAgreementStatusValidation"] = this.skipAgreementStatusValidation;
        return data;
    }
}

export interface ISendEmailEnvelopeCommand {
    agreementIds?: number[] | undefined;
    singleEmail?: boolean;
    convertDocumentFileToPdf?: boolean;
    skipMergeFieldsValidation?: boolean;
    skipAgreementStatusValidation?: boolean;
}

export class SendToDocuSignTestCommand implements ISendToDocuSignTestCommand {
    files?: FileDef[] | undefined;
    signers?: Signer[] | undefined;
    ccRecipientEmail?: string | undefined;
    ccRecipientName?: string | undefined;

    constructor(data?: ISendToDocuSignTestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileDef.fromJS(item));
            }
            if (Array.isArray(_data["signers"])) {
                this.signers = [] as any;
                for (let item of _data["signers"])
                    this.signers!.push(Signer.fromJS(item));
            }
            this.ccRecipientEmail = _data["ccRecipientEmail"];
            this.ccRecipientName = _data["ccRecipientName"];
        }
    }

    static fromJS(data: any): SendToDocuSignTestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendToDocuSignTestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (Array.isArray(this.signers)) {
            data["signers"] = [];
            for (let item of this.signers)
                data["signers"].push(item.toJSON());
        }
        data["ccRecipientEmail"] = this.ccRecipientEmail;
        data["ccRecipientName"] = this.ccRecipientName;
        return data;
    }
}

export interface ISendToDocuSignTestCommand {
    files?: FileDef[] | undefined;
    signers?: Signer[] | undefined;
    ccRecipientEmail?: string | undefined;
    ccRecipientName?: string | undefined;
}

export class Signer implements ISigner {
    signerEmail?: string | undefined;
    signerName?: string | undefined;
    signatureAnchorString?: string | undefined;

    constructor(data?: ISigner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signerEmail = _data["signerEmail"];
            this.signerName = _data["signerName"];
            this.signatureAnchorString = _data["signatureAnchorString"];
        }
    }

    static fromJS(data: any): Signer {
        data = typeof data === 'object' ? data : {};
        let result = new Signer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signerEmail"] = this.signerEmail;
        data["signerName"] = this.signerName;
        data["signatureAnchorString"] = this.signatureAnchorString;
        return data;
    }
}

export interface ISigner {
    signerEmail?: string | undefined;
    signerName?: string | undefined;
    signatureAnchorString?: string | undefined;
}

export enum SignerType {
    InternalEmagine = 1,
    Client = 2,
    Consultant = 3,
    Supplier = 4,
}

export class SimpleAgreementTemplatesListItemDto implements ISimpleAgreementTemplatesListItemDto {
    agreementTemplateId?: number;
    name?: string | undefined;
    clientName?: string | undefined;
    agreementType?: AgreementType;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    currentVersion?: number | undefined;
    languageId?: AgreementLanguage;
    createdDateUtc?: moment.Moment;
    isEnabled?: boolean;
    tenantIds?: number[] | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;

    constructor(data?: ISimpleAgreementTemplatesListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementTemplateId = _data["agreementTemplateId"];
            this.name = _data["name"];
            this.clientName = _data["clientName"];
            this.agreementType = _data["agreementType"];
            this.linkState = _data["linkState"];
            this.linkStateAccepted = _data["linkStateAccepted"];
            this.currentVersion = _data["currentVersion"];
            this.languageId = _data["languageId"];
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.isEnabled = _data["isEnabled"];
            if (Array.isArray(_data["tenantIds"])) {
                this.tenantIds = [] as any;
                for (let item of _data["tenantIds"])
                    this.tenantIds!.push(item);
            }
            this.hasDraftVersion = _data["hasDraftVersion"];
            this.hasCurrentVersion = _data["hasCurrentVersion"];
        }
    }

    static fromJS(data: any): SimpleAgreementTemplatesListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleAgreementTemplatesListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementTemplateId"] = this.agreementTemplateId;
        data["name"] = this.name;
        data["clientName"] = this.clientName;
        data["agreementType"] = this.agreementType;
        data["linkState"] = this.linkState;
        data["linkStateAccepted"] = this.linkStateAccepted;
        data["currentVersion"] = this.currentVersion;
        data["languageId"] = this.languageId;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        if (Array.isArray(this.tenantIds)) {
            data["tenantIds"] = [];
            for (let item of this.tenantIds)
                data["tenantIds"].push(item);
        }
        data["hasDraftVersion"] = this.hasDraftVersion;
        data["hasCurrentVersion"] = this.hasCurrentVersion;
        return data;
    }
}

export interface ISimpleAgreementTemplatesListItemDto {
    agreementTemplateId?: number;
    name?: string | undefined;
    clientName?: string | undefined;
    agreementType?: AgreementType;
    linkState?: AgreementTemplateParentChildLinkState;
    linkStateAccepted?: boolean | undefined;
    currentVersion?: number | undefined;
    languageId?: AgreementLanguage;
    createdDateUtc?: moment.Moment;
    isEnabled?: boolean;
    tenantIds?: number[] | undefined;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
}

export class SimpleAgreementTemplatesListItemDtoPaginatedList implements ISimpleAgreementTemplatesListItemDtoPaginatedList {
    items?: SimpleAgreementTemplatesListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ISimpleAgreementTemplatesListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SimpleAgreementTemplatesListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): SimpleAgreementTemplatesListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleAgreementTemplatesListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface ISimpleAgreementTemplatesListItemDtoPaginatedList {
    items?: SimpleAgreementTemplatesListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SimplePublicObject implements ISimplePublicObject {
    id!: string;
    properties!: { [key: string]: string; };
    createdAt!: moment.Moment;
    updatedAt!: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISimplePublicObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.archivedAt = _data["archivedAt"] ? moment(_data["archivedAt"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimplePublicObject {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePublicObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["archivedAt"] = this.archivedAt ? this.archivedAt.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISimplePublicObject {
    id: string;
    properties: { [key: string]: string; };
    createdAt: moment.Moment;
    updatedAt: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SimpleRequestLocationDto implements ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;

    constructor(data?: ISimpleRequestLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"] ? IdNameDto.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"] ? IdNameDto.fromJS(_data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimpleRequestLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleRequestLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;
}

export class SpecialRateReportingUnit implements ISpecialRateReportingUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateReportingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateReportingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateReportingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateReportingUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class SpecialRateSpecifiedAs implements ISpecialRateSpecifiedAs {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateSpecifiedAs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateSpecifiedAs {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateSpecifiedAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateSpecifiedAs {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class StartNewWorkflowInputDto implements IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;

    constructor(data?: IStartNewWorkflowInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
        }
    }

    static fromJS(data: any): StartNewWorkflowInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StartNewWorkflowInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["requestId"] = this.requestId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        return data;
    }
}

export interface IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;
}

export class StepDto implements IStepDto {
    id?: number | undefined;
    typeId?: StepType;
    readonly name?: string | undefined;
    isFakeActiveStep?: boolean;
    status?: WorkflowStepStatus;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: boolean; } | undefined;

    constructor(data?: IStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.isFakeActiveStep = _data["isFakeActiveStep"];
            this.status = _data["status"];
            this.responsiblePerson = _data["responsiblePerson"] ? EmployeeDto.fromJS(_data["responsiblePerson"]) : <any>undefined;
            if (_data["actionsPermissionsForCurrentUser"]) {
                this.actionsPermissionsForCurrentUser = {} as any;
                for (let key in _data["actionsPermissionsForCurrentUser"]) {
                    if (_data["actionsPermissionsForCurrentUser"].hasOwnProperty(key))
                        (<any>this.actionsPermissionsForCurrentUser)![key] = _data["actionsPermissionsForCurrentUser"][key];
                }
            }
        }
    }

    static fromJS(data: any): StepDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["isFakeActiveStep"] = this.isFakeActiveStep;
        data["status"] = this.status;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        if (this.actionsPermissionsForCurrentUser) {
            data["actionsPermissionsForCurrentUser"] = {};
            for (let key in this.actionsPermissionsForCurrentUser) {
                if (this.actionsPermissionsForCurrentUser.hasOwnProperty(key))
                    (<any>data["actionsPermissionsForCurrentUser"])[key] = this.actionsPermissionsForCurrentUser[key];
            }
        }
        return data;
    }
}

export interface IStepDto {
    id?: number | undefined;
    typeId?: StepType;
    name?: string | undefined;
    isFakeActiveStep?: boolean;
    status?: WorkflowStepStatus;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: boolean; } | undefined;
}

export enum StepType {
    Sales = 1,
    Contract = 2,
    Finance = 3,
    Sourcing = 4,
}

export class StringWrappedValueDto implements IStringWrappedValueDto {
    value?: string | undefined;

    constructor(data?: IStringWrappedValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringWrappedValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringWrappedValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IStringWrappedValueDto {
    value?: string | undefined;
}

export class SupplierMemberResultDto implements ISupplierMemberResultDto {
    id?: number;
    name?: string | undefined;
    supplierId?: number;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    supplierCompanyName?: string | undefined;
    vatNumber?: string | undefined;
    isOwner?: boolean;
    externalId?: string;

    constructor(data?: ISupplierMemberResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.supplierId = _data["supplierId"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.supplierCompanyName = _data["supplierCompanyName"];
            this.vatNumber = _data["vatNumber"];
            this.isOwner = _data["isOwner"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): SupplierMemberResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierMemberResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["supplierId"] = this.supplierId;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["vatNumber"] = this.vatNumber;
        data["isOwner"] = this.isOwner;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface ISupplierMemberResultDto {
    id?: number;
    name?: string | undefined;
    supplierId?: number;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    supplierCompanyName?: string | undefined;
    vatNumber?: string | undefined;
    isOwner?: boolean;
    externalId?: string;
}

export class SupplierResultDto implements ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    email?: string | undefined;
    externalId?: string;
    vatNumber?: string | undefined;
    countryCode?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    address?: string | undefined;

    constructor(data?: ISupplierResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.email = _data["email"];
            this.externalId = _data["externalId"];
            this.vatNumber = _data["vatNumber"];
            this.countryCode = _data["countryCode"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): SupplierResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["email"] = this.email;
        data["externalId"] = this.externalId;
        data["vatNumber"] = this.vatNumber;
        data["countryCode"] = this.countryCode;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["address"] = this.address;
        return data;
    }
}

export interface ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    email?: string | undefined;
    externalId?: string;
    vatNumber?: string | undefined;
    countryCode?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    address?: string | undefined;
}

export class SyncClientFromCrmResultDto implements ISyncClientFromCrmResultDto {
    message?: string | undefined;

    constructor(data?: ISyncClientFromCrmResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SyncClientFromCrmResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncClientFromCrmResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ISyncClientFromCrmResultDto {
    message?: string | undefined;
}

export enum SyncStateStatus {
    NotSynced = 1,
    NewSyncNeeded = 2,
    Synced = 3,
}

export class TemplateListItem implements ITemplateListItem {
    templateId?: string;
    name?: string | undefined;
    description?: string | undefined;
    emailSubject?: string | undefined;
    emailBody?: string | undefined;
    owner?: string | undefined;

    constructor(data?: ITemplateListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.emailSubject = _data["emailSubject"];
            this.emailBody = _data["emailBody"];
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): TemplateListItem {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["emailSubject"] = this.emailSubject;
        data["emailBody"] = this.emailBody;
        data["owner"] = this.owner;
        return data;
    }
}

export interface ITemplateListItem {
    templateId?: string;
    name?: string | undefined;
    description?: string | undefined;
    emailSubject?: string | undefined;
    emailBody?: string | undefined;
    owner?: string | undefined;
}

export class Tenant implements ITenant {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;
    country?: Country;

    constructor(data?: ITenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            this.timeZone = _data["timeZone"];
            this.culture = _data["culture"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Tenant {
        data = typeof data === 'object' ? data : {};
        let result = new Tenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["timeZone"] = this.timeZone;
        data["culture"] = this.culture;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenant {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;
    country?: Country;
}

export class TenantConfigDto implements ITenantConfigDto {
    tenantId?: number;
    tenantName?: string | undefined;
    workflowStepEmployeeAssignments?: WorkflowStepEmployeeAssignmentDto[] | undefined;

    constructor(data?: ITenantConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            if (Array.isArray(_data["workflowStepEmployeeAssignments"])) {
                this.workflowStepEmployeeAssignments = [] as any;
                for (let item of _data["workflowStepEmployeeAssignments"])
                    this.workflowStepEmployeeAssignments!.push(WorkflowStepEmployeeAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        if (Array.isArray(this.workflowStepEmployeeAssignments)) {
            data["workflowStepEmployeeAssignments"] = [];
            for (let item of this.workflowStepEmployeeAssignments)
                data["workflowStepEmployeeAssignments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITenantConfigDto {
    tenantId?: number;
    tenantName?: string | undefined;
    workflowStepEmployeeAssignments?: WorkflowStepEmployeeAssignmentDto[] | undefined;
}

export enum TerminationReason {
    RequestedByClient = 1,
    RequestedByConsultant = 2,
    AdminTermination = 3,
}

export enum TerminationTime {
    AccordingToContract = 1,
    BeforeEndOfContract = 2,
    ContractDidNotStart = 3,
}

export class TimeReportingCapDto implements ITimeReportingCapDto {
    id?: TimeReportingCapId;
    timeReportingCapMaxValue?: number;
    valueUnitId?: number;
    periodUnitId?: number;

    constructor(data?: ITimeReportingCapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] ? TimeReportingCapId.fromJS(_data["id"]) : <any>undefined;
            this.timeReportingCapMaxValue = _data["timeReportingCapMaxValue"];
            this.valueUnitId = _data["valueUnitId"];
            this.periodUnitId = _data["periodUnitId"];
        }
    }

    static fromJS(data: any): TimeReportingCapDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimeReportingCapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id ? this.id.toJSON() : <any>undefined;
        data["timeReportingCapMaxValue"] = this.timeReportingCapMaxValue;
        data["valueUnitId"] = this.valueUnitId;
        data["periodUnitId"] = this.periodUnitId;
        return data;
    }
}

export interface ITimeReportingCapDto {
    id?: TimeReportingCapId;
    timeReportingCapMaxValue?: number;
    valueUnitId?: number;
    periodUnitId?: number;
}

export class TimeReportingCapId implements ITimeReportingCapId {
    readonly value?: number;

    constructor(data?: ITimeReportingCapId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): TimeReportingCapId {
        data = typeof data === 'object' ? data : {};
        let result = new TimeReportingCapId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ITimeReportingCapId {
    value?: number;
}

export class UpdateClientAttachmentFileInfoInputDto implements IUpdateClientAttachmentFileInfoInputDto {
    clientAttachmentGuid?: string;
    headline?: string | undefined;
    fileType?: ClientAttachmentTypeEnum;
    file?: string | undefined;

    constructor(data?: IUpdateClientAttachmentFileInfoInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientAttachmentGuid = _data["clientAttachmentGuid"];
            this.headline = _data["headline"];
            this.fileType = _data["fileType"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): UpdateClientAttachmentFileInfoInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientAttachmentFileInfoInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientAttachmentGuid"] = this.clientAttachmentGuid;
        data["headline"] = this.headline;
        data["fileType"] = this.fileType;
        data["file"] = this.file;
        return data;
    }
}

export interface IUpdateClientAttachmentFileInfoInputDto {
    clientAttachmentGuid?: string;
    headline?: string | undefined;
    fileType?: ClientAttachmentTypeEnum;
    file?: string | undefined;
}

export class UpdateClientSpecialFeeDto implements IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class UpdateClientSpecialRateDto implements IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class UpdateClientWFResponsibleCommand implements IUpdateClientWFResponsibleCommand {
    clientId?: number | undefined;
    contractStepResponsibleEmployeeId?: number | undefined;
    financeStepResponsibleEmployeeId?: number | undefined;

    constructor(data?: IUpdateClientWFResponsibleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.contractStepResponsibleEmployeeId = _data["contractStepResponsibleEmployeeId"];
            this.financeStepResponsibleEmployeeId = _data["financeStepResponsibleEmployeeId"];
        }
    }

    static fromJS(data: any): UpdateClientWFResponsibleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientWFResponsibleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["contractStepResponsibleEmployeeId"] = this.contractStepResponsibleEmployeeId;
        data["financeStepResponsibleEmployeeId"] = this.financeStepResponsibleEmployeeId;
        return data;
    }
}

export interface IUpdateClientWFResponsibleCommand {
    clientId?: number | undefined;
    contractStepResponsibleEmployeeId?: number | undefined;
    financeStepResponsibleEmployeeId?: number | undefined;
}

export class UpdateCommentInputDto implements IUpdateCommentInputDto {
    text?: string | undefined;
    metadata?: string | undefined;
    id?: number;

    constructor(data?: IUpdateCommentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.metadata = _data["metadata"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["metadata"] = this.metadata;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCommentInputDto {
    text?: string | undefined;
    metadata?: string | undefined;
    id?: number;
}

export class UpdateCompletedTemplateDocumentFileDto implements IUpdateCompletedTemplateDocumentFileDto {
    versionDescription?: string | undefined;
    propagateChangesToDerivedTemplates?: boolean | undefined;
    markActiveAgreementsAsOutdated?: boolean;
    fileContent?: string | undefined;

    constructor(data?: IUpdateCompletedTemplateDocumentFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionDescription = _data["versionDescription"];
            this.propagateChangesToDerivedTemplates = _data["propagateChangesToDerivedTemplates"];
            this.markActiveAgreementsAsOutdated = _data["markActiveAgreementsAsOutdated"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): UpdateCompletedTemplateDocumentFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompletedTemplateDocumentFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionDescription"] = this.versionDescription;
        data["propagateChangesToDerivedTemplates"] = this.propagateChangesToDerivedTemplates;
        data["markActiveAgreementsAsOutdated"] = this.markActiveAgreementsAsOutdated;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface IUpdateCompletedTemplateDocumentFileDto {
    versionDescription?: string | undefined;
    propagateChangesToDerivedTemplates?: boolean | undefined;
    markActiveAgreementsAsOutdated?: boolean;
    fileContent?: string | undefined;
}

export class UpdateDocuSignEnvelopeStatusCommand implements IUpdateDocuSignEnvelopeStatusCommand {
    docuSignEnvelopeId?: string;
    event?: DocuSignEvent;
    timestampUtc?: moment.Moment;
    docuSignRecipientId?: string | undefined;
    envelopeSummary?: DocuSignEnvelopeSummary;

    constructor(data?: IUpdateDocuSignEnvelopeStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docuSignEnvelopeId = _data["docuSignEnvelopeId"];
            this.event = _data["event"];
            this.timestampUtc = _data["timestampUtc"] ? moment(_data["timestampUtc"].toString()) : <any>undefined;
            this.docuSignRecipientId = _data["docuSignRecipientId"];
            this.envelopeSummary = _data["envelopeSummary"] ? DocuSignEnvelopeSummary.fromJS(_data["envelopeSummary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDocuSignEnvelopeStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocuSignEnvelopeStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docuSignEnvelopeId"] = this.docuSignEnvelopeId;
        data["event"] = this.event;
        data["timestampUtc"] = this.timestampUtc ? this.timestampUtc.toISOString() : <any>undefined;
        data["docuSignRecipientId"] = this.docuSignRecipientId;
        data["envelopeSummary"] = this.envelopeSummary ? this.envelopeSummary.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateDocuSignEnvelopeStatusCommand {
    docuSignEnvelopeId?: string;
    event?: DocuSignEvent;
    timestampUtc?: moment.Moment;
    docuSignRecipientId?: string | undefined;
    envelopeSummary?: DocuSignEnvelopeSummary;
}

export class UpdateProjectLineFromLegacyCommand implements IUpdateProjectLineFromLegacyCommand {
    projectLineId?: number;
    referenceNumber?: string | undefined;
    optionalInvoiceText?: string | undefined;

    constructor(data?: IUpdateProjectLineFromLegacyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectLineId = _data["projectLineId"];
            this.referenceNumber = _data["referenceNumber"];
            this.optionalInvoiceText = _data["optionalInvoiceText"];
        }
    }

    static fromJS(data: any): UpdateProjectLineFromLegacyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectLineFromLegacyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectLineId"] = this.projectLineId;
        data["referenceNumber"] = this.referenceNumber;
        data["optionalInvoiceText"] = this.optionalInvoiceText;
        return data;
    }
}

export interface IUpdateProjectLineFromLegacyCommand {
    projectLineId?: number;
    referenceNumber?: string | undefined;
    optionalInvoiceText?: string | undefined;
}

export class WorkflowAlreadyExistsDto implements IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;

    constructor(data?: IWorkflowAlreadyExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.existingWorkflowId = _data["existingWorkflowId"];
        }
    }

    static fromJS(data: any): WorkflowAlreadyExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAlreadyExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingWorkflowId"] = this.existingWorkflowId;
        return data;
    }
}

export interface IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;
}

export class WorkflowDocumentCommandDto implements IWorkflowDocumentCommandDto {
    workflowDocumentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;

    constructor(data?: IWorkflowDocumentCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowDocumentId = _data["workflowDocumentId"];
            this.temporaryFileId = _data["temporaryFileId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowDocumentCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDocumentCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowDocumentId"] = this.workflowDocumentId;
        data["temporaryFileId"] = this.temporaryFileId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWorkflowDocumentCommandDto {
    workflowDocumentId?: number | undefined;
    temporaryFileId?: string | undefined;
    name?: string | undefined;
}

export class WorkflowDocumentQueryDto implements IWorkflowDocumentQueryDto {
    id?: number;
    clientPeriodId?: string | undefined;
    workflowTerminationId?: string | undefined;
    workflowProcessType?: WorkflowProcessType;
    stepType?: StepType;
    name?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;

    constructor(data?: IWorkflowDocumentQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientPeriodId = _data["clientPeriodId"];
            this.workflowTerminationId = _data["workflowTerminationId"];
            this.workflowProcessType = _data["workflowProcessType"];
            this.stepType = _data["stepType"];
            this.name = _data["name"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowDocumentQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDocumentQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientPeriodId"] = this.clientPeriodId;
        data["workflowTerminationId"] = this.workflowTerminationId;
        data["workflowProcessType"] = this.workflowProcessType;
        data["stepType"] = this.stepType;
        data["name"] = this.name;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWorkflowDocumentQueryDto {
    id?: number;
    clientPeriodId?: string | undefined;
    workflowTerminationId?: string | undefined;
    workflowProcessType?: WorkflowProcessType;
    stepType?: StepType;
    name?: string | undefined;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
}

export class WorkflowDto implements IWorkflowDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    workflowStatusId?: WorkflowStatus;
    isDeleted?: boolean;
    directClientId?: number | undefined;
    directClientName?: string | undefined;
    directClientCrmId?: number | undefined;
    endClientId?: number | undefined;
    endClientName?: string | undefined;
    endClientCrmId?: number | undefined;
    clientPeriods?: ClientPeriodDto[] | undefined;
    consultantNamesWithRequestUrls?: ConsultantNameWithRequestUrl[] | undefined;

    constructor(data?: IWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowSequenceIdCode = _data["workflowSequenceIdCode"];
            this.workflowStatusId = _data["workflowStatusId"];
            this.isDeleted = _data["isDeleted"];
            this.directClientId = _data["directClientId"];
            this.directClientName = _data["directClientName"];
            this.directClientCrmId = _data["directClientCrmId"];
            this.endClientId = _data["endClientId"];
            this.endClientName = _data["endClientName"];
            this.endClientCrmId = _data["endClientCrmId"];
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(ClientPeriodDto.fromJS(item));
            }
            if (Array.isArray(_data["consultantNamesWithRequestUrls"])) {
                this.consultantNamesWithRequestUrls = [] as any;
                for (let item of _data["consultantNamesWithRequestUrls"])
                    this.consultantNamesWithRequestUrls!.push(ConsultantNameWithRequestUrl.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowSequenceIdCode"] = this.workflowSequenceIdCode;
        data["workflowStatusId"] = this.workflowStatusId;
        data["isDeleted"] = this.isDeleted;
        data["directClientId"] = this.directClientId;
        data["directClientName"] = this.directClientName;
        data["directClientCrmId"] = this.directClientCrmId;
        data["endClientId"] = this.endClientId;
        data["endClientName"] = this.endClientName;
        data["endClientCrmId"] = this.endClientCrmId;
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantNamesWithRequestUrls)) {
            data["consultantNamesWithRequestUrls"] = [];
            for (let item of this.consultantNamesWithRequestUrls)
                data["consultantNamesWithRequestUrls"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    workflowStatusId?: WorkflowStatus;
    isDeleted?: boolean;
    directClientId?: number | undefined;
    directClientName?: string | undefined;
    directClientCrmId?: number | undefined;
    endClientId?: number | undefined;
    endClientName?: string | undefined;
    endClientCrmId?: number | undefined;
    clientPeriods?: ClientPeriodDto[] | undefined;
    consultantNamesWithRequestUrls?: ConsultantNameWithRequestUrl[] | undefined;
}

export class WorkflowListConsultantDto implements IWorkflowListConsultantDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IWorkflowListConsultantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowListConsultantDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListConsultantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWorkflowListConsultantDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class WorkflowListEmployeeDto implements IWorkflowListEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IWorkflowListEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowListEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWorkflowListEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class WorkflowListItemDto implements IWorkflowListItemDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientName?: string | undefined;
    startDate?: moment.Moment;
    actualEndDate?: moment.Moment | undefined;
    startDateOfOpenedPeriodOrLastClientPeriod?: moment.Moment;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatus?: WorkflowStatus;
    syncStateStatus?: SyncStateStatus;
    isDeleted?: boolean;
    isCompleted?: boolean;
    isNewSale?: boolean;
    consultantName?: string | undefined;
    consultantNamesTooltip?: string | undefined;
    consultants?: WorkflowListConsultantDto[] | undefined;
    openProcesses?: WorkflowListProcessDto[] | undefined;

    constructor(data?: IWorkflowListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowSequenceIdCode = _data["workflowSequenceIdCode"];
            this.clientName = _data["clientName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.actualEndDate = _data["actualEndDate"] ? moment(_data["actualEndDate"].toString()) : <any>undefined;
            this.startDateOfOpenedPeriodOrLastClientPeriod = _data["startDateOfOpenedPeriodOrLastClientPeriod"] ? moment(_data["startDateOfOpenedPeriodOrLastClientPeriod"].toString()) : <any>undefined;
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.workflowStatus = _data["workflowStatus"];
            this.syncStateStatus = _data["syncStateStatus"];
            this.isDeleted = _data["isDeleted"];
            this.isCompleted = _data["isCompleted"];
            this.isNewSale = _data["isNewSale"];
            this.consultantName = _data["consultantName"];
            this.consultantNamesTooltip = _data["consultantNamesTooltip"];
            if (Array.isArray(_data["consultants"])) {
                this.consultants = [] as any;
                for (let item of _data["consultants"])
                    this.consultants!.push(WorkflowListConsultantDto.fromJS(item));
            }
            if (Array.isArray(_data["openProcesses"])) {
                this.openProcesses = [] as any;
                for (let item of _data["openProcesses"])
                    this.openProcesses!.push(WorkflowListProcessDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowSequenceIdCode"] = this.workflowSequenceIdCode;
        data["clientName"] = this.clientName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["startDateOfOpenedPeriodOrLastClientPeriod"] = this.startDateOfOpenedPeriodOrLastClientPeriod ? this.startDateOfOpenedPeriodOrLastClientPeriod.format('YYYY-MM-DD') : <any>undefined;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["workflowStatus"] = this.workflowStatus;
        data["syncStateStatus"] = this.syncStateStatus;
        data["isDeleted"] = this.isDeleted;
        data["isCompleted"] = this.isCompleted;
        data["isNewSale"] = this.isNewSale;
        data["consultantName"] = this.consultantName;
        data["consultantNamesTooltip"] = this.consultantNamesTooltip;
        if (Array.isArray(this.consultants)) {
            data["consultants"] = [];
            for (let item of this.consultants)
                data["consultants"].push(item.toJSON());
        }
        if (Array.isArray(this.openProcesses)) {
            data["openProcesses"] = [];
            for (let item of this.openProcesses)
                data["openProcesses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowListItemDto {
    workflowId?: string;
    workflowSequenceIdCode?: string | undefined;
    clientName?: string | undefined;
    startDate?: moment.Moment;
    actualEndDate?: moment.Moment | undefined;
    startDateOfOpenedPeriodOrLastClientPeriod?: moment.Moment;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    workflowStatus?: WorkflowStatus;
    syncStateStatus?: SyncStateStatus;
    isDeleted?: boolean;
    isCompleted?: boolean;
    isNewSale?: boolean;
    consultantName?: string | undefined;
    consultantNamesTooltip?: string | undefined;
    consultants?: WorkflowListConsultantDto[] | undefined;
    openProcesses?: WorkflowListProcessDto[] | undefined;
}

export class WorkflowListItemDtoPaginatedList implements IWorkflowListItemDtoPaginatedList {
    items?: WorkflowListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IWorkflowListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkflowListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): WorkflowListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IWorkflowListItemDtoPaginatedList {
    items?: WorkflowListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkflowListProcessDto implements IWorkflowListProcessDto {
    typeId?: WorkflowProcessType;
    name?: string | undefined;
    processId?: string | undefined;
    clientPeriodId?: string | undefined;
    steps?: WorkflowListStepDto[] | undefined;

    constructor(data?: IWorkflowListProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.name = _data["name"];
            this.processId = _data["processId"];
            this.clientPeriodId = _data["clientPeriodId"];
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(WorkflowListStepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowListProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["processId"] = this.processId;
        data["clientPeriodId"] = this.clientPeriodId;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowListProcessDto {
    typeId?: WorkflowProcessType;
    name?: string | undefined;
    processId?: string | undefined;
    clientPeriodId?: string | undefined;
    steps?: WorkflowListStepDto[] | undefined;
}

export class WorkflowListStepDto implements IWorkflowListStepDto {
    typeId?: StepType;
    name?: string | undefined;
    status?: WorkflowStepStatus;
    responsiblePerson?: WorkflowListEmployeeDto;

    constructor(data?: IWorkflowListStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.responsiblePerson = _data["responsiblePerson"] ? WorkflowListEmployeeDto.fromJS(_data["responsiblePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowListStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowListStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["status"] = this.status;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowListStepDto {
    typeId?: StepType;
    name?: string | undefined;
    status?: WorkflowStepStatus;
    responsiblePerson?: WorkflowListEmployeeDto;
}

export class WorkflowOverviewDto implements IWorkflowOverviewDto {
    incompleteWorkflowProcesses?: WorkflowProcessDto[] | undefined;
    clientGanttRows?: ClientGanttRow[] | undefined;
    consultantGanttRows?: ConsultantGanttRow[] | undefined;
    actualEndDate?: moment.Moment | undefined;
    workflowStatusWithEmployeeDto?: WorkflowStatusWithEmployeeDto;
    mainOverviewStatusForSales?: MainOverviewStatus;
    isDeleted?: boolean;

    constructor(data?: IWorkflowOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incompleteWorkflowProcesses"])) {
                this.incompleteWorkflowProcesses = [] as any;
                for (let item of _data["incompleteWorkflowProcesses"])
                    this.incompleteWorkflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
            if (Array.isArray(_data["clientGanttRows"])) {
                this.clientGanttRows = [] as any;
                for (let item of _data["clientGanttRows"])
                    this.clientGanttRows!.push(ClientGanttRow.fromJS(item));
            }
            if (Array.isArray(_data["consultantGanttRows"])) {
                this.consultantGanttRows = [] as any;
                for (let item of _data["consultantGanttRows"])
                    this.consultantGanttRows!.push(ConsultantGanttRow.fromJS(item));
            }
            this.actualEndDate = _data["actualEndDate"] ? moment(_data["actualEndDate"].toString()) : <any>undefined;
            this.workflowStatusWithEmployeeDto = _data["workflowStatusWithEmployeeDto"] ? WorkflowStatusWithEmployeeDto.fromJS(_data["workflowStatusWithEmployeeDto"]) : <any>undefined;
            this.mainOverviewStatusForSales = _data["mainOverviewStatusForSales"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): WorkflowOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incompleteWorkflowProcesses)) {
            data["incompleteWorkflowProcesses"] = [];
            for (let item of this.incompleteWorkflowProcesses)
                data["incompleteWorkflowProcesses"].push(item.toJSON());
        }
        if (Array.isArray(this.clientGanttRows)) {
            data["clientGanttRows"] = [];
            for (let item of this.clientGanttRows)
                data["clientGanttRows"].push(item.toJSON());
        }
        if (Array.isArray(this.consultantGanttRows)) {
            data["consultantGanttRows"] = [];
            for (let item of this.consultantGanttRows)
                data["consultantGanttRows"].push(item.toJSON());
        }
        data["actualEndDate"] = this.actualEndDate ? this.actualEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["workflowStatusWithEmployeeDto"] = this.workflowStatusWithEmployeeDto ? this.workflowStatusWithEmployeeDto.toJSON() : <any>undefined;
        data["mainOverviewStatusForSales"] = this.mainOverviewStatusForSales;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IWorkflowOverviewDto {
    incompleteWorkflowProcesses?: WorkflowProcessDto[] | undefined;
    clientGanttRows?: ClientGanttRow[] | undefined;
    consultantGanttRows?: ConsultantGanttRow[] | undefined;
    actualEndDate?: moment.Moment | undefined;
    workflowStatusWithEmployeeDto?: WorkflowStatusWithEmployeeDto;
    mainOverviewStatusForSales?: MainOverviewStatus;
    isDeleted?: boolean;
}

export class WorkflowPeriodAgreementDto implements IWorkflowPeriodAgreementDto {
    agreementId?: number;
    name?: string | undefined;
    agreementStatus?: EnvelopeStatus;
    validity?: AgreementValidityState;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;
    inEditByEmployeeDtos?: EmployeeDto[] | undefined;
    docuSignUrl?: string | undefined;
    processingPath?: EnvelopeProcessingPath;

    constructor(data?: IWorkflowPeriodAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agreementId = _data["agreementId"];
            this.name = _data["name"];
            this.agreementStatus = _data["agreementStatus"];
            this.validity = _data["validity"];
            this.createdBy = _data["createdBy"] ? EmployeeDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.createdDateUtc = _data["createdDateUtc"] ? moment(_data["createdDateUtc"].toString()) : <any>undefined;
            this.lastUpdatedBy = _data["lastUpdatedBy"] ? EmployeeDto.fromJS(_data["lastUpdatedBy"]) : <any>undefined;
            this.lastUpdateDateUtc = _data["lastUpdateDateUtc"] ? moment(_data["lastUpdateDateUtc"].toString()) : <any>undefined;
            this.hasDraftVersion = _data["hasDraftVersion"];
            this.hasCurrentVersion = _data["hasCurrentVersion"];
            this.hasSignedDocumentFile = _data["hasSignedDocumentFile"];
            if (Array.isArray(_data["inEditByEmployeeDtos"])) {
                this.inEditByEmployeeDtos = [] as any;
                for (let item of _data["inEditByEmployeeDtos"])
                    this.inEditByEmployeeDtos!.push(EmployeeDto.fromJS(item));
            }
            this.docuSignUrl = _data["docuSignUrl"];
            this.processingPath = _data["processingPath"];
        }
    }

    static fromJS(data: any): WorkflowPeriodAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agreementId"] = this.agreementId;
        data["name"] = this.name;
        data["agreementStatus"] = this.agreementStatus;
        data["validity"] = this.validity;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["createdDateUtc"] = this.createdDateUtc ? this.createdDateUtc.toISOString() : <any>undefined;
        data["lastUpdatedBy"] = this.lastUpdatedBy ? this.lastUpdatedBy.toJSON() : <any>undefined;
        data["lastUpdateDateUtc"] = this.lastUpdateDateUtc ? this.lastUpdateDateUtc.toISOString() : <any>undefined;
        data["hasDraftVersion"] = this.hasDraftVersion;
        data["hasCurrentVersion"] = this.hasCurrentVersion;
        data["hasSignedDocumentFile"] = this.hasSignedDocumentFile;
        if (Array.isArray(this.inEditByEmployeeDtos)) {
            data["inEditByEmployeeDtos"] = [];
            for (let item of this.inEditByEmployeeDtos)
                data["inEditByEmployeeDtos"].push(item.toJSON());
        }
        data["docuSignUrl"] = this.docuSignUrl;
        data["processingPath"] = this.processingPath;
        return data;
    }
}

export interface IWorkflowPeriodAgreementDto {
    agreementId?: number;
    name?: string | undefined;
    agreementStatus?: EnvelopeStatus;
    validity?: AgreementValidityState;
    createdBy?: EmployeeDto;
    createdDateUtc?: moment.Moment;
    lastUpdatedBy?: EmployeeDto;
    lastUpdateDateUtc?: moment.Moment;
    hasDraftVersion?: boolean;
    hasCurrentVersion?: boolean;
    hasSignedDocumentFile?: boolean;
    inEditByEmployeeDtos?: EmployeeDto[] | undefined;
    docuSignUrl?: string | undefined;
    processingPath?: EnvelopeProcessingPath;
}

export class WorkflowPeriodForLegacyContractDto implements IWorkflowPeriodForLegacyContractDto {
    workflowId?: string;
    client?: LegacyClientDto;
    endClient?: LegacyClientDto;
    clientInvoicingRecipient?: LegacyClientDto;
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    isFirstPeriod?: boolean;
    isClientPeriod?: boolean;
    firstWorkflowPeriodStartDate?: moment.Moment | undefined;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    clientRateDto?: ClientRateDto;
    consultantRateDto?: ConsultantRateDto;
    noClientExtensionOption?: boolean;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientExtensionDeadlineName?: string | undefined;
    clientExtensionDurationName?: string | undefined;
    clientSpecialContractTerms?: string | undefined;
    consultantSpecialContractTerms?: string | undefined;
    clientProjectDescription?: string | undefined;
    consultantProjectDescription?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
    projectType?: ProjectTypeDto;
    employmentType?: EmploymentType;
    expectedWorkload?: ExpectedWorkload;
    workplace?: WorkplaceDto;
    salesManager?: Pm3EmployeeDto;
    invoicingReferenceContactDto?: ContactResultDto;

    constructor(data?: IWorkflowPeriodForLegacyContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.client = _data["client"] ? LegacyClientDto.fromJS(_data["client"]) : <any>undefined;
            this.endClient = _data["endClient"] ? LegacyClientDto.fromJS(_data["endClient"]) : <any>undefined;
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? LegacyClientDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.legacyConsultantId = _data["legacyConsultantId"];
            this.consultantTenantId = _data["consultantTenantId"];
            this.isFirstPeriod = _data["isFirstPeriod"];
            this.isClientPeriod = _data["isClientPeriod"];
            this.firstWorkflowPeriodStartDate = _data["firstWorkflowPeriodStartDate"] ? moment(_data["firstWorkflowPeriodStartDate"].toString()) : <any>undefined;
            this.periodStartDate = _data["periodStartDate"] ? moment(_data["periodStartDate"].toString()) : <any>undefined;
            this.periodEndDate = _data["periodEndDate"] ? moment(_data["periodEndDate"].toString()) : <any>undefined;
            this.clientRateDto = _data["clientRateDto"] ? ClientRateDto.fromJS(_data["clientRateDto"]) : <any>undefined;
            this.consultantRateDto = _data["consultantRateDto"] ? ConsultantRateDto.fromJS(_data["consultantRateDto"]) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientExtensionDeadlineName = _data["clientExtensionDeadlineName"];
            this.clientExtensionDurationName = _data["clientExtensionDurationName"];
            this.clientSpecialContractTerms = _data["clientSpecialContractTerms"];
            this.consultantSpecialContractTerms = _data["consultantSpecialContractTerms"];
            this.clientProjectDescription = _data["clientProjectDescription"];
            this.consultantProjectDescription = _data["consultantProjectDescription"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
            this.projectType = _data["projectType"] ? ProjectTypeDto.fromJS(_data["projectType"]) : <any>undefined;
            this.employmentType = _data["employmentType"] ? EmploymentType.fromJS(_data["employmentType"]) : <any>undefined;
            this.expectedWorkload = _data["expectedWorkload"] ? ExpectedWorkload.fromJS(_data["expectedWorkload"]) : <any>undefined;
            this.workplace = _data["workplace"] ? WorkplaceDto.fromJS(_data["workplace"]) : <any>undefined;
            this.salesManager = _data["salesManager"] ? Pm3EmployeeDto.fromJS(_data["salesManager"]) : <any>undefined;
            this.invoicingReferenceContactDto = _data["invoicingReferenceContactDto"] ? ContactResultDto.fromJS(_data["invoicingReferenceContactDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowPeriodForLegacyContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodForLegacyContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["endClient"] = this.endClient ? this.endClient.toJSON() : <any>undefined;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["legacyConsultantId"] = this.legacyConsultantId;
        data["consultantTenantId"] = this.consultantTenantId;
        data["isFirstPeriod"] = this.isFirstPeriod;
        data["isClientPeriod"] = this.isClientPeriod;
        data["firstWorkflowPeriodStartDate"] = this.firstWorkflowPeriodStartDate ? this.firstWorkflowPeriodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? this.periodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodEndDate"] = this.periodEndDate ? this.periodEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["clientRateDto"] = this.clientRateDto ? this.clientRateDto.toJSON() : <any>undefined;
        data["consultantRateDto"] = this.consultantRateDto ? this.consultantRateDto.toJSON() : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientExtensionDeadlineName"] = this.clientExtensionDeadlineName;
        data["clientExtensionDurationName"] = this.clientExtensionDurationName;
        data["clientSpecialContractTerms"] = this.clientSpecialContractTerms;
        data["consultantSpecialContractTerms"] = this.consultantSpecialContractTerms;
        data["clientProjectDescription"] = this.clientProjectDescription;
        data["consultantProjectDescription"] = this.consultantProjectDescription;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["employmentType"] = this.employmentType ? this.employmentType.toJSON() : <any>undefined;
        data["expectedWorkload"] = this.expectedWorkload ? this.expectedWorkload.toJSON() : <any>undefined;
        data["workplace"] = this.workplace ? this.workplace.toJSON() : <any>undefined;
        data["salesManager"] = this.salesManager ? this.salesManager.toJSON() : <any>undefined;
        data["invoicingReferenceContactDto"] = this.invoicingReferenceContactDto ? this.invoicingReferenceContactDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowPeriodForLegacyContractDto {
    workflowId?: string;
    client?: LegacyClientDto;
    endClient?: LegacyClientDto;
    clientInvoicingRecipient?: LegacyClientDto;
    legacyConsultantId?: number | undefined;
    consultantTenantId?: number | undefined;
    isFirstPeriod?: boolean;
    isClientPeriod?: boolean;
    firstWorkflowPeriodStartDate?: moment.Moment | undefined;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    clientRateDto?: ClientRateDto;
    consultantRateDto?: ConsultantRateDto;
    noClientExtensionOption?: boolean;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientExtensionDeadlineName?: string | undefined;
    clientExtensionDurationName?: string | undefined;
    clientSpecialContractTerms?: string | undefined;
    consultantSpecialContractTerms?: string | undefined;
    clientProjectDescription?: string | undefined;
    consultantProjectDescription?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
    projectType?: ProjectTypeDto;
    employmentType?: EmploymentType;
    expectedWorkload?: ExpectedWorkload;
    workplace?: WorkplaceDto;
    salesManager?: Pm3EmployeeDto;
    invoicingReferenceContactDto?: ContactResultDto;
}

export class WorkflowPeriodInfoForEvaluationDto implements IWorkflowPeriodInfoForEvaluationDto {
    projectLineId?: number;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    evaluatorLegacyContactId?: number | undefined;
    evaluatorLegacyContactTenantId?: number | undefined;
    evaluatorContactName?: string | undefined;

    constructor(data?: IWorkflowPeriodInfoForEvaluationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectLineId = _data["projectLineId"];
            this.projectName = _data["projectName"];
            this.projectDescription = _data["projectDescription"];
            this.evaluatorLegacyContactId = _data["evaluatorLegacyContactId"];
            this.evaluatorLegacyContactTenantId = _data["evaluatorLegacyContactTenantId"];
            this.evaluatorContactName = _data["evaluatorContactName"];
        }
    }

    static fromJS(data: any): WorkflowPeriodInfoForEvaluationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodInfoForEvaluationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectLineId"] = this.projectLineId;
        data["projectName"] = this.projectName;
        data["projectDescription"] = this.projectDescription;
        data["evaluatorLegacyContactId"] = this.evaluatorLegacyContactId;
        data["evaluatorLegacyContactTenantId"] = this.evaluatorLegacyContactTenantId;
        data["evaluatorContactName"] = this.evaluatorContactName;
        return data;
    }
}

export interface IWorkflowPeriodInfoForEvaluationDto {
    projectLineId?: number;
    projectName?: string | undefined;
    projectDescription?: string | undefined;
    evaluatorLegacyContactId?: number | undefined;
    evaluatorLegacyContactTenantId?: number | undefined;
    evaluatorContactName?: string | undefined;
}

export class WorkflowPeriodLegalContractStatusUpdateInputDto implements IWorkflowPeriodLegalContractStatusUpdateInputDto {
    periodId?: string;
    legalContractStatus?: LegalContractStatus;
    isInternalContract?: boolean;

    constructor(data?: IWorkflowPeriodLegalContractStatusUpdateInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodId = _data["periodId"];
            this.legalContractStatus = _data["legalContractStatus"];
            this.isInternalContract = _data["isInternalContract"];
        }
    }

    static fromJS(data: any): WorkflowPeriodLegalContractStatusUpdateInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPeriodLegalContractStatusUpdateInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodId"] = this.periodId;
        data["legalContractStatus"] = this.legalContractStatus;
        data["isInternalContract"] = this.isInternalContract;
        return data;
    }
}

export interface IWorkflowPeriodLegalContractStatusUpdateInputDto {
    periodId?: string;
    legalContractStatus?: LegalContractStatus;
    isInternalContract?: boolean;
}

export class WorkflowProcessDto implements IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    readonly name?: string | undefined;
    consultantPeriodId?: string | undefined;
    consultant?: ConsultantResultDto;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    terminationEndDate?: moment.Moment | undefined;
    steps?: StepDto[] | undefined;

    constructor(data?: IWorkflowProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.periodStartDate = _data["periodStartDate"] ? moment(_data["periodStartDate"].toString()) : <any>undefined;
            this.periodEndDate = _data["periodEndDate"] ? moment(_data["periodEndDate"].toString()) : <any>undefined;
            this.terminationEndDate = _data["terminationEndDate"] ? moment(_data["terminationEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(StepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? this.periodStartDate.format('YYYY-MM-DD') : <any>undefined;
        data["periodEndDate"] = this.periodEndDate ? this.periodEndDate.format('YYYY-MM-DD') : <any>undefined;
        data["terminationEndDate"] = this.terminationEndDate ? this.terminationEndDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    name?: string | undefined;
    consultantPeriodId?: string | undefined;
    consultant?: ConsultantResultDto;
    periodStartDate?: moment.Moment | undefined;
    periodEndDate?: moment.Moment | undefined;
    terminationEndDate?: moment.Moment | undefined;
    steps?: StepDto[] | undefined;
}

export enum WorkflowProcessType {
    StartClientPeriod = 1,
    ChangeClientPeriod = 2,
    ExtendClientPeriod = 3,
    StartConsultantPeriod = 4,
    ChangeConsultantPeriod = 5,
    ExtendConsultantPeriod = 6,
    TerminateWorkflow = 7,
    TerminateConsultant = 8,
}

export enum WorkflowStatus {
    Pending = 1,
    Active = 2,
    Finished = 3,
    PendingDataMissing = 101,
}

export class WorkflowStatusDto implements IWorkflowStatusDto {
    id?: WorkflowStatus;
    displayName?: string | undefined;
    parentId?: WorkflowStatus;

    constructor(data?: IWorkflowStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): WorkflowStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IWorkflowStatusDto {
    id?: WorkflowStatus;
    displayName?: string | undefined;
    parentId?: WorkflowStatus;
}

export class WorkflowStatusWithEmployeeDto implements IWorkflowStatusWithEmployeeDto {
    status?: WorkflowStatus;
    responsibleEmployee?: EmployeeDto;
    processType?: WorkflowProcessType;

    constructor(data?: IWorkflowStatusWithEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.responsibleEmployee = _data["responsibleEmployee"] ? EmployeeDto.fromJS(_data["responsibleEmployee"]) : <any>undefined;
            this.processType = _data["processType"];
        }
    }

    static fromJS(data: any): WorkflowStatusWithEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusWithEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["responsibleEmployee"] = this.responsibleEmployee ? this.responsibleEmployee.toJSON() : <any>undefined;
        data["processType"] = this.processType;
        return data;
    }
}

export interface IWorkflowStatusWithEmployeeDto {
    status?: WorkflowStatus;
    responsibleEmployee?: EmployeeDto;
    processType?: WorkflowProcessType;
}

export class WorkflowStepEmployeeAssignmentDto implements IWorkflowStepEmployeeAssignmentDto {
    responsibleEmployee?: WorkflowStepEmployeeAssignmentEmployeeDto;
    stepType?: StepType;

    constructor(data?: IWorkflowStepEmployeeAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responsibleEmployee = _data["responsibleEmployee"] ? WorkflowStepEmployeeAssignmentEmployeeDto.fromJS(_data["responsibleEmployee"]) : <any>undefined;
            this.stepType = _data["stepType"];
        }
    }

    static fromJS(data: any): WorkflowStepEmployeeAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStepEmployeeAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responsibleEmployee"] = this.responsibleEmployee ? this.responsibleEmployee.toJSON() : <any>undefined;
        data["stepType"] = this.stepType;
        return data;
    }
}

export interface IWorkflowStepEmployeeAssignmentDto {
    responsibleEmployee?: WorkflowStepEmployeeAssignmentEmployeeDto;
    stepType?: StepType;
}

export class WorkflowStepEmployeeAssignmentEmployeeDto implements IWorkflowStepEmployeeAssignmentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IWorkflowStepEmployeeAssignmentEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): WorkflowStepEmployeeAssignmentEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStepEmployeeAssignmentEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IWorkflowStepEmployeeAssignmentEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
    emailAddress?: string | undefined;
}

export enum WorkflowStepStatus {
    Upcoming = 1,
    Pending = 2,
    Completed = 3,
}

export class WorkflowTerminationContractDataCommandDto implements IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataCommandDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocumentsCommandDto"])) {
                this.workflowDocumentsCommandDto = [] as any;
                for (let item of _data["workflowDocumentsCommandDto"])
                    this.workflowDocumentsCommandDto!.push(WorkflowDocumentCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocumentsCommandDto)) {
            data["workflowDocumentsCommandDto"] = [];
            for (let item of this.workflowDocumentsCommandDto)
                data["workflowDocumentsCommandDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;
}

export class WorkflowTerminationContractDataQueryDto implements IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
            this.isNewSyncNeeded = _data["isNewSyncNeeded"];
            this.lastSyncedDate = _data["lastSyncedDate"] ? moment(_data["lastSyncedDate"].toString()) : <any>undefined;
            this.showManualOption = _data["showManualOption"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataQueryDto.fromJS(item));
            }
            if (Array.isArray(_data["workflowDocuments"])) {
                this.workflowDocuments = [] as any;
                for (let item of _data["workflowDocuments"])
                    this.workflowDocuments!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        data["isNewSyncNeeded"] = this.isNewSyncNeeded;
        data["lastSyncedDate"] = this.lastSyncedDate ? this.lastSyncedDate.toISOString() : <any>undefined;
        data["showManualOption"] = this.showManualOption;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowDocuments)) {
            data["workflowDocuments"] = [];
            for (let item of this.workflowDocuments)
                data["workflowDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPm?: boolean;
    isNewSyncNeeded?: boolean;
    lastSyncedDate?: moment.Moment | undefined;
    showManualOption?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;
}

export class WorkflowTerminationSalesDataCommandDto implements IWorkflowTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
            if (Array.isArray(_data["workflowDocumentsCommandDto"])) {
                this.workflowDocumentsCommandDto = [] as any;
                for (let item of _data["workflowDocumentsCommandDto"])
                    this.workflowDocumentsCommandDto!.push(WorkflowDocumentCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        if (Array.isArray(this.workflowDocumentsCommandDto)) {
            data["workflowDocumentsCommandDto"] = [];
            for (let item of this.workflowDocumentsCommandDto)
                data["workflowDocumentsCommandDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSalesDataCommandDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
    workflowDocumentsCommandDto?: WorkflowDocumentCommandDto[] | undefined;
}

export class WorkflowTerminationSalesDataQueryDto implements IWorkflowTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    directClientId?: number;
    endClientId?: number | undefined;
    finalEvaluationReferencePerson?: ContactDto;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.terminationTime = _data["terminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.directClientId = _data["directClientId"];
            this.endClientId = _data["endClientId"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
            if (Array.isArray(_data["workflowDocuments"])) {
                this.workflowDocuments = [] as any;
                for (let item of _data["workflowDocuments"])
                    this.workflowDocuments!.push(WorkflowDocumentQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terminationTime"] = this.terminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["directClientId"] = this.directClientId;
        data["endClientId"] = this.endClientId;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        if (Array.isArray(this.workflowDocuments)) {
            data["workflowDocuments"] = [];
            for (let item of this.workflowDocuments)
                data["workflowDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSalesDataQueryDto {
    terminationTime?: TerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    directClientId?: number;
    endClientId?: number | undefined;
    finalEvaluationReferencePerson?: ContactDto;
    workflowDocuments?: WorkflowDocumentQueryDto[] | undefined;
}

export class WorkflowTerminationSourcingDataCommandDto implements IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;
}

export class WorkflowTerminationSourcingDataQueryDto implements IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;
}

export class WorkflowTerminationSyncResultDto implements IWorkflowTerminationSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    workflowTerminationContractData?: WorkflowTerminationContractDataQueryDto;

    constructor(data?: IWorkflowTerminationSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractSyncResult = _data["contractSyncResult"] ? ContractSyncResultDto.fromJS(_data["contractSyncResult"]) : <any>undefined;
            this.workflowTerminationContractData = _data["workflowTerminationContractData"] ? WorkflowTerminationContractDataQueryDto.fromJS(_data["workflowTerminationContractData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowTerminationSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractSyncResult"] = this.contractSyncResult ? this.contractSyncResult.toJSON() : <any>undefined;
        data["workflowTerminationContractData"] = this.workflowTerminationContractData ? this.workflowTerminationContractData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowTerminationSyncResultDto {
    contractSyncResult?: ContractSyncResultDto;
    workflowTerminationContractData?: WorkflowTerminationContractDataQueryDto;
}

export class WorkplaceDto implements IWorkplaceDto {
    isOnsite?: boolean;
    percentageOnSite?: number | undefined;
    onSiteClientAddress?: ClientAddressDto;
    onSiteClientName?: string | undefined;
    onSiteClientId?: number | undefined;
    isRemote?: boolean;
    remoteCountryName?: string | undefined;
    isEmagineOffice?: boolean;
    emagineOffice?: EmagineOfficeDto;

    constructor(data?: IWorkplaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isOnsite = _data["isOnsite"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.onSiteClientAddress = _data["onSiteClientAddress"] ? ClientAddressDto.fromJS(_data["onSiteClientAddress"]) : <any>undefined;
            this.onSiteClientName = _data["onSiteClientName"];
            this.onSiteClientId = _data["onSiteClientId"];
            this.isRemote = _data["isRemote"];
            this.remoteCountryName = _data["remoteCountryName"];
            this.isEmagineOffice = _data["isEmagineOffice"];
            this.emagineOffice = _data["emagineOffice"] ? EmagineOfficeDto.fromJS(_data["emagineOffice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkplaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkplaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isOnsite"] = this.isOnsite;
        data["percentageOnSite"] = this.percentageOnSite;
        data["onSiteClientAddress"] = this.onSiteClientAddress ? this.onSiteClientAddress.toJSON() : <any>undefined;
        data["onSiteClientName"] = this.onSiteClientName;
        data["onSiteClientId"] = this.onSiteClientId;
        data["isRemote"] = this.isRemote;
        data["remoteCountryName"] = this.remoteCountryName;
        data["isEmagineOffice"] = this.isEmagineOffice;
        data["emagineOffice"] = this.emagineOffice ? this.emagineOffice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkplaceDto {
    isOnsite?: boolean;
    percentageOnSite?: number | undefined;
    onSiteClientAddress?: ClientAddressDto;
    onSiteClientName?: string | undefined;
    onSiteClientId?: number | undefined;
    isRemote?: boolean;
    remoteCountryName?: string | undefined;
    isEmagineOffice?: boolean;
    emagineOffice?: EmagineOfficeDto;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}