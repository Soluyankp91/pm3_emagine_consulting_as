//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param redirectUri (optional) 
     * @return Success
     */
    signIn(scheme: string, redirectUri?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignIn/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param redirectUri (optional) 
     * @param scope (optional) 
     * @param loginHint (optional) 
     * @param domainHint (optional) 
     * @param claims (optional) 
     * @param policy (optional) 
     * @return Success
     */
    challenge(scheme: string, redirectUri?: string | undefined, scope?: string | undefined, loginHint?: string | undefined, domainHint?: string | undefined, claims?: string | undefined, policy?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/Challenge/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (loginHint === null)
            throw new Error("The parameter 'loginHint' cannot be null.");
        else if (loginHint !== undefined)
            url_ += "loginHint=" + encodeURIComponent("" + loginHint) + "&";
        if (domainHint === null)
            throw new Error("The parameter 'domainHint' cannot be null.");
        else if (domainHint !== undefined)
            url_ += "domainHint=" + encodeURIComponent("" + domainHint) + "&";
        if (claims === null)
            throw new Error("The parameter 'claims' cannot be null.");
        else if (claims !== undefined)
            url_ += "claims=" + encodeURIComponent("" + claims) + "&";
        if (policy === null)
            throw new Error("The parameter 'policy' cannot be null.");
        else if (policy !== undefined)
            url_ += "policy=" + encodeURIComponent("" + policy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallenge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallenge(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChallenge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    signOut(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignOut/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    resetPassword(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/ResetPassword/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    editProfile(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/EditProfile/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientPeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesPut(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    salesGet(clientPeriodId: string): Observable<ClientPeriodSalesDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodSalesDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodSalesDataDto>;
        }));
    }

    protected processSalesGet(response: HttpResponseBase): Observable<ClientPeriodSalesDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodSalesDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodSalesDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contractsPut(clientPeriodId: string, body?: ClientPeriodContractsDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContractsPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    contractsGet(clientPeriodId: string): Observable<ClientPeriodContractsDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractsGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodContractsDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodContractsDataDto>;
        }));
    }

    protected processContractsGet(response: HttpResponseBase): Observable<ClientPeriodContractsDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodContractsDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodContractsDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    financePut(clientPeriodId: string, body?: ClientPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinancePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinancePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFinancePut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    financeGet(clientPeriodId: string): Observable<ClientPeriodFinanceDataDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/finance";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinanceGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinanceGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientPeriodFinanceDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientPeriodFinanceDataDto>;
        }));
    }

    protected processFinanceGet(response: HttpResponseBase): Observable<ClientPeriodFinanceDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPeriodFinanceDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientPeriodFinanceDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extend(clientPeriodId: string, body?: ExtendClientPeriodDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/extend";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    projectType(projectTypeId: number): Observable<ProjectTypeConfigurationDto> {
        let url_ = this.baseUrl + "/api/ClientPeriod/project-type/{projectTypeId}";
        if (projectTypeId === undefined || projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' must be defined.");
        url_ = url_.replace("{projectTypeId}", encodeURIComponent("" + projectTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectTypeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectTypeConfigurationDto>;
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<ProjectTypeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectTypeConfigurationDto>(null as any);
    }
}

@Injectable()
export class SalesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodSalesDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/sales/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    edit(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts/edit";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editFinish(clientPeriodId: string, body?: ClientPeriodContractsDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/contracts/edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class FinanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    financeEdit(clientPeriodId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/finance/finance-edit";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinanceEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinanceEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFinanceEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    financeEditFinish(clientPeriodId: string, body?: ClientPeriodFinanceDataDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ClientPeriod/{clientPeriodId}/finance/finance-edit-finish";
        if (clientPeriodId === undefined || clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' must be defined.");
        url_ = url_.replace("{clientPeriodId}", encodeURIComponent("" + clientPeriodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinanceEditFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinanceEditFinish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFinanceEditFinish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ClientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param countryFilter (optional) 
     * @param ownerFilter (optional) 
     * @param isActive (optional) 
     * @param excludeDeleted (optional) 
     * @param onlyWrongfullyDeletedInHubspot (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    list(search?: string | undefined, countryFilter?: number[] | undefined, ownerFilter?: number[] | undefined, isActive?: boolean | undefined, excludeDeleted?: boolean | undefined, onlyWrongfullyDeletedInHubspot?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/list?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (countryFilter === null)
            throw new Error("The parameter 'countryFilter' cannot be null.");
        else if (countryFilter !== undefined)
            countryFilter && countryFilter.forEach(item => { url_ += "countryFilter=" + encodeURIComponent("" + item) + "&"; });
        if (ownerFilter === null)
            throw new Error("The parameter 'ownerFilter' cannot be null.");
        else if (ownerFilter !== undefined)
            ownerFilter && ownerFilter.forEach(item => { url_ += "ownerFilter=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        if (onlyWrongfullyDeletedInHubspot === null)
            throw new Error("The parameter 'onlyWrongfullyDeletedInHubspot' cannot be null.");
        else if (onlyWrongfullyDeletedInHubspot !== undefined)
            url_ += "onlyWrongfullyDeletedInHubspot=" + encodeURIComponent("" + onlyWrongfullyDeletedInHubspot) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientListItemDtoPaginatedList>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ClientListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListItemDtoPaginatedList>(null as any);
    }

    /**
     * @param search (optional) 
     * @param projectTypeFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clientOverview(search?: string | undefined, projectTypeFilter?: string[] | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientOverviewListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/client-overview?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectTypeFilter === null)
            throw new Error("The parameter 'projectTypeFilter' cannot be null.");
        else if (projectTypeFilter !== undefined)
            projectTypeFilter && projectTypeFilter.forEach(item => { url_ += "projectTypeFilter=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientOverviewListItemDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientOverviewListItemDtoPaginatedList>;
        }));
    }

    protected processClientOverview(response: HttpResponseBase): Observable<ClientOverviewListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientOverviewListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientOverviewListItemDtoPaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    specialRatesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialRateDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialRateDto[]>;
        }));
    }

    protected processSpecialRatesGet(response: HttpResponseBase): Observable<ClientSpecialRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialRateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialRateDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPost(clientId: number, body?: AddClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialRatesPut(clientId: number, body?: UpdateClientSpecialRateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialRatesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialRatesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialRatesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    specialFeesGet(clientId: number, showHidden: boolean): Observable<ClientSpecialFeeDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{showHidden}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (showHidden === undefined || showHidden === null)
            throw new Error("The parameter 'showHidden' must be defined.");
        url_ = url_.replace("{showHidden}", encodeURIComponent("" + showHidden));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientSpecialFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientSpecialFeeDto[]>;
        }));
    }

    protected processSpecialFeesGet(response: HttpResponseBase): Observable<ClientSpecialFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientSpecialFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientSpecialFeeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPost(clientId: number, body?: AddClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    specialFeesPut(clientId: number, body?: UpdateClientSpecialFeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecialFeesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecialFeesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSpecialFeesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    requestTrack(clientId: number, pageNumber?: number | undefined, pageSize?: number | undefined, sort?: string | undefined): Observable<ClientRequestTrackDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/request-track?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTrack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientRequestTrackDtoPaginatedList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientRequestTrackDtoPaginatedList>;
        }));
    }

    protected processRequestTrack(response: HttpResponseBase): Observable<ClientRequestTrackDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRequestTrackDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRequestTrackDtoPaginatedList>(null as any);
    }

    /**
     * @param excludeDeleted (optional) 
     * @return Success
     */
    contacts(clientId: number, excludeDeleted?: boolean | undefined): Observable<ContactDto[]> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/contacts?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (excludeDeleted === null)
            throw new Error("The parameter 'excludeDeleted' cannot be null.");
        else if (excludeDeleted !== undefined)
            url_ += "excludeDeleted=" + encodeURIComponent("" + excludeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDto[]>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrl(clientId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrl";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    camImpersonationUrlEditContactLogin(clientId: number, contactId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/CamImpersonationUrlEditContactLogin/{contactId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamImpersonationUrlEditContactLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamImpersonationUrlEditContactLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamImpersonationUrlEditContactLogin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clients(clientId: number): Observable<ClientDetailsDto> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDetailsDto>;
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailsDto>(null as any);
    }
}

@Injectable()
export class SpecialRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    delete(clientId: number, clientSpecialRateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-rates/{clientSpecialRateId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialRateId === undefined || clientSpecialRateId === null)
            throw new Error("The parameter 'clientSpecialRateId' must be defined.");
        url_ = url_.replace("{clientSpecialRateId}", encodeURIComponent("" + clientSpecialRateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class SpecialFeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    delete(clientId: number, clientSpecialFeeId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/special-fees/{clientSpecialFeeId}/delete";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (clientSpecialFeeId === undefined || clientSpecialFeeId === null)
            throw new Error("The parameter 'clientSpecialFeeId' must be defined.");
        url_ = url_.replace("{clientSpecialFeeId}", encodeURIComponent("" + clientSpecialFeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EmployeeNotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    enabledNotifications(): Observable<EmployeeNotificationDto[]> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/enabled-notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnabledNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnabledNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeNotificationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeNotificationDto[]>;
        }));
    }

    protected processEnabledNotifications(response: HttpResponseBase): Observable<EmployeeNotificationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeNotificationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeNotificationDto[]>(null as any);
    }

    /**
     * @param notification (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    addNotification(notification?: Notification | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/add-notification?";
        if (notification === null)
            throw new Error("The parameter 'notification' cannot be null.");
        else if (notification !== undefined)
            url_ += "notification=" + encodeURIComponent("" + notification) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param notification (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeNotification(notification?: Notification | undefined, tenantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/EmployeeNotification/remove-notification?";
        if (notification === null)
            throw new Error("The parameter 'notification' cannot be null.");
        else if (notification !== undefined)
            url_ += "notification=" + encodeURIComponent("" + notification) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    countries(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    currencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCurrencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tenants(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/tenants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processTenants(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    deliveryTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/delivery-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeliveryTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeliveryTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDeliveryTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoiceFrequencies(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoice-frequencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoiceFrequencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoiceFrequencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoiceFrequencies(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    invoicingTimes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/invoicing-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoicingTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoicingTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processInvoicingTimes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    rateUnitTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/rate-unit-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateUnitTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRateUnitTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    salesTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/sales-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSalesTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    signerRoles(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/signer-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignerRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignerRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processSignerRoles(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    margins(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/margins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMargins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMargins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processMargins(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateReportingUnits(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-reporting-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateReportingUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateReportingUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateReportingUnits(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialRateOrFeeDirections(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-rate-or-fee-directions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialRateOrFeeDirections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialRateOrFeeDirections(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialRateOrFeeDirections(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeSpecifiedAs(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-specified-as";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeSpecifiedAs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeSpecifiedAs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeSpecifiedAs(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientSpecialFeeFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-special-fee-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSpecialFeeFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSpecialFeeFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientSpecialFeeFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDuration(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-duration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDuration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDuration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDuration(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientExtensionDeadline(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-extension-deadline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientExtensionDeadline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientExtensionDeadline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientExtensionDeadline(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    clientTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/client-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processClientTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantTimeReportingCap(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-time-reporting-cap";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantTimeReportingCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantTimeReportingCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantTimeReportingCap(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    consultantPeriodType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/consultant-period-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantPeriodType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantPeriodType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processConsultantPeriodType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    stepTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/step-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStepTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStepTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processStepTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    workflowProcessTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/workflow-process-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowProcessTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowProcessTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processWorkflowProcessTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    terminationReasons(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/termination-reasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTerminationReasons(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    nonStandardTerminationTimes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/non-standard-termination-times";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNonStandardTerminationTimes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNonStandardTerminationTimes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processNonStandardTerminationTimes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    emagineOffice(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/emagine-office";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmagineOffice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmagineOffice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmagineOffice(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    contractExpirationNotificationInterval(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/contract-expiration-notification-interval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContractExpirationNotificationInterval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContractExpirationNotificationInterval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processContractExpirationNotificationInterval(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    commissionFrequency(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionFrequency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionFrequency(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    commissionTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/commission-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommissionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommissionTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processCommissionTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    recipientTypes(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/recipient-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecipientTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecipientTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processRecipientTypes(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    projectCategory(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processProjectCategory(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    employmentType(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/employment-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmploymentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmploymentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processEmploymentType(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    discount(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/discount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processDiscount(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    expectedWorkloadUnit(): Observable<EnumEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/expected-workload-unit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpectedWorkloadUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpectedWorkloadUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EnumEntityTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EnumEntityTypeDto[]>;
        }));
    }

    protected processExpectedWorkloadUnit(response: HttpResponseBase): Observable<EnumEntityTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumEntityTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumEntityTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    notification(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/notification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processNotification(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }

    /**
     * @return Success
     */
    consultantInsuranceOption(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Enum/consultant-insurance-option";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantInsuranceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantInsuranceOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processConsultantInsuranceOption(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(null as any);
    }
}

@Injectable()
export class HubSpotCardDataFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    workflows(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Workflows?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processWorkflows(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param associatedcompanyid (optional) 
     * @return Success
     */
    requests(hs_object_id?: string | undefined, associatedcompanyid?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/Requests?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (associatedcompanyid === null)
            throw new Error("The parameter 'associatedcompanyid' cannot be null.");
        else if (associatedcompanyid !== undefined)
            url_ += "associatedcompanyid=" + encodeURIComponent("" + associatedcompanyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequests(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    contactPerson(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/ContactPerson?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processContactPerson(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param hs_object_id (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    camLoginLink(hs_object_id?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotCardDataFetch/CamLoginLink?";
        if (hs_object_id === null)
            throw new Error("The parameter 'hs_object_id' cannot be null.");
        else if (hs_object_id !== undefined)
            url_ += "hs_object_id=" + encodeURIComponent("" + hs_object_id) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCamLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCamLoginLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCamLoginLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotContractFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    listContracts(userId?: string | undefined, userEmail?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotContractFetch/ListContracts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListContracts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processListContracts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotInstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    auth(code?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/auth?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class HubSpotSyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    syncAllWithHubSpot(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncAllWithHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllWithHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllWithHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncAllWithHubSpot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactMerges(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactMerges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactMerges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactMerges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactMerges(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectCompanyRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectCompanyRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectCompanyRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectCompanyRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectCompanyRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    detectContactRestoreAndHardDelete(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/DetectContactRestoreAndHardDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetectContactRestoreAndHardDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetectContactRestoreAndHardDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDetectContactRestoreAndHardDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    syncClientParents(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotSync/SyncClientParents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncClientParents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncClientParents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSyncClientParents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class HubSpotTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testCreateClientInHubSpot(): Observable<SimplePublicObject> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestCreateClientInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCreateClientInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCreateClientInHubSpot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimplePublicObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimplePublicObject>;
        }));
    }

    protected processTestCreateClientInHubSpot(response: HttpResponseBase): Observable<SimplePublicObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimplePublicObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePublicObject>(null as any);
    }

    /**
     * @return Success
     */
    testSyncUpdateToLegacy(): Observable<void> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestSyncUpdateToLegacy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSyncUpdateToLegacy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSyncUpdateToLegacy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestSyncUpdateToLegacy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class LookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param nameFilter (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    employees(nameFilter?: string | undefined, idsToExclude?: number[] | undefined): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Employees?";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "nameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto[]>;
        }));
    }

    protected processEmployees(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    consultants(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<ConsultantResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Consultants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantResultDto[]>;
        }));
    }

    protected processConsultants(response: HttpResponseBase): Observable<ConsultantResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsultantResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @param idsToExclude (optional) 
     * @return Success
     */
    suppliers(filter?: string | undefined, maxRecords?: number | undefined, idsToExclude?: number[] | undefined): Observable<SupplierResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Suppliers?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        if (idsToExclude === null)
            throw new Error("The parameter 'idsToExclude' cannot be null.");
        else if (idsToExclude !== undefined)
            idsToExclude && idsToExclude.forEach(item => { url_ += "idsToExclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuppliers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SupplierResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SupplierResultDto[]>;
        }));
    }

    protected processSuppliers(response: HttpResponseBase): Observable<SupplierResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierResultDto[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    clients(filter?: string | undefined, maxRecords?: number | undefined): Observable<ClientResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Clients?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientResultDto[]>;
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientResultDto[]>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param filter (optional) 
     * @param maxRecords (optional) 
     * @return Success
     */
    contacts(clientId?: number | undefined, filter?: string | undefined, maxRecords?: number | undefined): Observable<ContactResultDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/Contacts?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxRecords === null)
            throw new Error("The parameter 'maxRecords' cannot be null.");
        else if (maxRecords !== undefined)
            url_ += "maxRecords=" + encodeURIComponent("" + maxRecords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactResultDto[]>;
        }));
    }

    protected processContacts(response: HttpResponseBase): Observable<ContactResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactResultDto[]>(null as any);
    }
}

@Injectable()
export class NotificationTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    send(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     * @deprecated
     */
    sendContractExpiration(email?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/NotificationTest/send-contract-expiration?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendContractExpiration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendContractExpiration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendContractExpiration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(body?: StartNewWorkflowInputDto | undefined): Observable<NewWorkflowCreatedDto> {
        let url_ = this.baseUrl + "/api/Workflow/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewWorkflowCreatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewWorkflowCreatedDto>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<NewWorkflowCreatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewWorkflowCreatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewWorkflowCreatedDto>(null as any);
    }

    /**
     * @return Success
     */
    workflowExists(requestConsultantId: number): Observable<WorkflowAlreadyExistsDto> {
        let url_ = this.baseUrl + "/api/Workflow/{requestConsultantId}/workflow-exists";
        if (requestConsultantId === undefined || requestConsultantId === null)
            throw new Error("The parameter 'requestConsultantId' must be defined.");
        url_ = url_.replace("{requestConsultantId}", encodeURIComponent("" + requestConsultantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWorkflowExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWorkflowExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowAlreadyExistsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowAlreadyExistsDto>;
        }));
    }

    protected processWorkflowExists(response: HttpResponseBase): Observable<WorkflowAlreadyExistsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowAlreadyExistsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowAlreadyExistsDto>(null as any);
    }

    /**
     * @param clientPeriodId (optional) 
     * @param includeProcesses (optional) 
     * @return Success
     */
    clientPeriods(workflowId: string, clientPeriodId?: string | undefined, includeProcesses?: boolean | undefined): Observable<WorkflowDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/clientPeriods?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (clientPeriodId === null)
            throw new Error("The parameter 'clientPeriodId' cannot be null.");
        else if (clientPeriodId !== undefined)
            url_ += "clientPeriodId=" + encodeURIComponent("" + clientPeriodId) + "&";
        if (includeProcesses === null)
            throw new Error("The parameter 'includeProcesses' cannot be null.");
        else if (includeProcesses !== undefined)
            url_ += "includeProcesses=" + encodeURIComponent("" + includeProcesses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientPeriods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientPeriods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowDto>;
        }));
    }

    protected processClientPeriods(response: HttpResponseBase): Observable<WorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowDto>(null as any);
    }

    /**
     * @return Success
     */
    terminationStart(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-start";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSalesGet(workflowId: string): Observable<WorkflowTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationSalesGet(response: HttpResponseBase): Observable<WorkflowTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesPut(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSalesComplete(workflowId: string, body?: WorkflowTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sales-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractGet(workflowId: string): Observable<WorkflowTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationContractGet(response: HttpResponseBase): Observable<WorkflowTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractPut(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationContractStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationContractComplete(workflowId: string, body?: WorkflowTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingGet(workflowId: string): Observable<WorkflowTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WorkflowTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationSourcingGet(response: HttpResponseBase): Observable<WorkflowTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingPut(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationSourcingStartEdit(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-start-edit";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationSourcingComplete(workflowId: string, body?: WorkflowTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    terminationDelete(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantStart(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-start?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSalesGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSalesDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSalesDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSalesGet(response: HttpResponseBase): Observable<ConsultantTerminationSalesDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSalesDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSalesDataQueryDto>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesPut(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSalesComplete(workflowId: string, consultantId?: number | undefined, body?: ConsultantTerminationSalesDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sales-complete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSalesComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSalesComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSalesComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationContractDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationContractDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationContractDataQueryDto>;
        }));
    }

    protected processTerminationConsultantContractGet(response: HttpResponseBase): Observable<ConsultantTerminationContractDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationContractDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationContractDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractPut(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantContractStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantContractComplete(workflowId: string, body?: ConsultantTerminationContractDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-contract-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantContractComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantContractComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantContractComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingGet(workflowId: string, consultantId?: number | undefined): Observable<ConsultantTerminationSourcingDataQueryDto> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsultantTerminationSourcingDataQueryDto>;
        }));
    }

    protected processTerminationConsultantSourcingGet(response: HttpResponseBase): Observable<ConsultantTerminationSourcingDataQueryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsultantTerminationSourcingDataQueryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsultantTerminationSourcingDataQueryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingPut(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantSourcingStartEdit(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-start-edit?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingStartEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingStartEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingStartEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    terminationConsultantSourcingComplete(workflowId: string, body?: ConsultantTerminationSourcingDataCommandDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-sourcing-complete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantSourcingComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantSourcingComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantSourcingComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param consultantId (optional) 
     * @return Success
     */
    terminationConsultantDelete(workflowId: string, consultantId?: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/termination-consultant-delete?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (consultantId === null)
            throw new Error("The parameter 'consultantId' cannot be null.");
        else if (consultantId !== undefined)
            url_ += "consultantId=" + encodeURIComponent("" + consultantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTerminationConsultantDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTerminationConsultantDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTerminationConsultantDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    delete(workflowId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Workflow/{workflowId}/delete";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class ActionPermissionDto implements IActionPermissionDto {
    isAllowed?: boolean;
    error?: string | undefined;

    constructor(data?: IActionPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAllowed = _data["isAllowed"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ActionPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAllowed"] = this.isAllowed;
        data["error"] = this.error;
        return data;
    }
}

export interface IActionPermissionDto {
    isAllowed?: boolean;
    error?: string | undefined;
}

export class AddClientSpecialFeeDto implements IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class AddClientSpecialRateDto implements IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;

    constructor(data?: IAddClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.specialRateCategoryId = _data["specialRateCategoryId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): AddClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["specialRateCategoryId"] = this.specialRateCategoryId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IAddClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
}

export class ClientDetailsDto implements IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IClientDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ClientDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IClientDetailsDto {
    clientId?: number;
    name?: string | undefined;
    tenantId?: number;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export class ClientListItemDto implements IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    readonly isDeleted?: boolean;
    readonly isWrongfullyDeletedInHubspot?: boolean;
    readonly isActive?: boolean;

    constructor(data?: IClientListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crmClientId = _data["crmClientId"];
            this.legacyClientId = _data["legacyClientId"];
            this.name = _data["name"];
            this.clientAddress_Address = _data["clientAddress_Address"];
            this.clientAddress_Address2 = _data["clientAddress_Address2"];
            this.clientAddress_PostCode = _data["clientAddress_PostCode"];
            this.clientAddress_City = _data["clientAddress_City"];
            this.clientAddress_Country_Id = _data["clientAddress_Country_Id"];
            this.clientAddress_Country_Name = _data["clientAddress_Country_Name"];
            this.clientAddress_Country_Code = _data["clientAddress_Country_Code"];
            this.phone = _data["phone"];
            this.owner_Id = _data["owner_Id"];
            this.owner_Name = _data["owner_Name"];
            this.tenant_Id = _data["tenant_Id"];
            (<any>this).isDeleted = _data["isDeleted"];
            (<any>this).isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            (<any>this).isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ClientListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crmClientId"] = this.crmClientId;
        data["legacyClientId"] = this.legacyClientId;
        data["name"] = this.name;
        data["clientAddress_Address"] = this.clientAddress_Address;
        data["clientAddress_Address2"] = this.clientAddress_Address2;
        data["clientAddress_PostCode"] = this.clientAddress_PostCode;
        data["clientAddress_City"] = this.clientAddress_City;
        data["clientAddress_Country_Id"] = this.clientAddress_Country_Id;
        data["clientAddress_Country_Name"] = this.clientAddress_Country_Name;
        data["clientAddress_Country_Code"] = this.clientAddress_Country_Code;
        data["phone"] = this.phone;
        data["owner_Id"] = this.owner_Id;
        data["owner_Name"] = this.owner_Name;
        data["tenant_Id"] = this.tenant_Id;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IClientListItemDto {
    id?: number;
    crmClientId?: number | undefined;
    legacyClientId?: number | undefined;
    name?: string | undefined;
    clientAddress_Address?: string | undefined;
    clientAddress_Address2?: string | undefined;
    clientAddress_PostCode?: string | undefined;
    clientAddress_City?: string | undefined;
    clientAddress_Country_Id?: number | undefined;
    clientAddress_Country_Name?: string | undefined;
    clientAddress_Country_Code?: string | undefined;
    phone?: string | undefined;
    owner_Id?: number | undefined;
    owner_Name?: string | undefined;
    tenant_Id?: number;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    isActive?: boolean;
}

export class ClientListItemDtoPaginatedList implements IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientListItemDtoPaginatedList {
    items?: ClientListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientOverviewListItemDto implements IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;

    constructor(data?: IClientOverviewListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.clientName = _data["clientName"];
            this.consultantName = _data["consultantName"];
            this.note = _data["note"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.contractsCount = _data["contractsCount"];
            this.contractsPendingCount = _data["contractsPendingCount"];
            this.contractsExtensionsOkCount = _data["contractsExtensionsOkCount"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["clientName"] = this.clientName;
        data["consultantName"] = this.consultantName;
        data["note"] = this.note;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["contractsCount"] = this.contractsCount;
        data["contractsPendingCount"] = this.contractsPendingCount;
        data["contractsExtensionsOkCount"] = this.contractsExtensionsOkCount;
        return data;
    }
}

export interface IClientOverviewListItemDto {
    consultantId?: number;
    clientName?: string | undefined;
    consultantName?: string | undefined;
    note?: string | undefined;
    endDate?: moment.Moment;
    contractsCount?: number;
    contractsPendingCount?: number;
    contractsExtensionsOkCount?: number;
}

export class ClientOverviewListItemDtoPaginatedList implements IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientOverviewListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientOverviewListItemDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientOverviewListItemDtoPaginatedList {
    items?: ClientOverviewListItemDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientPeriodContractsDataDto implements IClientPeriodContractsDataDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    consultantData?: ConsultantContractsDataDto[] | undefined;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;

    constructor(data?: IClientPeriodContractsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainData = _data["mainData"] ? ContractsMainDataDto.fromJS(_data["mainData"]) : <any>undefined;
            this.clientData = _data["clientData"] ? ContractsClientDataDto.fromJS(_data["clientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantData"])) {
                this.consultantData = [] as any;
                for (let item of _data["consultantData"])
                    this.consultantData!.push(ConsultantContractsDataDto.fromJS(item));
            }
            this.contractLinesDoneManuallyInOldPm = _data["contractLinesDoneManuallyInOldPm"];
        }
    }

    static fromJS(data: any): ClientPeriodContractsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodContractsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainData"] = this.mainData ? this.mainData.toJSON() : <any>undefined;
        data["clientData"] = this.clientData ? this.clientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantData)) {
            data["consultantData"] = [];
            for (let item of this.consultantData)
                data["consultantData"].push(item.toJSON());
        }
        data["contractLinesDoneManuallyInOldPm"] = this.contractLinesDoneManuallyInOldPm;
        return data;
    }
}

export interface IClientPeriodContractsDataDto {
    mainData?: ContractsMainDataDto;
    clientData?: ContractsClientDataDto;
    consultantData?: ConsultantContractsDataDto[] | undefined;
    contractLinesDoneManuallyInOldPm?: boolean | undefined;
}

export class ClientPeriodDto implements IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    additionalInfo?: string | undefined;
    isCompleted?: boolean;
    workflowProcesses?: WorkflowProcessDto[] | undefined;

    constructor(data?: IClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.additionalInfo = _data["additionalInfo"];
            this.isCompleted = _data["isCompleted"];
            if (Array.isArray(_data["workflowProcesses"])) {
                this.workflowProcesses = [] as any;
                for (let item of _data["workflowProcesses"])
                    this.workflowProcesses!.push(WorkflowProcessDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["additionalInfo"] = this.additionalInfo;
        data["isCompleted"] = this.isCompleted;
        if (Array.isArray(this.workflowProcesses)) {
            data["workflowProcesses"] = [];
            for (let item of this.workflowProcesses)
                data["workflowProcesses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodDto {
    id?: string;
    name?: string | undefined;
    typeId?: number;
    additionalInfo?: string | undefined;
    isCompleted?: boolean;
    workflowProcesses?: WorkflowProcessDto[] | undefined;
}

export class ClientPeriodFinanceDataDto implements IClientPeriodFinanceDataDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;

    constructor(data?: IClientPeriodFinanceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtorCreatedInNavision = _data["debtorCreatedInNavision"];
            this.differentDebtorNumberForInvoicing = _data["differentDebtorNumberForInvoicing"];
            this.customDebtorNumber = _data["customDebtorNumber"];
            if (Array.isArray(_data["consultantFinanceData"])) {
                this.consultantFinanceData = [] as any;
                for (let item of _data["consultantFinanceData"])
                    this.consultantFinanceData!.push(ConsultantPeriodFinanceDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientPeriodFinanceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodFinanceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtorCreatedInNavision"] = this.debtorCreatedInNavision;
        data["differentDebtorNumberForInvoicing"] = this.differentDebtorNumberForInvoicing;
        data["customDebtorNumber"] = this.customDebtorNumber;
        if (Array.isArray(this.consultantFinanceData)) {
            data["consultantFinanceData"] = [];
            for (let item of this.consultantFinanceData)
                data["consultantFinanceData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientPeriodFinanceDataDto {
    debtorCreatedInNavision?: boolean;
    differentDebtorNumberForInvoicing?: boolean;
    customDebtorNumber?: string | undefined;
    consultantFinanceData?: ConsultantPeriodFinanceDataDto[] | undefined;
}

export class ClientPeriodSalesDataDto implements IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;

    constructor(data?: IClientPeriodSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesMainData = _data["salesMainData"] ? SalesMainDataDto.fromJS(_data["salesMainData"]) : <any>undefined;
            this.salesClientData = _data["salesClientData"] ? SalesClientDataDto.fromJS(_data["salesClientData"]) : <any>undefined;
            if (Array.isArray(_data["consultantSalesData"])) {
                this.consultantSalesData = [] as any;
                for (let item of _data["consultantSalesData"])
                    this.consultantSalesData!.push(ConsultantSalesDataDto.fromJS(item));
            }
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientPeriodSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPeriodSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesMainData"] = this.salesMainData ? this.salesMainData.toJSON() : <any>undefined;
        data["salesClientData"] = this.salesClientData ? this.salesClientData.toJSON() : <any>undefined;
        if (Array.isArray(this.consultantSalesData)) {
            data["consultantSalesData"] = [];
            for (let item of this.consultantSalesData)
                data["consultantSalesData"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        return data;
    }
}

export interface IClientPeriodSalesDataDto {
    salesMainData?: SalesMainDataDto;
    salesClientData?: SalesClientDataDto;
    consultantSalesData?: ConsultantSalesDataDto[] | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
}

export class ClientRateDto implements IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IClientRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.invoiceCurrencyId = _data["invoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ClientRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["invoiceCurrencyId"] = this.invoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IClientRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    invoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ClientRequestTrackDto implements IClientRequestTrackDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;

    constructor(data?: IClientRequestTrackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.headline = _data["headline"];
            this.status = _data["status"] ? RequestStatusValueValueNameDto.fromJS(_data["status"]) : <any>undefined;
            this.clientDeadline = _data["clientDeadline"] ? moment(_data["clientDeadline"].toString()) : <any>undefined;
            this.dateAdded = _data["dateAdded"] ? moment(_data["dateAdded"].toString()) : <any>undefined;
            this.projectType = _data["projectType"] ? RequestProjectTypeValueValueNameDto.fromJS(_data["projectType"]) : <any>undefined;
            this.priority = _data["priority"];
            this.numberOfConsultants = _data["numberOfConsultants"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(SimpleRequestLocationDto.fromJS(item));
            }
            if (Array.isArray(_data["requestSourcers"])) {
                this.requestSourcers = [] as any;
                for (let item of _data["requestSourcers"])
                    this.requestSourcers!.push(EmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["accountManagers"])) {
                this.accountManagers = [] as any;
                for (let item of _data["accountManagers"])
                    this.accountManagers!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRequestTrackDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["headline"] = this.headline;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["clientDeadline"] = this.clientDeadline ? this.clientDeadline.toISOString() : <any>undefined;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["priority"] = this.priority;
        data["numberOfConsultants"] = this.numberOfConsultants;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.requestSourcers)) {
            data["requestSourcers"] = [];
            for (let item of this.requestSourcers)
                data["requestSourcers"].push(item.toJSON());
        }
        if (Array.isArray(this.accountManagers)) {
            data["accountManagers"] = [];
            for (let item of this.accountManagers)
                data["accountManagers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientRequestTrackDto {
    requestId?: number;
    headline?: string | undefined;
    status?: RequestStatusValueValueNameDto;
    clientDeadline?: moment.Moment | undefined;
    dateAdded?: moment.Moment;
    projectType?: RequestProjectTypeValueValueNameDto;
    priority?: number;
    numberOfConsultants?: number;
    locations?: SimpleRequestLocationDto[] | undefined;
    requestSourcers?: EmployeeDto[] | undefined;
    accountManagers?: EmployeeDto[] | undefined;
}

export class ClientRequestTrackDtoPaginatedList implements IClientRequestTrackDtoPaginatedList {
    items?: ClientRequestTrackDto[] | undefined;
    pageIndex?: number;
    readonly totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IClientRequestTrackDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientRequestTrackDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientRequestTrackDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IClientRequestTrackDtoPaginatedList {
    items?: ClientRequestTrackDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClientResultDto implements IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;

    constructor(data?: IClientResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.address = _data["address"];
            this.address2 = _data["address2"];
            this.postCode = _data["postCode"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): ClientResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["address"] = this.address;
        data["address2"] = this.address2;
        data["postCode"] = this.postCode;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IClientResultDto {
    clientId?: number;
    clientName?: string | undefined;
    address?: string | undefined;
    address2?: string | undefined;
    postCode?: string | undefined;
    city?: string | undefined;
    countryId?: number | undefined;
    countryName?: string | undefined;
}

export class ClientSpecialFeeDto implements IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirection = _data["specialRateOrFeeDirection"] ? EnumEntityTypeDto.fromJS(_data["specialRateOrFeeDirection"]) : <any>undefined;
            this.clientSpecialFeeFrequency = _data["clientSpecialFeeFrequency"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeFrequency"]) : <any>undefined;
            this.clientSpecialFeeSpecifiedAs = _data["clientSpecialFeeSpecifiedAs"] ? EnumEntityTypeDto.fromJS(_data["clientSpecialFeeSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrency = _data["prodataToProdataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["prodataToProdataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirection"] = this.specialRateOrFeeDirection ? this.specialRateOrFeeDirection.toJSON() : <any>undefined;
        data["clientSpecialFeeFrequency"] = this.clientSpecialFeeFrequency ? this.clientSpecialFeeFrequency.toJSON() : <any>undefined;
        data["clientSpecialFeeSpecifiedAs"] = this.clientSpecialFeeSpecifiedAs ? this.clientSpecialFeeSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrency"] = this.prodataToProdataRateCurrency ? this.prodataToProdataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialFeeDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    clientSpecialFeeFrequency?: EnumEntityTypeDto;
    clientSpecialFeeSpecifiedAs?: EnumEntityTypeDto;
    clientRate?: number;
    clientRateCurrency?: EnumEntityTypeDto;
    prodataToProdataRate?: number;
    prodataToProdataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number;
    consultantCurrency?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class ClientSpecialRateDto implements IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    specialRateCategory?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;

    constructor(data?: IClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirection = _data["specialRateOrFeeDirection"] ? EnumEntityTypeDto.fromJS(_data["specialRateOrFeeDirection"]) : <any>undefined;
            this.specialRateReportingUnit = _data["specialRateReportingUnit"] ? SpecialRateReportingUnit.fromJS(_data["specialRateReportingUnit"]) : <any>undefined;
            this.specialRateSpecifiedAs = _data["specialRateSpecifiedAs"] ? SpecialRateSpecifiedAs.fromJS(_data["specialRateSpecifiedAs"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrency = _data["clientRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["clientRateCurrency"]) : <any>undefined;
            this.proDataToProDataRate = _data["proDataToProDataRate"];
            this.proDataToProDataRateCurrency = _data["proDataToProDataRateCurrency"] ? EnumEntityTypeDto.fromJS(_data["proDataToProDataRateCurrency"]) : <any>undefined;
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrency = _data["consultantCurrency"] ? EnumEntityTypeDto.fromJS(_data["consultantCurrency"]) : <any>undefined;
            this.specialRateCategory = _data["specialRateCategory"] ? EnumEntityTypeDto.fromJS(_data["specialRateCategory"]) : <any>undefined;
            this.inUse = _data["inUse"];
            this.isHidden = _data["isHidden"];
        }
    }

    static fromJS(data: any): ClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirection"] = this.specialRateOrFeeDirection ? this.specialRateOrFeeDirection.toJSON() : <any>undefined;
        data["specialRateReportingUnit"] = this.specialRateReportingUnit ? this.specialRateReportingUnit.toJSON() : <any>undefined;
        data["specialRateSpecifiedAs"] = this.specialRateSpecifiedAs ? this.specialRateSpecifiedAs.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrency"] = this.clientRateCurrency ? this.clientRateCurrency.toJSON() : <any>undefined;
        data["proDataToProDataRate"] = this.proDataToProDataRate;
        data["proDataToProDataRateCurrency"] = this.proDataToProDataRateCurrency ? this.proDataToProDataRateCurrency.toJSON() : <any>undefined;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrency"] = this.consultantCurrency ? this.consultantCurrency.toJSON() : <any>undefined;
        data["specialRateCategory"] = this.specialRateCategory ? this.specialRateCategory.toJSON() : <any>undefined;
        data["inUse"] = this.inUse;
        data["isHidden"] = this.isHidden;
        return data;
    }
}

export interface IClientSpecialRateDto {
    id?: number;
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirection?: EnumEntityTypeDto;
    specialRateReportingUnit?: SpecialRateReportingUnit;
    specialRateSpecifiedAs?: SpecialRateSpecifiedAs;
    clientRate?: number | undefined;
    clientRateCurrency?: EnumEntityTypeDto;
    proDataToProDataRate?: number | undefined;
    proDataToProDataRateCurrency?: EnumEntityTypeDto;
    consultantRate?: number | undefined;
    consultantCurrency?: EnumEntityTypeDto;
    specialRateCategory?: EnumEntityTypeDto;
    inUse?: boolean;
    isHidden?: boolean;
}

export class CommissionDto implements ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;

    constructor(data?: ICommissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionTypeId = _data["commissionTypeId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.commissionFrequencyId = _data["commissionFrequencyId"];
            this.oneTimeDate = _data["oneTimeDate"] ? moment(_data["oneTimeDate"].toString()) : <any>undefined;
            this.recipientTypeId = _data["recipientTypeId"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierResultDto.fromJS(_data["supplier"]) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientResultDto.fromJS(_data["client"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionTypeId"] = this.commissionTypeId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["commissionFrequencyId"] = this.commissionFrequencyId;
        data["oneTimeDate"] = this.oneTimeDate ? this.oneTimeDate.format('YYYY-MM-DD') : <any>undefined;
        data["recipientTypeId"] = this.recipientTypeId;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionDto {
    id?: number | undefined;
    commissionTypeId?: number;
    amount?: number;
    currencyId?: number;
    commissionFrequencyId?: number;
    oneTimeDate?: moment.Moment | undefined;
    recipientTypeId?: number;
    supplierId?: number | undefined;
    supplier?: SupplierResultDto;
    tenantId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    clientId?: number | undefined;
    client?: ClientResultDto;
}

export class ConsultantContractsDataDto implements IConsultantContractsDataDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;

    constructor(data?: IConsultantContractsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantPeriodId = _data["consultantPeriodId"];
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.consultantTimeReportingCapCurrencyId = _data["consultantTimeReportingCapCurrencyId"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            if (Array.isArray(_data["projectLines"])) {
                this.projectLines = [] as any;
                for (let item of _data["projectLines"])
                    this.projectLines!.push(ProjectLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsultantContractsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantContractsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantPeriodId"] = this.consultantPeriodId;
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["consultantTimeReportingCapCurrencyId"] = this.consultantTimeReportingCapCurrencyId;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        if (Array.isArray(this.projectLines)) {
            data["projectLines"] = [];
            for (let item of this.projectLines)
                data["projectLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConsultantContractsDataDto {
    consultantPeriodId?: string;
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    consultantTimeReportingCapCurrencyId?: number | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    projectLines?: ProjectLineDto[] | undefined;
}

export class ConsultantPeriodFinanceDataDto implements IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;

    constructor(data?: IConsultantPeriodFinanceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.checkInvoicingSettingsOnConsultant = _data["checkInvoicingSettingsOnConsultant"];
            this.creditorCreatedInNavision = _data["creditorCreatedInNavision"];
        }
    }

    static fromJS(data: any): ConsultantPeriodFinanceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantPeriodFinanceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["checkInvoicingSettingsOnConsultant"] = this.checkInvoicingSettingsOnConsultant;
        data["creditorCreatedInNavision"] = this.creditorCreatedInNavision;
        return data;
    }
}

export interface IConsultantPeriodFinanceDataDto {
    consultantId?: number;
    consultant?: ConsultantResultDto;
    checkInvoicingSettingsOnConsultant?: boolean;
    creditorCreatedInNavision?: boolean;
}

export class ConsultantRateDto implements IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;

    constructor(data?: IConsultantRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isTimeBasedRate = _data["isTimeBasedRate"];
            this.isFixedRate = _data["isFixedRate"];
            this.normalRate = _data["normalRate"];
            this.currencyId = _data["currencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataCurrencyId = _data["prodataToProdataCurrencyId"];
            this.prodataToProdataInvoiceCurrencyId = _data["prodataToProdataInvoiceCurrencyId"];
            this.manualDate = _data["manualDate"] ? moment(_data["manualDate"].toString()) : <any>undefined;
            this.rateUnitTypeId = _data["rateUnitTypeId"];
            this.invoiceFrequencyId = _data["invoiceFrequencyId"];
            this.invoicingTimeId = _data["invoicingTimeId"];
        }
    }

    static fromJS(data: any): ConsultantRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTimeBasedRate"] = this.isTimeBasedRate;
        data["isFixedRate"] = this.isFixedRate;
        data["normalRate"] = this.normalRate;
        data["currencyId"] = this.currencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataCurrencyId"] = this.prodataToProdataCurrencyId;
        data["prodataToProdataInvoiceCurrencyId"] = this.prodataToProdataInvoiceCurrencyId;
        data["manualDate"] = this.manualDate ? this.manualDate.format('YYYY-MM-DD') : <any>undefined;
        data["rateUnitTypeId"] = this.rateUnitTypeId;
        data["invoiceFrequencyId"] = this.invoiceFrequencyId;
        data["invoicingTimeId"] = this.invoicingTimeId;
        return data;
    }
}

export interface IConsultantRateDto {
    isTimeBasedRate?: boolean;
    isFixedRate?: boolean;
    normalRate?: number | undefined;
    currencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataCurrencyId?: number | undefined;
    prodataToProdataInvoiceCurrencyId?: number | undefined;
    manualDate?: moment.Moment | undefined;
    rateUnitTypeId?: number | undefined;
    invoiceFrequencyId?: number | undefined;
    invoicingTimeId?: number | undefined;
}

export class ConsultantResultDto implements IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    companyName?: string | undefined;
    tenantId?: number;
    externalId?: string;
    city?: string | undefined;
    countryId?: number | undefined;

    constructor(data?: IConsultantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.legacyId = _data["legacyId"];
            this.companyName = _data["companyName"];
            this.tenantId = _data["tenantId"];
            this.externalId = _data["externalId"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ConsultantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["legacyId"] = this.legacyId;
        data["companyName"] = this.companyName;
        data["tenantId"] = this.tenantId;
        data["externalId"] = this.externalId;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IConsultantResultDto {
    name?: string | undefined;
    id?: number;
    legacyId?: number | undefined;
    companyName?: string | undefined;
    tenantId?: number;
    externalId?: string;
    city?: string | undefined;
    countryId?: number | undefined;
}

export class ConsultantSalesDataDto implements IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;

    constructor(data?: IConsultantSalesDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employmentTypeId = _data["employmentTypeId"];
            this.consultantId = _data["consultantId"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
            this.nameOnly = _data["nameOnly"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isOnsiteWorkplace = _data["isOnsiteWorkplace"];
            this.onsiteClientId = _data["onsiteClientId"];
            this.onsiteClient = _data["onsiteClient"] ? ClientResultDto.fromJS(_data["onsiteClient"]) : <any>undefined;
            this.isEmagineOfficeWorkplace = _data["isEmagineOfficeWorkplace"];
            this.emagineOfficeId = _data["emagineOfficeId"];
            this.isRemoteWorkplace = _data["isRemoteWorkplace"];
            this.remoteAddressCountryId = _data["remoteAddressCountryId"];
            this.percentageOnSite = _data["percentageOnSite"];
            this.noExpectedWorkload = _data["noExpectedWorkload"];
            this.expectedWorkloadHours = _data["expectedWorkloadHours"];
            this.expectedWorkloadUnitId = _data["expectedWorkloadUnitId"];
            this.consultantTimeReportingCapId = _data["consultantTimeReportingCapId"];
            this.consultantTimeReportingCapMaxValue = _data["consultantTimeReportingCapMaxValue"];
            this.pdcPaymentEntityId = _data["pdcPaymentEntityId"];
            this.consultantRate = _data["consultantRate"] ? ConsultantRateDto.fromJS(_data["consultantRate"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodConsultantSpecialRates"])) {
                this.periodConsultantSpecialRates = [] as any;
                for (let item of _data["periodConsultantSpecialRates"])
                    this.periodConsultantSpecialRates!.push(PeriodConsultantSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodConsultantSpecialFees"])) {
                this.periodConsultantSpecialFees = [] as any;
                for (let item of _data["periodConsultantSpecialFees"])
                    this.periodConsultantSpecialFees!.push(PeriodConsultantSpecialFeeDto.fromJS(item));
            }
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            this.deliveryManagerSameAsAccountManager = _data["deliveryManagerSameAsAccountManager"];
            this.deliveryAccountManagerIdValue = _data["deliveryAccountManagerIdValue"];
            this.deliveryAccountManager = _data["deliveryAccountManager"] ? EmployeeDto.fromJS(_data["deliveryAccountManager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantSalesDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantSalesDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employmentTypeId"] = this.employmentTypeId;
        data["consultantId"] = this.consultantId;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        data["nameOnly"] = this.nameOnly;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isOnsiteWorkplace"] = this.isOnsiteWorkplace;
        data["onsiteClientId"] = this.onsiteClientId;
        data["onsiteClient"] = this.onsiteClient ? this.onsiteClient.toJSON() : <any>undefined;
        data["isEmagineOfficeWorkplace"] = this.isEmagineOfficeWorkplace;
        data["emagineOfficeId"] = this.emagineOfficeId;
        data["isRemoteWorkplace"] = this.isRemoteWorkplace;
        data["remoteAddressCountryId"] = this.remoteAddressCountryId;
        data["percentageOnSite"] = this.percentageOnSite;
        data["noExpectedWorkload"] = this.noExpectedWorkload;
        data["expectedWorkloadHours"] = this.expectedWorkloadHours;
        data["expectedWorkloadUnitId"] = this.expectedWorkloadUnitId;
        data["consultantTimeReportingCapId"] = this.consultantTimeReportingCapId;
        data["consultantTimeReportingCapMaxValue"] = this.consultantTimeReportingCapMaxValue;
        data["pdcPaymentEntityId"] = this.pdcPaymentEntityId;
        data["consultantRate"] = this.consultantRate ? this.consultantRate.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodConsultantSpecialRates)) {
            data["periodConsultantSpecialRates"] = [];
            for (let item of this.periodConsultantSpecialRates)
                data["periodConsultantSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodConsultantSpecialFees)) {
            data["periodConsultantSpecialFees"] = [];
            for (let item of this.periodConsultantSpecialFees)
                data["periodConsultantSpecialFees"].push(item.toJSON());
        }
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        data["deliveryManagerSameAsAccountManager"] = this.deliveryManagerSameAsAccountManager;
        data["deliveryAccountManagerIdValue"] = this.deliveryAccountManagerIdValue;
        data["deliveryAccountManager"] = this.deliveryAccountManager ? this.deliveryAccountManager.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantSalesDataDto {
    employmentTypeId?: number | undefined;
    consultantId?: number | undefined;
    consultant?: ConsultantResultDto;
    nameOnly?: string | undefined;
    startDate?: moment.Moment | undefined;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    isOnsiteWorkplace?: boolean | undefined;
    onsiteClientId?: number | undefined;
    onsiteClient?: ClientResultDto;
    isEmagineOfficeWorkplace?: boolean | undefined;
    emagineOfficeId?: number | undefined;
    isRemoteWorkplace?: boolean | undefined;
    remoteAddressCountryId?: number | undefined;
    percentageOnSite?: number | undefined;
    noExpectedWorkload?: boolean;
    expectedWorkloadHours?: number | undefined;
    expectedWorkloadUnitId?: number | undefined;
    consultantTimeReportingCapId?: number | undefined;
    consultantTimeReportingCapMaxValue?: number | undefined;
    pdcPaymentEntityId?: number | undefined;
    consultantRate?: ConsultantRateDto;
    noSpecialRate?: boolean;
    periodConsultantSpecialRates?: PeriodConsultantSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodConsultantSpecialFees?: PeriodConsultantSpecialFeeDto[] | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    deliveryManagerSameAsAccountManager?: boolean;
    deliveryAccountManagerIdValue?: number | undefined;
    deliveryAccountManager?: EmployeeDto;
}

export class ConsultantTerminationContractDataCommandDto implements IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationContractDataQueryDto implements IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            this.removedConsultantFromAnyManualChecklists = _data["removedConsultantFromAnyManualChecklists"];
            this.deletedAnySensitiveDocumentsForGDPR = _data["deletedAnySensitiveDocumentsForGDPR"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        data["removedConsultantFromAnyManualChecklists"] = this.removedConsultantFromAnyManualChecklists;
        data["deletedAnySensitiveDocumentsForGDPR"] = this.deletedAnySensitiveDocumentsForGDPR;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    removedConsultantFromAnyManualChecklists?: boolean;
    deletedAnySensitiveDocumentsForGDPR?: boolean;
    consultant?: ConsultantResultDto;
}

export class ConsultantTerminationSalesDataCommandDto implements IConsultantTerminationSalesDataCommandDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;

    constructor(data?: IConsultantTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nonStandardTerminationTime = _data["nonStandardTerminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nonStandardTerminationTime"] = this.nonStandardTerminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        return data;
    }
}

export interface IConsultantTerminationSalesDataCommandDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
}

export class ConsultantTerminationSalesDataQueryDto implements IConsultantTerminationSalesDataQueryDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePerson?: ContactDto;

    constructor(data?: IConsultantTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nonStandardTerminationTime = _data["nonStandardTerminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nonStandardTerminationTime"] = this.nonStandardTerminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSalesDataQueryDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePerson?: ContactDto;
}

export class ConsultantTerminationSourcingDataCommandDto implements IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;

    constructor(data?: IConsultantTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultantId = _data["consultantId"];
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultantId"] = this.consultantId;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataCommandDto {
    cvUpdated?: boolean;
    consultantId?: number;
}

export class ConsultantTerminationSourcingDataQueryDto implements IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;

    constructor(data?: IConsultantTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cvUpdated = _data["cvUpdated"];
            this.consultant = _data["consultant"] ? ConsultantResultDto.fromJS(_data["consultant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsultantTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsultantTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cvUpdated"] = this.cvUpdated;
        data["consultant"] = this.consultant ? this.consultant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConsultantTerminationSourcingDataQueryDto {
    cvUpdated?: boolean;
    consultant?: ConsultantResultDto;
}

export class ContactDto implements IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.owner = _data["owner"] ? EmployeeDto.fromJS(_data["owner"]) : <any>undefined;
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.tenant = _data["tenant"] ? Tenant.fromJS(_data["tenant"]) : <any>undefined;
            this.legacyContactId = _data["legacyContactId"] ? LegacyContactId.fromJS(_data["legacyContactId"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.isWrongfullyDeletedInHubspot = _data["isWrongfullyDeletedInHubspot"];
            this.lastCamLogin = _data["lastCamLogin"] ? moment(_data["lastCamLogin"].toString()) : <any>undefined;
            this.hasCamLogin = _data["hasCamLogin"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["legacyContactId"] = this.legacyContactId ? this.legacyContactId.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["isWrongfullyDeletedInHubspot"] = this.isWrongfullyDeletedInHubspot;
        data["lastCamLogin"] = this.lastCamLogin ? this.lastCamLogin.toISOString() : <any>undefined;
        data["hasCamLogin"] = this.hasCamLogin;
        return data;
    }
}

export interface IContactDto {
    id?: number;
    owner?: EmployeeDto;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    tenant?: Tenant;
    legacyContactId?: LegacyContactId;
    isDeleted?: boolean;
    isWrongfullyDeletedInHubspot?: boolean;
    lastCamLogin?: moment.Moment | undefined;
    hasCamLogin?: boolean;
}

export class ContactResultDto implements IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IContactResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ContactResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IContactResultDto {
    id?: number;
    clientId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
}

export class ContractsClientDataDto implements IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;

    constructor(data?: IContractsClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialContractTerms = _data["specialContractTerms"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.clientTimeReportingCapCurrencyId = _data["clientTimeReportingCapCurrencyId"];
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractsClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialContractTerms"] = this.specialContractTerms;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["clientTimeReportingCapCurrencyId"] = this.clientTimeReportingCapCurrencyId;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractsClientDataDto {
    specialContractTerms?: string | undefined;
    noSpecialContractTerms?: boolean;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    clientTimeReportingCapCurrencyId?: number | undefined;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
}

export class ContractSignerDto implements IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;

    constructor(data?: IContractSignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signOrder = _data["signOrder"];
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? ContactResultDto.fromJS(_data["contact"]) : <any>undefined;
            this.signerRoleId = _data["signerRoleId"];
        }
    }

    static fromJS(data: any): ContractSignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signOrder"] = this.signOrder;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["signerRoleId"] = this.signerRoleId;
        return data;
    }
}

export interface IContractSignerDto {
    signOrder?: number;
    contactId?: number;
    contact?: ContactResultDto;
    signerRoleId?: number;
}

export class ContractsMainDataDto implements IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;

    constructor(data?: IContractsMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): ContractsMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface IContractsMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean;
}

export class DomainEventBase implements IDomainEventBase {
    readonly id?: string;
    readonly dateOccurred?: moment.Moment;

    constructor(data?: IDomainEventBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).dateOccurred = _data["dateOccurred"] ? moment(_data["dateOccurred"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainEventBase {
        data = typeof data === 'object' ? data : {};
        let result = new DomainEventBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateOccurred"] = this.dateOccurred ? this.dateOccurred.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDomainEventBase {
    id?: string;
    dateOccurred?: moment.Moment;
}

export class EmployeeDto implements IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface IEmployeeDto {
    id?: number;
    externalId?: string;
    name?: string | undefined;
}

export class EmployeeNotificationDto implements IEmployeeNotificationDto {
    notification?: Notification;
    tenantId?: number | undefined;

    constructor(data?: IEmployeeNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notification = _data["notification"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): EmployeeNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notification"] = this.notification;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IEmployeeNotificationDto {
    notification?: Notification;
    tenantId?: number | undefined;
}

export class EnumEntityTypeDto implements IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IEnumEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EnumEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IEnumEntityTypeDto {
    id?: number;
    name?: string | undefined;
}

export class ExtendClientPeriodDto implements IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantPeriodIds?: string[] | undefined;

    constructor(data?: IExtendClientPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["extendConsultantPeriodIds"])) {
                this.extendConsultantPeriodIds = [] as any;
                for (let item of _data["extendConsultantPeriodIds"])
                    this.extendConsultantPeriodIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendClientPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendClientPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        if (Array.isArray(this.extendConsultantPeriodIds)) {
            data["extendConsultantPeriodIds"] = [];
            for (let item of this.extendConsultantPeriodIds)
                data["extendConsultantPeriodIds"].push(item);
        }
        return data;
    }
}

export interface IExtendClientPeriodDto {
    startDate?: moment.Moment;
    noEndDate?: boolean;
    endDate?: moment.Moment | undefined;
    extendConsultantPeriodIds?: string[] | undefined;
}

export class IdNameDto implements IIdNameDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdNameDto {
    id?: number;
    name?: string | undefined;
}

export class LegacyContactId implements ILegacyContactId {
    readonly value?: number;

    constructor(data?: ILegacyContactId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): LegacyContactId {
        data = typeof data === 'object' ? data : {};
        let result = new LegacyContactId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface ILegacyContactId {
    value?: number;
}

export class NewWorkflowCreatedDto implements INewWorkflowCreatedDto {
    workflowId?: string;

    constructor(data?: INewWorkflowCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): NewWorkflowCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewWorkflowCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        return data;
    }
}

export interface INewWorkflowCreatedDto {
    workflowId?: string;
}

export enum NonStandardTerminationTime {
    BeforeEndOfContract = 1,
    ContractDidNotStart = 2,
}

export enum Notification {
    ConsultantStart = 1,
    ConsultantExtension = 2,
}

export class PeriodClientSpecialFeeDto implements IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.feeDirection = _data["feeDirection"] ? EnumEntityTypeDto.fromJS(_data["feeDirection"]) : <any>undefined;
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["feeDirection"] = this.feeDirection ? this.feeDirection.toJSON() : <any>undefined;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodClientSpecialRateDto implements IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.rateDirection = _data["rateDirection"] ? EnumEntityTypeDto.fromJS(_data["rateDirection"]) : <any>undefined;
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["rateDirection"] = this.rateDirection ? this.rateDirection.toJSON() : <any>undefined;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        return data;
    }
}

export interface IPeriodClientSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialFeeDto implements IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialFeeId = _data["clientSpecialFeeId"];
            this.feeName = _data["feeName"];
            this.feeDirection = _data["feeDirection"] ? EnumEntityTypeDto.fromJS(_data["feeDirection"]) : <any>undefined;
            this.frequency = _data["frequency"] ? EnumEntityTypeDto.fromJS(_data["frequency"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialFeeId"] = this.clientSpecialFeeId;
        data["feeName"] = this.feeName;
        data["feeDirection"] = this.feeDirection ? this.feeDirection.toJSON() : <any>undefined;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialFeeDto {
    id?: number | undefined;
    clientSpecialFeeId?: number;
    feeName?: string | undefined;
    feeDirection?: EnumEntityTypeDto;
    frequency?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class PeriodConsultantSpecialRateDto implements IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;

    constructor(data?: IPeriodConsultantSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientSpecialRateId = _data["clientSpecialRateId"];
            this.rateName = _data["rateName"];
            this.rateDirection = _data["rateDirection"] ? EnumEntityTypeDto.fromJS(_data["rateDirection"]) : <any>undefined;
            this.reportingUnit = _data["reportingUnit"] ? EnumEntityTypeDto.fromJS(_data["reportingUnit"]) : <any>undefined;
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantRateCurrencyId = _data["consultantRateCurrencyId"];
        }
    }

    static fromJS(data: any): PeriodConsultantSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodConsultantSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientSpecialRateId"] = this.clientSpecialRateId;
        data["rateName"] = this.rateName;
        data["rateDirection"] = this.rateDirection ? this.rateDirection.toJSON() : <any>undefined;
        data["reportingUnit"] = this.reportingUnit ? this.reportingUnit.toJSON() : <any>undefined;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantRateCurrencyId"] = this.consultantRateCurrencyId;
        return data;
    }
}

export interface IPeriodConsultantSpecialRateDto {
    id?: number | undefined;
    clientSpecialRateId?: number;
    rateName?: string | undefined;
    rateDirection?: EnumEntityTypeDto;
    reportingUnit?: EnumEntityTypeDto;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantRateCurrencyId?: number | undefined;
}

export class ProjectLineDto implements IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    modifiedById?: number | undefined;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;

    constructor(data?: IProjectLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectName = _data["projectName"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEndDate = _data["noEndDate"];
            this.differentInvoicingReferenceNumber = _data["differentInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.differentInvoicingReferencePerson = _data["differentInvoicingReferencePerson"];
            this.invoicingReferencePersonId = _data["invoicingReferencePersonId"];
            this.optionalInvoicingInfo = _data["optionalInvoicingInfo"];
            this.differentDebtorNumber = _data["differentDebtorNumber"];
            this.debtorNumber = _data["debtorNumber"];
            this.differentInvoiceRecipient = _data["differentInvoiceRecipient"];
            this.invoiceRecipientId = _data["invoiceRecipientId"];
            this.modifiedById = _data["modifiedById"];
            this.modificationDate = _data["modificationDate"] ? moment(_data["modificationDate"].toString()) : <any>undefined;
            this.consultantInsuranceOptionId = _data["consultantInsuranceOptionId"];
        }
    }

    static fromJS(data: any): ProjectLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectName"] = this.projectName;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEndDate"] = this.noEndDate;
        data["differentInvoicingReferenceNumber"] = this.differentInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["differentInvoicingReferencePerson"] = this.differentInvoicingReferencePerson;
        data["invoicingReferencePersonId"] = this.invoicingReferencePersonId;
        data["optionalInvoicingInfo"] = this.optionalInvoicingInfo;
        data["differentDebtorNumber"] = this.differentDebtorNumber;
        data["debtorNumber"] = this.debtorNumber;
        data["differentInvoiceRecipient"] = this.differentInvoiceRecipient;
        data["invoiceRecipientId"] = this.invoiceRecipientId;
        data["modifiedById"] = this.modifiedById;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["consultantInsuranceOptionId"] = this.consultantInsuranceOptionId;
        return data;
    }
}

export interface IProjectLineDto {
    id?: number | undefined;
    projectName?: string | undefined;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
    noEndDate?: boolean;
    differentInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    differentInvoicingReferencePerson?: boolean;
    invoicingReferencePersonId?: number | undefined;
    optionalInvoicingInfo?: string | undefined;
    differentDebtorNumber?: boolean;
    debtorNumber?: string | undefined;
    differentInvoiceRecipient?: boolean;
    invoiceRecipientId?: number | undefined;
    modifiedById?: number | undefined;
    modificationDate?: moment.Moment | undefined;
    consultantInsuranceOptionId?: number | undefined;
}

export class ProjectTypeConfigurationDto implements IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;

    constructor(data?: IProjectTypeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
        }
    }

    static fromJS(data: any): ProjectTypeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        return data;
    }
}

export interface IProjectTypeConfigurationDto {
    salesTypeId?: number;
    deliveryTypeId?: number;
    marginId?: number;
}

export enum RequestProjectTypeValue {
    NormalHighMargin = 1,
    NormalLowMargin = 2,
    NearShoreHighMargin = 3,
    NearShoreLowMargin = 4,
    VMSReferredHighMargin = 5,
    VMSReferredLowMargin = 6,
    NearShoreVMSReferredHighMargin = 7,
    NearShoreVMSReferredLowMargin = 8,
    OtherHighMargin = 9,
    OtherLowMargin = 10,
}

export class RequestProjectTypeValueValueNameDto implements IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;

    constructor(data?: IRequestProjectTypeValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestProjectTypeValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestProjectTypeValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestProjectTypeValueValueNameDto {
    value?: RequestProjectTypeValue;
    name?: string | undefined;
}

export enum RequestStatusValue {
    Open = 1,
    Sold = 2,
    Stop = 3,
    Closed = 4,
    Potential = 7,
    AdRunning = 8,
    TenderSent = 9,
    Cancelled = 10,
}

export class RequestStatusValueValueNameDto implements IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;

    constructor(data?: IRequestStatusValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestStatusValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IRequestStatusValueValueNameDto {
    value?: RequestStatusValue;
    name?: string | undefined;
}

export class SalesClientDataDto implements ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;

    constructor(data?: ISalesClientDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.differentEndClient = _data["differentEndClient"];
            this.directClientIdValue = _data["directClientIdValue"];
            this.directClient = _data["directClient"] ? ClientResultDto.fromJS(_data["directClient"]) : <any>undefined;
            this.endClientIdValue = _data["endClientIdValue"];
            this.endClient = _data["endClient"] ? ClientResultDto.fromJS(_data["endClient"]) : <any>undefined;
            this.noClientExtensionOption = _data["noClientExtensionOption"];
            this.clientExtensionDurationId = _data["clientExtensionDurationId"];
            this.clientExtensionDeadlineId = _data["clientExtensionDeadlineId"];
            this.clientExtensionSpecificDate = _data["clientExtensionSpecificDate"] ? moment(_data["clientExtensionSpecificDate"].toString()) : <any>undefined;
            this.clientTimeReportingCapId = _data["clientTimeReportingCapId"];
            this.clientTimeReportingCapMaxValue = _data["clientTimeReportingCapMaxValue"];
            this.pdcInvoicingEntityId = _data["pdcInvoicingEntityId"];
            this.clientRate = _data["clientRate"] ? ClientRateDto.fromJS(_data["clientRate"]) : <any>undefined;
            this.noInvoicingReferenceNumber = _data["noInvoicingReferenceNumber"];
            this.invoicingReferenceNumber = _data["invoicingReferenceNumber"];
            this.clientInvoicingRecipientSameAsDirectClient = _data["clientInvoicingRecipientSameAsDirectClient"];
            this.clientInvoicingRecipientIdValue = _data["clientInvoicingRecipientIdValue"];
            this.clientInvoicingRecipient = _data["clientInvoicingRecipient"] ? ClientResultDto.fromJS(_data["clientInvoicingRecipient"]) : <any>undefined;
            this.noInvoicingReferencePerson = _data["noInvoicingReferencePerson"];
            this.invoicingReferencePersonIdValue = _data["invoicingReferencePersonIdValue"];
            this.invoicingReferencePerson = _data["invoicingReferencePerson"] ? ContactResultDto.fromJS(_data["invoicingReferencePerson"]) : <any>undefined;
            this.noSpecialRate = _data["noSpecialRate"];
            if (Array.isArray(_data["periodClientSpecialRates"])) {
                this.periodClientSpecialRates = [] as any;
                for (let item of _data["periodClientSpecialRates"])
                    this.periodClientSpecialRates!.push(PeriodClientSpecialRateDto.fromJS(item));
            }
            this.noSpecialFee = _data["noSpecialFee"];
            if (Array.isArray(_data["periodClientSpecialFees"])) {
                this.periodClientSpecialFees = [] as any;
                for (let item of _data["periodClientSpecialFees"])
                    this.periodClientSpecialFees!.push(PeriodClientSpecialFeeDto.fromJS(item));
            }
            this.evaluationsReferencePersonIdValue = _data["evaluationsReferencePersonIdValue"];
            this.evaluationsReferencePerson = _data["evaluationsReferencePerson"] ? ContactResultDto.fromJS(_data["evaluationsReferencePerson"]) : <any>undefined;
            this.evaluationsDisabled = _data["evaluationsDisabled"];
            this.evaluationsDisabledReason = _data["evaluationsDisabledReason"];
            this.noSpecialContractTerms = _data["noSpecialContractTerms"];
            this.specialContractTerms = _data["specialContractTerms"];
            if (Array.isArray(_data["contractSigners"])) {
                this.contractSigners = [] as any;
                for (let item of _data["contractSigners"])
                    this.contractSigners!.push(ContractSignerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesClientDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesClientDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["differentEndClient"] = this.differentEndClient;
        data["directClientIdValue"] = this.directClientIdValue;
        data["directClient"] = this.directClient ? this.directClient.toJSON() : <any>undefined;
        data["endClientIdValue"] = this.endClientIdValue;
        data["endClient"] = this.endClient ? this.endClient.toJSON() : <any>undefined;
        data["noClientExtensionOption"] = this.noClientExtensionOption;
        data["clientExtensionDurationId"] = this.clientExtensionDurationId;
        data["clientExtensionDeadlineId"] = this.clientExtensionDeadlineId;
        data["clientExtensionSpecificDate"] = this.clientExtensionSpecificDate ? this.clientExtensionSpecificDate.toISOString() : <any>undefined;
        data["clientTimeReportingCapId"] = this.clientTimeReportingCapId;
        data["clientTimeReportingCapMaxValue"] = this.clientTimeReportingCapMaxValue;
        data["pdcInvoicingEntityId"] = this.pdcInvoicingEntityId;
        data["clientRate"] = this.clientRate ? this.clientRate.toJSON() : <any>undefined;
        data["noInvoicingReferenceNumber"] = this.noInvoicingReferenceNumber;
        data["invoicingReferenceNumber"] = this.invoicingReferenceNumber;
        data["clientInvoicingRecipientSameAsDirectClient"] = this.clientInvoicingRecipientSameAsDirectClient;
        data["clientInvoicingRecipientIdValue"] = this.clientInvoicingRecipientIdValue;
        data["clientInvoicingRecipient"] = this.clientInvoicingRecipient ? this.clientInvoicingRecipient.toJSON() : <any>undefined;
        data["noInvoicingReferencePerson"] = this.noInvoicingReferencePerson;
        data["invoicingReferencePersonIdValue"] = this.invoicingReferencePersonIdValue;
        data["invoicingReferencePerson"] = this.invoicingReferencePerson ? this.invoicingReferencePerson.toJSON() : <any>undefined;
        data["noSpecialRate"] = this.noSpecialRate;
        if (Array.isArray(this.periodClientSpecialRates)) {
            data["periodClientSpecialRates"] = [];
            for (let item of this.periodClientSpecialRates)
                data["periodClientSpecialRates"].push(item.toJSON());
        }
        data["noSpecialFee"] = this.noSpecialFee;
        if (Array.isArray(this.periodClientSpecialFees)) {
            data["periodClientSpecialFees"] = [];
            for (let item of this.periodClientSpecialFees)
                data["periodClientSpecialFees"].push(item.toJSON());
        }
        data["evaluationsReferencePersonIdValue"] = this.evaluationsReferencePersonIdValue;
        data["evaluationsReferencePerson"] = this.evaluationsReferencePerson ? this.evaluationsReferencePerson.toJSON() : <any>undefined;
        data["evaluationsDisabled"] = this.evaluationsDisabled;
        data["evaluationsDisabledReason"] = this.evaluationsDisabledReason;
        data["noSpecialContractTerms"] = this.noSpecialContractTerms;
        data["specialContractTerms"] = this.specialContractTerms;
        if (Array.isArray(this.contractSigners)) {
            data["contractSigners"] = [];
            for (let item of this.contractSigners)
                data["contractSigners"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISalesClientDataDto {
    differentEndClient?: boolean;
    directClientIdValue?: number | undefined;
    directClient?: ClientResultDto;
    endClientIdValue?: number | undefined;
    endClient?: ClientResultDto;
    noClientExtensionOption?: boolean;
    clientExtensionDurationId?: number | undefined;
    clientExtensionDeadlineId?: number | undefined;
    clientExtensionSpecificDate?: moment.Moment | undefined;
    clientTimeReportingCapId?: number | undefined;
    clientTimeReportingCapMaxValue?: number | undefined;
    pdcInvoicingEntityId?: number | undefined;
    clientRate?: ClientRateDto;
    noInvoicingReferenceNumber?: boolean;
    invoicingReferenceNumber?: string | undefined;
    clientInvoicingRecipientSameAsDirectClient?: boolean;
    clientInvoicingRecipientIdValue?: number | undefined;
    clientInvoicingRecipient?: ClientResultDto;
    noInvoicingReferencePerson?: boolean | undefined;
    invoicingReferencePersonIdValue?: number | undefined;
    invoicingReferencePerson?: ContactResultDto;
    noSpecialRate?: boolean;
    periodClientSpecialRates?: PeriodClientSpecialRateDto[] | undefined;
    noSpecialFee?: boolean;
    periodClientSpecialFees?: PeriodClientSpecialFeeDto[] | undefined;
    evaluationsReferencePersonIdValue?: number | undefined;
    evaluationsReferencePerson?: ContactResultDto;
    evaluationsDisabled?: boolean;
    evaluationsDisabledReason?: string | undefined;
    noSpecialContractTerms?: boolean;
    specialContractTerms?: string | undefined;
    contractSigners?: ContractSignerDto[] | undefined;
}

export class SalesMainDataDto implements ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: number[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;

    constructor(data?: ISalesMainDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.salesTypeId = _data["salesTypeId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.marginId = _data["marginId"];
            this.projectCategoryId = _data["projectCategoryId"];
            this.projectDescription = _data["projectDescription"];
            this.discountId = _data["discountId"];
            if (Array.isArray(_data["commissions"])) {
                this.commissions = [] as any;
                for (let item of _data["commissions"])
                    this.commissions!.push(CommissionDto.fromJS(item));
            }
            this.salesAccountManagerIdValue = _data["salesAccountManagerIdValue"];
            this.salesAccountManagerData = _data["salesAccountManagerData"] ? EmployeeDto.fromJS(_data["salesAccountManagerData"]) : <any>undefined;
            this.commissionAccountManagerIdValue = _data["commissionAccountManagerIdValue"];
            this.commissionAccountManagerData = _data["commissionAccountManagerData"] ? EmployeeDto.fromJS(_data["commissionAccountManagerData"]) : <any>undefined;
            if (Array.isArray(_data["contractExpirationNotificationIntervalIds"])) {
                this.contractExpirationNotificationIntervalIds = [] as any;
                for (let item of _data["contractExpirationNotificationIntervalIds"])
                    this.contractExpirationNotificationIntervalIds!.push(item);
            }
            this.customContractExpirationNotificationDate = _data["customContractExpirationNotificationDate"] ? moment(_data["customContractExpirationNotificationDate"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.noRemarks = _data["noRemarks"];
        }
    }

    static fromJS(data: any): SalesMainDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesMainDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["salesTypeId"] = this.salesTypeId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["marginId"] = this.marginId;
        data["projectCategoryId"] = this.projectCategoryId;
        data["projectDescription"] = this.projectDescription;
        data["discountId"] = this.discountId;
        if (Array.isArray(this.commissions)) {
            data["commissions"] = [];
            for (let item of this.commissions)
                data["commissions"].push(item.toJSON());
        }
        data["salesAccountManagerIdValue"] = this.salesAccountManagerIdValue;
        data["salesAccountManagerData"] = this.salesAccountManagerData ? this.salesAccountManagerData.toJSON() : <any>undefined;
        data["commissionAccountManagerIdValue"] = this.commissionAccountManagerIdValue;
        data["commissionAccountManagerData"] = this.commissionAccountManagerData ? this.commissionAccountManagerData.toJSON() : <any>undefined;
        if (Array.isArray(this.contractExpirationNotificationIntervalIds)) {
            data["contractExpirationNotificationIntervalIds"] = [];
            for (let item of this.contractExpirationNotificationIntervalIds)
                data["contractExpirationNotificationIntervalIds"].push(item);
        }
        data["customContractExpirationNotificationDate"] = this.customContractExpirationNotificationDate ? this.customContractExpirationNotificationDate.format('YYYY-MM-DD') : <any>undefined;
        data["remarks"] = this.remarks;
        data["noRemarks"] = this.noRemarks;
        return data;
    }
}

export interface ISalesMainDataDto {
    projectTypeId?: number | undefined;
    salesTypeId?: number | undefined;
    deliveryTypeId?: number | undefined;
    marginId?: number | undefined;
    projectCategoryId?: number | undefined;
    projectDescription?: string | undefined;
    discountId?: number | undefined;
    commissions?: CommissionDto[] | undefined;
    salesAccountManagerIdValue?: number | undefined;
    salesAccountManagerData?: EmployeeDto;
    commissionAccountManagerIdValue?: number | undefined;
    commissionAccountManagerData?: EmployeeDto;
    contractExpirationNotificationIntervalIds?: number[] | undefined;
    customContractExpirationNotificationDate?: moment.Moment | undefined;
    remarks?: string | undefined;
    noRemarks?: boolean | undefined;
}

export class SimplePublicObject implements ISimplePublicObject {
    id!: string;
    properties!: { [key: string]: string; };
    createdAt!: moment.Moment;
    updatedAt!: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISimplePublicObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.archivedAt = _data["archivedAt"] ? moment(_data["archivedAt"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimplePublicObject {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePublicObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["archivedAt"] = this.archivedAt ? this.archivedAt.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISimplePublicObject {
    id: string;
    properties: { [key: string]: string; };
    createdAt: moment.Moment;
    updatedAt: moment.Moment;
    archived?: boolean | undefined;
    archivedAt?: moment.Moment | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SimpleRequestLocationDto implements ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;

    constructor(data?: ISimpleRequestLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"] ? IdNameDto.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"] ? IdNameDto.fromJS(_data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimpleRequestLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleRequestLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISimpleRequestLocationDto {
    id?: number;
    country?: IdNameDto;
    city?: IdNameDto;
}

export class SpecialRateReportingUnit implements ISpecialRateReportingUnit {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateReportingUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateReportingUnit {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateReportingUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateReportingUnit {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class SpecialRateSpecifiedAs implements ISpecialRateSpecifiedAs {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ISpecialRateSpecifiedAs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): SpecialRateSpecifiedAs {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialRateSpecifiedAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISpecialRateSpecifiedAs {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export class StartNewWorkflowInputDto implements IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;

    constructor(data?: IStartNewWorkflowInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            this.soldRequestConsultantId = _data["soldRequestConsultantId"];
        }
    }

    static fromJS(data: any): StartNewWorkflowInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StartNewWorkflowInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["requestId"] = this.requestId;
        data["soldRequestConsultantId"] = this.soldRequestConsultantId;
        return data;
    }
}

export interface IStartNewWorkflowInputDto {
    startDate?: moment.Moment;
    endDate?: moment.Moment | undefined;
    requestId?: number | undefined;
    soldRequestConsultantId?: number | undefined;
}

export class StepDto implements IStepDto {
    typeId?: StepType;
    readonly name?: string | undefined;
    isCompleted?: boolean | undefined;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: ActionPermissionDto; } | undefined;

    constructor(data?: IStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.isCompleted = _data["isCompleted"];
            this.responsiblePerson = _data["responsiblePerson"] ? EmployeeDto.fromJS(_data["responsiblePerson"]) : <any>undefined;
            if (_data["actionsPermissionsForCurrentUser"]) {
                this.actionsPermissionsForCurrentUser = {} as any;
                for (let key in _data["actionsPermissionsForCurrentUser"]) {
                    if (_data["actionsPermissionsForCurrentUser"].hasOwnProperty(key))
                        (<any>this.actionsPermissionsForCurrentUser)![key] = _data["actionsPermissionsForCurrentUser"][key] ? ActionPermissionDto.fromJS(_data["actionsPermissionsForCurrentUser"][key]) : new ActionPermissionDto();
                }
            }
        }
    }

    static fromJS(data: any): StepDto {
        data = typeof data === 'object' ? data : {};
        let result = new StepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["isCompleted"] = this.isCompleted;
        data["responsiblePerson"] = this.responsiblePerson ? this.responsiblePerson.toJSON() : <any>undefined;
        if (this.actionsPermissionsForCurrentUser) {
            data["actionsPermissionsForCurrentUser"] = {};
            for (let key in this.actionsPermissionsForCurrentUser) {
                if (this.actionsPermissionsForCurrentUser.hasOwnProperty(key))
                    (<any>data["actionsPermissionsForCurrentUser"])[key] = this.actionsPermissionsForCurrentUser[key] ? this.actionsPermissionsForCurrentUser[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IStepDto {
    typeId?: StepType;
    name?: string | undefined;
    isCompleted?: boolean | undefined;
    responsiblePerson?: EmployeeDto;
    actionsPermissionsForCurrentUser?: { [key: string]: ActionPermissionDto; } | undefined;
}

export enum StepType {
    Sales = 1,
    Contract = 2,
    Finance = 3,
    Sourcing = 4,
}

export class SupplierResultDto implements ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    externalId?: string;

    constructor(data?: ISupplierResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): SupplierResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface ISupplierResultDto {
    supplierId?: number;
    supplierName?: string | undefined;
    externalId?: string;
}

export class Tenant implements ITenant {
    readonly domainEvents?: DomainEventBase[] | undefined;
    readonly id?: number;
    readonly name?: string | undefined;

    constructor(data?: ITenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents!.push(DomainEventBase.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): Tenant {
        data = typeof data === 'object' ? data : {};
        let result = new Tenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITenant {
    domainEvents?: DomainEventBase[] | undefined;
    id?: number;
    name?: string | undefined;
}

export enum TerminationReason {
    RequestedByClient = 1,
    RequestedByConsultant = 2,
}

export class UpdateClientSpecialFeeDto implements IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialFeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.clientSpecialFeeFrequencyId = _data["clientSpecialFeeFrequencyId"];
            this.clientSpecialFeeSpecifiedAsId = _data["clientSpecialFeeSpecifiedAsId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["clientSpecialFeeFrequencyId"] = this.clientSpecialFeeFrequencyId;
        data["clientSpecialFeeSpecifiedAsId"] = this.clientSpecialFeeSpecifiedAsId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialFeeDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    clientSpecialFeeFrequencyId?: number;
    clientSpecialFeeSpecifiedAsId?: number;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class UpdateClientSpecialRateDto implements IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;

    constructor(data?: IUpdateClientSpecialRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internalName = _data["internalName"];
            this.publicName = _data["publicName"];
            this.specialRateOrFeeDirectionId = _data["specialRateOrFeeDirectionId"];
            this.specialRateReportingUnitId = _data["specialRateReportingUnitId"];
            this.specialRateSpecifiedAsId = _data["specialRateSpecifiedAsId"];
            this.specialRateCategoryId = _data["specialRateCategoryId"];
            this.clientRate = _data["clientRate"];
            this.clientRateCurrencyId = _data["clientRateCurrencyId"];
            this.prodataToProdataRate = _data["prodataToProdataRate"];
            this.prodataToProdataRateCurrencyId = _data["prodataToProdataRateCurrencyId"];
            this.consultantRate = _data["consultantRate"];
            this.consultantCurrencyId = _data["consultantCurrencyId"];
            this.isHidden = _data["isHidden"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientSpecialRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientSpecialRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalName"] = this.internalName;
        data["publicName"] = this.publicName;
        data["specialRateOrFeeDirectionId"] = this.specialRateOrFeeDirectionId;
        data["specialRateReportingUnitId"] = this.specialRateReportingUnitId;
        data["specialRateSpecifiedAsId"] = this.specialRateSpecifiedAsId;
        data["specialRateCategoryId"] = this.specialRateCategoryId;
        data["clientRate"] = this.clientRate;
        data["clientRateCurrencyId"] = this.clientRateCurrencyId;
        data["prodataToProdataRate"] = this.prodataToProdataRate;
        data["prodataToProdataRateCurrencyId"] = this.prodataToProdataRateCurrencyId;
        data["consultantRate"] = this.consultantRate;
        data["consultantCurrencyId"] = this.consultantCurrencyId;
        data["isHidden"] = this.isHidden;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateClientSpecialRateDto {
    internalName?: string | undefined;
    publicName?: string | undefined;
    specialRateOrFeeDirectionId?: number;
    specialRateReportingUnitId?: number;
    specialRateSpecifiedAsId?: number | undefined;
    specialRateCategoryId?: number | undefined;
    clientRate?: number | undefined;
    clientRateCurrencyId?: number | undefined;
    prodataToProdataRate?: number | undefined;
    prodataToProdataRateCurrencyId?: number | undefined;
    consultantRate?: number | undefined;
    consultantCurrencyId?: number | undefined;
    isHidden?: boolean;
    id?: number;
}

export class WorkflowAlreadyExistsDto implements IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;

    constructor(data?: IWorkflowAlreadyExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.existingWorkflowId = _data["existingWorkflowId"];
        }
    }

    static fromJS(data: any): WorkflowAlreadyExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAlreadyExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingWorkflowId"] = this.existingWorkflowId;
        return data;
    }
}

export interface IWorkflowAlreadyExistsDto {
    existingWorkflowId?: string | undefined;
}

export class WorkflowDto implements IWorkflowDto {
    workflowId?: string;
    clientPeriods?: ClientPeriodDto[] | undefined;

    constructor(data?: IWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            if (Array.isArray(_data["clientPeriods"])) {
                this.clientPeriods = [] as any;
                for (let item of _data["clientPeriods"])
                    this.clientPeriods!.push(ClientPeriodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        if (Array.isArray(this.clientPeriods)) {
            data["clientPeriods"] = [];
            for (let item of this.clientPeriods)
                data["clientPeriods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowDto {
    workflowId?: string;
    clientPeriods?: ClientPeriodDto[] | undefined;
}

export class WorkflowProcessDto implements IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    readonly name?: string | undefined;
    consultantName?: string | undefined;
    additionalInfo?: string | undefined;
    steps?: StepDto[] | undefined;

    constructor(data?: IWorkflowProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            (<any>this).name = _data["name"];
            this.consultantName = _data["consultantName"];
            this.additionalInfo = _data["additionalInfo"];
            if (Array.isArray(_data["steps"])) {
                this.steps = [] as any;
                for (let item of _data["steps"])
                    this.steps!.push(StepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["consultantName"] = this.consultantName;
        data["additionalInfo"] = this.additionalInfo;
        if (Array.isArray(this.steps)) {
            data["steps"] = [];
            for (let item of this.steps)
                data["steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowProcessDto {
    typeId?: WorkflowProcessType;
    name?: string | undefined;
    consultantName?: string | undefined;
    additionalInfo?: string | undefined;
    steps?: StepDto[] | undefined;
}

export enum WorkflowProcessType {
    StartClientPeriod = 1,
    ChangeClientPeriod = 2,
    ExtendClientPeriod = 3,
    StartConsultantPeriod = 4,
    ChangeConsultantPeriod = 5,
    ExtendConsultantPeriod = 6,
    TerminateWorkflow = 7,
    TerminateConsultant = 8,
}

export class WorkflowTerminationContractDataCommandDto implements IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataCommandDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataCommandDto[] | undefined;
}

export class WorkflowTerminationContractDataQueryDto implements IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationContractDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLinesDoneManuallyInOldPM = _data["contractLinesDoneManuallyInOldPM"];
            if (Array.isArray(_data["consultantTerminationContractData"])) {
                this.consultantTerminationContractData = [] as any;
                for (let item of _data["consultantTerminationContractData"])
                    this.consultantTerminationContractData!.push(ConsultantTerminationContractDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationContractDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationContractDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLinesDoneManuallyInOldPM"] = this.contractLinesDoneManuallyInOldPM;
        if (Array.isArray(this.consultantTerminationContractData)) {
            data["consultantTerminationContractData"] = [];
            for (let item of this.consultantTerminationContractData)
                data["consultantTerminationContractData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationContractDataQueryDto {
    contractLinesDoneManuallyInOldPM?: boolean;
    consultantTerminationContractData?: ConsultantTerminationContractDataQueryDto[] | undefined;
}

export class WorkflowTerminationSalesDataCommandDto implements IWorkflowTerminationSalesDataCommandDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;

    constructor(data?: IWorkflowTerminationSalesDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nonStandardTerminationTime = _data["nonStandardTerminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePersonId = _data["finalEvaluationReferencePersonId"];
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nonStandardTerminationTime"] = this.nonStandardTerminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePersonId"] = this.finalEvaluationReferencePersonId;
        return data;
    }
}

export interface IWorkflowTerminationSalesDataCommandDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePersonId?: number | undefined;
}

export class WorkflowTerminationSalesDataQueryDto implements IWorkflowTerminationSalesDataQueryDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePerson?: ContactDto;

    constructor(data?: IWorkflowTerminationSalesDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nonStandardTerminationTime = _data["nonStandardTerminationTime"];
            this.causeOfNonStandardTerminationTime = _data["causeOfNonStandardTerminationTime"];
            this.terminationReason = _data["terminationReason"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.noEvaluation = _data["noEvaluation"];
            this.causeOfNoEvaluation = _data["causeOfNoEvaluation"];
            this.additionalComments = _data["additionalComments"];
            this.finalEvaluationReferencePerson = _data["finalEvaluationReferencePerson"] ? ContactDto.fromJS(_data["finalEvaluationReferencePerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowTerminationSalesDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSalesDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nonStandardTerminationTime"] = this.nonStandardTerminationTime;
        data["causeOfNonStandardTerminationTime"] = this.causeOfNonStandardTerminationTime;
        data["terminationReason"] = this.terminationReason;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["noEvaluation"] = this.noEvaluation;
        data["causeOfNoEvaluation"] = this.causeOfNoEvaluation;
        data["additionalComments"] = this.additionalComments;
        data["finalEvaluationReferencePerson"] = this.finalEvaluationReferencePerson ? this.finalEvaluationReferencePerson.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowTerminationSalesDataQueryDto {
    nonStandardTerminationTime?: NonStandardTerminationTime;
    causeOfNonStandardTerminationTime?: string | undefined;
    terminationReason?: TerminationReason;
    endDate?: moment.Moment | undefined;
    noEvaluation?: boolean;
    causeOfNoEvaluation?: string | undefined;
    additionalComments?: string | undefined;
    finalEvaluationReferencePerson?: ContactDto;
}

export class WorkflowTerminationSourcingDataCommandDto implements IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataCommandDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataCommandDto[] | undefined;
}

export class WorkflowTerminationSourcingDataQueryDto implements IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;

    constructor(data?: IWorkflowTerminationSourcingDataQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consultantTerminationSourcingData"])) {
                this.consultantTerminationSourcingData = [] as any;
                for (let item of _data["consultantTerminationSourcingData"])
                    this.consultantTerminationSourcingData!.push(ConsultantTerminationSourcingDataQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTerminationSourcingDataQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTerminationSourcingDataQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consultantTerminationSourcingData)) {
            data["consultantTerminationSourcingData"] = [];
            for (let item of this.consultantTerminationSourcingData)
                data["consultantTerminationSourcingData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowTerminationSourcingDataQueryDto {
    consultantTerminationSourcingData?: ConsultantTerminationSourcingDataQueryDto[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}