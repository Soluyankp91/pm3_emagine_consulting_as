/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param redirectUri (optional) 
     * @return Success
     */
    signIn(scheme: string, redirectUri: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignIn/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param redirectUri (optional) 
     * @param scope (optional) 
     * @param loginHint (optional) 
     * @param domainHint (optional) 
     * @param claims (optional) 
     * @param policy (optional) 
     * @return Success
     */
    challenge(redirectUri: string | undefined, scope: string | undefined, loginHint: string | undefined, domainHint: string | undefined, claims: string | undefined, policy: string | undefined, scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/Challenge/{scheme}?";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        if (redirectUri === null)
            throw new Error("The parameter 'redirectUri' cannot be null.");
        else if (redirectUri !== undefined)
            url_ += "redirectUri=" + encodeURIComponent("" + redirectUri) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (loginHint === null)
            throw new Error("The parameter 'loginHint' cannot be null.");
        else if (loginHint !== undefined)
            url_ += "loginHint=" + encodeURIComponent("" + loginHint) + "&";
        if (domainHint === null)
            throw new Error("The parameter 'domainHint' cannot be null.");
        else if (domainHint !== undefined)
            url_ += "domainHint=" + encodeURIComponent("" + domainHint) + "&";
        if (claims === null)
            throw new Error("The parameter 'claims' cannot be null.");
        else if (claims !== undefined)
            url_ += "claims=" + encodeURIComponent("" + claims) + "&";
        if (policy === null)
            throw new Error("The parameter 'policy' cannot be null.");
        else if (policy !== undefined)
            url_ += "policy=" + encodeURIComponent("" + policy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallenge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallenge(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChallenge(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    signOut(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/SignOut/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    resetPassword(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/ResetPassword/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    editProfile(scheme: string): Observable<void> {
        let url_ = this.baseUrl + "/MicrosoftIdentity/Account/EditProfile/{scheme}";
        if (scheme === undefined || scheme === null)
            throw new Error("The parameter 'scheme' must be defined.");
        url_ = url_.replace("{scheme}", encodeURIComponent("" + scheme));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param countryFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clients(search: string | undefined, countryFilter: string[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, sort: string | undefined): Observable<ClientListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (countryFilter === null)
            throw new Error("The parameter 'countryFilter' cannot be null.");
        else if (countryFilter !== undefined)
            countryFilter && countryFilter.forEach(item => { url_ += "countryFilter=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(<any>response_);
                } catch (e) {
                    return <Observable<ClientListItemDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListItemDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<ClientListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListItemDtoPaginatedList>(<any>null);
    }
}

@Injectable()
export class ClientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param search (optional) 
     * @param projectTypeFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    clientOverview(search: string | undefined, projectTypeFilter: string[] | undefined, pageNumber: number | undefined, pageSize: number | undefined, sort: string | undefined): Observable<ClientOverviewListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/client-overview?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (projectTypeFilter === null)
            throw new Error("The parameter 'projectTypeFilter' cannot be null.");
        else if (projectTypeFilter !== undefined)
            projectTypeFilter && projectTypeFilter.forEach(item => { url_ += "projectTypeFilter=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientOverview(<any>response_);
                } catch (e) {
                    return <Observable<ClientOverviewListItemDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientOverviewListItemDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processClientOverview(response: HttpResponseBase): Observable<ClientOverviewListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientOverviewListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientOverviewListItemDtoPaginatedList>(<any>null);
    }

    /**
     * @param clientIdQuery (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    consultantContracts(clientIdQuery: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, sort: string | undefined, clientIdPath: string): Observable<ClientContractListItemDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{clientId}/consultant-contracts?";
        if (clientIdPath === undefined || clientIdPath === null)
            throw new Error("The parameter 'clientIdPath' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientIdPath));
        if (clientIdQuery === null)
            throw new Error("The parameter 'clientIdQuery' cannot be null.");
        else if (clientIdQuery !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientIdQuery) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsultantContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsultantContracts(<any>response_);
                } catch (e) {
                    return <Observable<ClientContractListItemDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientContractListItemDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processConsultantContracts(response: HttpResponseBase): Observable<ClientContractListItemDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientContractListItemDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientContractListItemDtoPaginatedList>(<any>null);
    }

    /**
     * @param legacyClientIdQuery (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @return Success
     */
    requestTrack(legacyClientIdQuery: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, sort: string | undefined, legacyClientIdPath: string): Observable<ClientRequestTrackDtoPaginatedList> {
        let url_ = this.baseUrl + "/api/Clients/{legacyClientId}/request-track?";
        if (legacyClientIdPath === undefined || legacyClientIdPath === null)
            throw new Error("The parameter 'legacyClientIdPath' must be defined.");
        url_ = url_.replace("{legacyClientId}", encodeURIComponent("" + legacyClientIdPath));
        if (legacyClientIdQuery === null)
            throw new Error("The parameter 'legacyClientIdQuery' cannot be null.");
        else if (legacyClientIdQuery !== undefined)
            url_ += "legacyClientId=" + encodeURIComponent("" + legacyClientIdQuery) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTrack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTrack(<any>response_);
                } catch (e) {
                    return <Observable<ClientRequestTrackDtoPaginatedList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientRequestTrackDtoPaginatedList>><any>_observableThrow(response_);
        }));
    }

    protected processRequestTrack(response: HttpResponseBase): Observable<ClientRequestTrackDtoPaginatedList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRequestTrackDtoPaginatedList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRequestTrackDtoPaginatedList>(<any>null);
    }
}

@Injectable()
export class ConsultantsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testAdTokenFlow(): Observable<string> {
        let url_ = this.baseUrl + "/api/Consultants/TestAdTokenFlow";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAdTokenFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAdTokenFlow(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTestAdTokenFlow(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class EnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    countries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Enum/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    projectTypes(): Observable<ProjectTypeDto[]> {
        let url_ = this.baseUrl + "/api/Enum/project-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<ProjectTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processProjectTypes(response: HttpResponseBase): Observable<ProjectTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectTypeDto[]>(<any>null);
    }
}

@Injectable()
export class HubSpotContractFetchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    listContracts(userId: string | undefined, userEmail: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotContractFetch/ListContracts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListContracts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListContracts(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processListContracts(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HubSpotInstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    auth(code: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/HubSpotInstall/auth?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAuth(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HubSpotTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testCreateClientInHubSpot(): Observable<SimplePublicObject> {
        let url_ = this.baseUrl + "/api/HubSpotTest/TestCreateClientInHubSpot";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCreateClientInHubSpot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCreateClientInHubSpot(<any>response_);
                } catch (e) {
                    return <Observable<SimplePublicObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimplePublicObject>><any>_observableThrow(response_);
        }));
    }

    protected processTestCreateClientInHubSpot(response: HttpResponseBase): Observable<SimplePublicObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimplePublicObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimplePublicObject>(<any>null);
    }
}

export class ClientContractListItemDto implements IClientContractListItemDto {
    id!: number;
    consultantName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    contractOwner!: string | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;

    constructor(data?: IClientContractListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.consultantName = _data["consultantName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contractOwner = _data["contractOwner"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientContractListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["consultantName"] = this.consultantName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contractOwner"] = this.contractOwner;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IClientContractListItemDto {
    id: number;
    consultantName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    contractOwner: string | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
}

export class ClientContractListItemDtoPaginatedList implements IClientContractListItemDtoPaginatedList {
    readonly items!: ClientContractListItemDto[] | undefined;
    readonly pageIndex!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly pageSize!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IClientContractListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ClientContractListItemDto.fromJS(item));
            }
            (<any>this).pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).totalCount = _data["totalCount"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientContractListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientContractListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IClientContractListItemDtoPaginatedList {
    items: ClientContractListItemDto[] | undefined;
    pageIndex: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ClientListItemDto implements IClientListItemDto {
    id!: number;
    crmClientId!: number | undefined;
    legacyClientId!: number | undefined;
    name!: string | undefined;
    clientAddress_Address!: string | undefined;
    clientAddress_Address2!: string | undefined;
    clientAddress_PostCode!: string | undefined;
    clientAddress_City!: string | undefined;
    clientAddress_Country_Name!: string | undefined;
    clientAddress_Country_Code!: string | undefined;
    phone!: string | undefined;
    owner_Name!: string | undefined;
    tenant_TenantId_Value!: number;

    constructor(data?: IClientListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.crmClientId = _data["crmClientId"];
            this.legacyClientId = _data["legacyClientId"];
            this.name = _data["name"];
            this.clientAddress_Address = _data["clientAddress_Address"];
            this.clientAddress_Address2 = _data["clientAddress_Address2"];
            this.clientAddress_PostCode = _data["clientAddress_PostCode"];
            this.clientAddress_City = _data["clientAddress_City"];
            this.clientAddress_Country_Name = _data["clientAddress_Country_Name"];
            this.clientAddress_Country_Code = _data["clientAddress_Country_Code"];
            this.phone = _data["phone"];
            this.owner_Name = _data["owner_Name"];
            this.tenant_TenantId_Value = _data["tenant_TenantId_Value"];
        }
    }

    static fromJS(data: any): ClientListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["crmClientId"] = this.crmClientId;
        data["legacyClientId"] = this.legacyClientId;
        data["name"] = this.name;
        data["clientAddress_Address"] = this.clientAddress_Address;
        data["clientAddress_Address2"] = this.clientAddress_Address2;
        data["clientAddress_PostCode"] = this.clientAddress_PostCode;
        data["clientAddress_City"] = this.clientAddress_City;
        data["clientAddress_Country_Name"] = this.clientAddress_Country_Name;
        data["clientAddress_Country_Code"] = this.clientAddress_Country_Code;
        data["phone"] = this.phone;
        data["owner_Name"] = this.owner_Name;
        data["tenant_TenantId_Value"] = this.tenant_TenantId_Value;
        return data; 
    }
}

export interface IClientListItemDto {
    id: number;
    crmClientId: number | undefined;
    legacyClientId: number | undefined;
    name: string | undefined;
    clientAddress_Address: string | undefined;
    clientAddress_Address2: string | undefined;
    clientAddress_PostCode: string | undefined;
    clientAddress_City: string | undefined;
    clientAddress_Country_Name: string | undefined;
    clientAddress_Country_Code: string | undefined;
    phone: string | undefined;
    owner_Name: string | undefined;
    tenant_TenantId_Value: number;
}

export class ClientListItemDtoPaginatedList implements IClientListItemDtoPaginatedList {
    readonly items!: ClientListItemDto[] | undefined;
    readonly pageIndex!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly pageSize!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IClientListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ClientListItemDto.fromJS(item));
            }
            (<any>this).pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).totalCount = _data["totalCount"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IClientListItemDtoPaginatedList {
    items: ClientListItemDto[] | undefined;
    pageIndex: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ClientOverviewListItemDto implements IClientOverviewListItemDto {
    consultantId!: number;
    clientName!: string | undefined;
    consultantName!: string | undefined;
    note!: string | undefined;
    endDate!: moment.Moment;
    projectType!: string | undefined;
    contractsCount!: number;
    contractsPendingCount!: number;
    contractsExtensionsOkCount!: number;

    constructor(data?: IClientOverviewListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consultantId = _data["consultantId"];
            this.clientName = _data["clientName"];
            this.consultantName = _data["consultantName"];
            this.note = _data["note"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.projectType = _data["projectType"];
            this.contractsCount = _data["contractsCount"];
            this.contractsPendingCount = _data["contractsPendingCount"];
            this.contractsExtensionsOkCount = _data["contractsExtensionsOkCount"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consultantId"] = this.consultantId;
        data["clientName"] = this.clientName;
        data["consultantName"] = this.consultantName;
        data["note"] = this.note;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["projectType"] = this.projectType;
        data["contractsCount"] = this.contractsCount;
        data["contractsPendingCount"] = this.contractsPendingCount;
        data["contractsExtensionsOkCount"] = this.contractsExtensionsOkCount;
        return data; 
    }
}

export interface IClientOverviewListItemDto {
    consultantId: number;
    clientName: string | undefined;
    consultantName: string | undefined;
    note: string | undefined;
    endDate: moment.Moment;
    projectType: string | undefined;
    contractsCount: number;
    contractsPendingCount: number;
    contractsExtensionsOkCount: number;
}

export class ClientOverviewListItemDtoPaginatedList implements IClientOverviewListItemDtoPaginatedList {
    readonly items!: ClientOverviewListItemDto[] | undefined;
    readonly pageIndex!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly pageSize!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IClientOverviewListItemDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ClientOverviewListItemDto.fromJS(item));
            }
            (<any>this).pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).totalCount = _data["totalCount"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientOverviewListItemDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientOverviewListItemDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IClientOverviewListItemDtoPaginatedList {
    items: ClientOverviewListItemDto[] | undefined;
    pageIndex: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ClientRequestTrackDto implements IClientRequestTrackDto {
    requestId!: number;
    headline!: string | undefined;
    status!: RequestStatusValueValueNameDto;
    clientDeadline!: moment.Moment | undefined;
    dateAdded!: moment.Moment;
    projectType!: RequestProjectTypeValueValueNameDto;
    priority!: number;
    numberOfConsultants!: number;
    locations!: SimpleRequestLocationDto[] | undefined;
    requestSourcers!: EmployeeDto[] | undefined;
    accountManagers!: EmployeeDto[] | undefined;

    constructor(data?: IClientRequestTrackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.headline = _data["headline"];
            this.status = _data["status"] ? RequestStatusValueValueNameDto.fromJS(_data["status"]) : <any>undefined;
            this.clientDeadline = _data["clientDeadline"] ? moment(_data["clientDeadline"].toString()) : <any>undefined;
            this.dateAdded = _data["dateAdded"] ? moment(_data["dateAdded"].toString()) : <any>undefined;
            this.projectType = _data["projectType"] ? RequestProjectTypeValueValueNameDto.fromJS(_data["projectType"]) : <any>undefined;
            this.priority = _data["priority"];
            this.numberOfConsultants = _data["numberOfConsultants"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(SimpleRequestLocationDto.fromJS(item));
            }
            if (Array.isArray(_data["requestSourcers"])) {
                this.requestSourcers = [] as any;
                for (let item of _data["requestSourcers"])
                    this.requestSourcers!.push(EmployeeDto.fromJS(item));
            }
            if (Array.isArray(_data["accountManagers"])) {
                this.accountManagers = [] as any;
                for (let item of _data["accountManagers"])
                    this.accountManagers!.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRequestTrackDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["headline"] = this.headline;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["clientDeadline"] = this.clientDeadline ? this.clientDeadline.toISOString() : <any>undefined;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["priority"] = this.priority;
        data["numberOfConsultants"] = this.numberOfConsultants;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.requestSourcers)) {
            data["requestSourcers"] = [];
            for (let item of this.requestSourcers)
                data["requestSourcers"].push(item.toJSON());
        }
        if (Array.isArray(this.accountManagers)) {
            data["accountManagers"] = [];
            for (let item of this.accountManagers)
                data["accountManagers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClientRequestTrackDto {
    requestId: number;
    headline: string | undefined;
    status: RequestStatusValueValueNameDto;
    clientDeadline: moment.Moment | undefined;
    dateAdded: moment.Moment;
    projectType: RequestProjectTypeValueValueNameDto;
    priority: number;
    numberOfConsultants: number;
    locations: SimpleRequestLocationDto[] | undefined;
    requestSourcers: EmployeeDto[] | undefined;
    accountManagers: EmployeeDto[] | undefined;
}

export class ClientRequestTrackDtoPaginatedList implements IClientRequestTrackDtoPaginatedList {
    readonly items!: ClientRequestTrackDto[] | undefined;
    readonly pageIndex!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly pageSize!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IClientRequestTrackDtoPaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ClientRequestTrackDto.fromJS(item));
            }
            (<any>this).pageIndex = _data["pageIndex"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).totalCount = _data["totalCount"];
            (<any>this).pageSize = _data["pageSize"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): ClientRequestTrackDtoPaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRequestTrackDtoPaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IClientRequestTrackDtoPaginatedList {
    items: ClientRequestTrackDto[] | undefined;
    pageIndex: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class CountryDto implements ICountryDto {
    id!: number;
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryDto {
    id: number;
    code: string | undefined;
    name: string | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id!: number;
    externalId!: string;
    name!: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IEmployeeDto {
    id: number;
    externalId: string;
    name: string | undefined;
}

export class IdNameDto implements IIdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProjectTypeDto {
    id: number;
    name: string | undefined;
}

export enum RequestProjectTypeValue {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class RequestProjectTypeValueValueNameDto implements IRequestProjectTypeValueValueNameDto {
    value!: RequestProjectTypeValue;
    name!: string | undefined;

    constructor(data?: IRequestProjectTypeValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestProjectTypeValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestProjectTypeValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRequestProjectTypeValueValueNameDto {
    value: RequestProjectTypeValue;
    name: string | undefined;
}

export enum RequestStatusValue {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class RequestStatusValueValueNameDto implements IRequestStatusValueValueNameDto {
    value!: RequestStatusValue;
    name!: string | undefined;

    constructor(data?: IRequestStatusValueValueNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RequestStatusValueValueNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusValueValueNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRequestStatusValueValueNameDto {
    value: RequestStatusValue;
    name: string | undefined;
}

export class SimplePublicObject implements ISimplePublicObject {
    id!: string;
    properties!: { [key: string]: string; };
    createdAt!: moment.Moment;
    updatedAt!: moment.Moment;
    archived!: boolean | undefined;
    archivedAt!: moment.Moment | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: ISimplePublicObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.archived = _data["archived"];
            this.archivedAt = _data["archivedAt"] ? moment(_data["archivedAt"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimplePublicObject {
        data = typeof data === 'object' ? data : {};
        let result = new SimplePublicObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["archivedAt"] = this.archivedAt ? this.archivedAt.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data; 
    }
}

export interface ISimplePublicObject {
    id: string;
    properties: { [key: string]: string; };
    createdAt: moment.Moment;
    updatedAt: moment.Moment;
    archived: boolean | undefined;
    archivedAt: moment.Moment | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export class SimpleRequestLocationDto implements ISimpleRequestLocationDto {
    id!: number;
    country!: IdNameDto;
    city!: IdNameDto;

    constructor(data?: ISimpleRequestLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.country = _data["country"] ? IdNameDto.fromJS(_data["country"]) : <any>undefined;
            this.city = _data["city"] ? IdNameDto.fromJS(_data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SimpleRequestLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleRequestLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISimpleRequestLocationDto {
    id: number;
    country: IdNameDto;
    city: IdNameDto;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}